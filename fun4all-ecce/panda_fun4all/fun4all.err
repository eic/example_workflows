In file included from input_line_11:1:
/gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:10: error: 'G4Setup_sPHENIX.C' file not found with <angled> include; use "quotes" instead
#include <G4Setup_sPHENIX.C>
         ^~~~~~~~~~~~~~~~~~~
         "G4Setup_sPHENIX.C"
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4BlockCellGeom_Dict: '
#line 1 "PHG4BlockCellGeom_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4BlockCellGeom;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4BlockCellGeomContainer_Dict: '
#line 1 "PHG4BlockCellGeomContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4BlockCellGeomContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4BlockGeom_Dict: '
#line 1 "PHG4BlockGeom_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4BlockGeom;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4BlockGeomContainer_Dict: '
#line 1 "PHG4BlockGeomContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4BlockGeomContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4BlockGeomv1_Dict: '
#line 1 "PHG4BlockGeomv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4BlockGeomv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4Cell_Dict: '
#line 1 "PHG4Cell_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4Cell;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4Cellv1_Dict: '
#line 1 "PHG4Cellv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4Cellv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CellContainer_Dict: '
#line 1 "PHG4CellContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CellContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeom_Dict: '
#line 1 "PHG4CylinderGeom_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeom;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeomv1_Dict: '
#line 1 "PHG4CylinderGeomv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeomv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeomv2_Dict: '
#line 1 "PHG4CylinderGeomv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeomv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeomv3_Dict: '
#line 1 "PHG4CylinderGeomv3_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeomv3;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeomv4_Dict: '
#line 1 "PHG4CylinderGeomv4_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeomv4;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeom_Spacalv1_Dict: '
#line 1 "PHG4CylinderGeom_Spacalv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeom_Spacalv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeom_Spacalv2_Dict: '
#line 1 "PHG4CylinderGeom_Spacalv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeom_Spacalv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeom_Spacalv3_Dict: '
#line 1 "PHG4CylinderGeom_Spacalv3_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeom_Spacalv3;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderGeomContainer_Dict: '
#line 1 "PHG4CylinderGeomContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderGeomContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderCell_Dict: '
#line 1 "PHG4CylinderCell_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderCell;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderCellv1_Dict: '
#line 1 "PHG4CylinderCellv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderCellv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderCellv2_Dict: '
#line 1 "PHG4CylinderCellv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderCellv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderCellv3_Dict: '
#line 1 "PHG4CylinderCellv3_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderCellv3;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderCellContainer_Dict: '
#line 1 "PHG4CylinderCellContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderCellContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderCellGeom_Dict: '
#line 1 "PHG4CylinderCellGeom_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderCellGeom;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderCellGeom_Spacalv1_Dict: '
#line 1 "PHG4CylinderCellGeom_Spacalv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderCellGeom_Spacalv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4CylinderCellGeomContainer_Dict: '
#line 1 "PHG4CylinderCellGeomContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4CylinderCellGeomContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4ScintillatorSlat_Dict: '
#line 1 "PHG4ScintillatorSlat_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4ScintillatorSlat;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4ScintillatorSlatv1_Dict: '
#line 1 "PHG4ScintillatorSlatv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4ScintillatorSlatv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module PHG4ScintillatorSlatContainer_Dict: '
#line 1 "PHG4ScintillatorSlatContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class PHG4ScintillatorSlatContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module BbcVertex_Dict: '
#line 1 "BbcVertex_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class BbcVertex;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module BbcVertexv1_Dict: '
#line 1 "BbcVertexv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class BbcVertexv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module BbcVertexMap_Dict: '
#line 1 "BbcVertexMap_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class BbcVertexMap;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module BbcVertexMapv1_Dict: '
#line 1 "BbcVertexMapv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class BbcVertexMapv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrack_Dict: '
#line 1 "SvtxTrack_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrack;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrackState_Dict: '
#line 1 "SvtxTrackState_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrackState;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrackState_v1_Dict: '
#line 1 "SvtxTrackState_v1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrackState_v1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrack_v1_Dict: '
#line 1 "SvtxTrack_v1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrack_v1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrack_v2_Dict: '
#line 1 "SvtxTrack_v2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrack_v2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrack_FastSim_Dict: '
#line 1 "SvtxTrack_FastSim_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrack_FastSim;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrack_FastSim_v1_Dict: '
#line 1 "SvtxTrack_FastSim_v1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrack_FastSim_v1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrack_FastSim_v2_Dict: '
#line 1 "SvtxTrack_FastSim_v2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrack_FastSim_v2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrackMap_Dict: '
#line 1 "SvtxTrackMap_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrackMap;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxTrackMap_v1_Dict: '
#line 1 "SvtxTrackMap_v1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxTrackMap_v1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxVertex_Dict: '
#line 1 "SvtxVertex_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxVertex;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxVertex_v1_Dict: '
#line 1 "SvtxVertex_v1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxVertex_v1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxVertexMap_Dict: '
#line 1 "SvtxVertexMap_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxVertexMap;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module SvtxVertexMap_v1_Dict: '
#line 1 "SvtxVertexMap_v1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class SvtxVertexMap_v1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrCluster_Dict: '
#line 1 "TrkrCluster_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrCluster;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterv1_Dict: '
#line 1 "TrkrClusterv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterv2_Dict: '
#line 1 "TrkrClusterv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterContainer_Dict: '
#line 1 "TrkrClusterContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterContainerv1_Dict: '
#line 1 "TrkrClusterContainerv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterContainerv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterContainerv2_Dict: '
#line 1 "TrkrClusterContainerv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterContainerv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterContainerv3_Dict: '
#line 1 "TrkrClusterContainerv3_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterContainerv3;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterHitAssoc_Dict: '
#line 1 "TrkrClusterHitAssoc_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterHitAssoc;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterHitAssocv1_Dict: '
#line 1 "TrkrClusterHitAssocv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterHitAssocv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterHitAssocv2_Dict: '
#line 1 "TrkrClusterHitAssocv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterHitAssocv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrClusterHitAssocv3_Dict: '
#line 1 "TrkrClusterHitAssocv3_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrClusterHitAssocv3;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHit_Dict: '
#line 1 "TrkrHit_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHit;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHitv1_Dict: '
#line 1 "TrkrHitv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHitv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHitv2_Dict: '
#line 1 "TrkrHitv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHitv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHitTruthAssoc_Dict: '
#line 1 "TrkrHitTruthAssoc_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHitTruthAssoc;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHitTruthAssocv1_Dict: '
#line 1 "TrkrHitTruthAssocv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHitTruthAssocv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHitSet_Dict: '
#line 1 "TrkrHitSet_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHitSet;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHitSetv1_Dict: '
#line 1 "TrkrHitSetv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHitSetv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHitSetContainer_Dict: '
#line 1 "TrkrHitSetContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHitSetContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrkrHitSetContainerv1_Dict: '
#line 1 "TrkrHitSetContainerv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrkrHitSetContainerv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module CylinderGeomMicromegas_Dict: '
#line 1 "CylinderGeomMicromegas_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class CylinderGeomMicromegas;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module MicromegasTile_Dict: '
#line 1 "MicromegasTile_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class MicromegasTile;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module CylinderGeomIntt_Dict: '
#line 1 "CylinderGeomIntt_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class CylinderGeomIntt;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module CylinderGeom_Mvtx_Dict: '
#line 1 "CylinderGeom_Mvtx_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class CylinderGeom_Mvtx;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module GlobalVertex_Dict: '
#line 1 "GlobalVertex_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class GlobalVertex;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module GlobalVertexv1_Dict: '
#line 1 "GlobalVertexv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class GlobalVertexv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module GlobalVertexMap_Dict: '
#line 1 "GlobalVertexMap_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class GlobalVertexMap;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module GlobalVertexMapv1_Dict: '
#line 1 "GlobalVertexMapv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class GlobalVertexMapv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrackEvaluationContainer_Dict: '
#line 1 "TrackEvaluationContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrackEvaluationContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TrackEvaluationContainerv1_Dict: '
#line 1 "TrackEvaluationContainerv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TrackEvaluationContainerv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module Jet_Dict: '
#line 1 "Jet_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class Jet;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module Jetv1_Dict: '
#line 1 "Jetv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class Jetv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module JetMap_Dict: '
#line 1 "JetMap_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class JetMap;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module JetMapv1_Dict: '
#line 1 "JetMapv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class JetMapv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawCluster_Dict: '
#line 1 "RawCluster_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawCluster;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawClusterv1_Dict: '
#line 1 "RawClusterv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawClusterv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawClusterContainer_Dict: '
#line 1 "RawClusterContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawClusterContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTower_Dict: '
#line 1 "RawTower_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTower;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerv1_Dict: '
#line 1 "RawTowerv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerv2_Dict: '
#line 1 "RawTowerv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerContainer_Dict: '
#line 1 "RawTowerContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerDeadMap_Dict: '
#line 1 "RawTowerDeadMap_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerDeadMap;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerGeom_Dict: '
#line 1 "RawTowerGeom_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerGeom;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerDeadMapv1_Dict: '
#line 1 "RawTowerDeadMapv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerDeadMapv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerGeomv1_Dict: '
#line 1 "RawTowerGeomv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerGeomv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerGeomv2_Dict: '
#line 1 "RawTowerGeomv2_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerGeomv2;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerGeomv3_Dict: '
#line 1 "RawTowerGeomv3_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerGeomv3;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerGeomContainer_Dict: '
#line 1 "RawTowerGeomContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerGeomContainer;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerGeomContainerv1_Dict: '
#line 1 "RawTowerGeomContainerv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerGeomContainerv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module RawTowerGeomContainer_Cylinderv1_Dict: '
#line 1 "RawTowerGeomContainer_Cylinderv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class RawTowerGeomContainer_Cylinderv1;
'
Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4Cell with content:

#line 1 "PHG4Cell_Dict dictionary payload"

#ifndef CGAL_DISABLE_ROUNDING_MATH_CHECK
  #define CGAL_DISABLE_ROUNDING_MATH_CHECK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
#ifndef G4DETECTORS_PHG4CELL_H
#define G4DETECTORS_PHG4CELL_H

#include "PHG4CellDefs.h"

#include <g4main/PHG4HitDefs.h>  // for keytype

#include <phool/PHObject.h>

#include <cmath>
#include <climits>
#include <iostream>              // for ostream, cout, operator<<, endl, bas...
#include <map>
#include <string>                // for string
#include <utility>               // for pair, make_pair

class PHG4Cell: public PHObject
{
 public:
  typedef std::map<PHG4HitDefs::keytype, float> EdepMap;
  typedef EdepMap::iterator EdepIterator;
  typedef EdepMap::const_iterator EdepConstIterator;
  typedef std::pair<EdepIterator, EdepIterator> EdepRange;
  typedef std::pair<EdepConstIterator, EdepConstIterator> EdepConstRange;

  typedef std::map<int, float> ShowerEdepMap;
  typedef ShowerEdepMap::iterator ShowerEdepIterator;
  typedef ShowerEdepMap::const_iterator ShowerEdepConstIterator;
  typedef std::pair<ShowerEdepIterator, ShowerEdepIterator> ShowerEdepRange;
  typedef std::pair<ShowerEdepConstIterator, ShowerEdepConstIterator> ShowerEdepConstRange;

  virtual ~PHG4Cell() {}

  virtual void identify(std::ostream& os = std::cout) const;
  virtual void CopyFrom(const PHObject *phobj);
  friend std::ostream &operator<<(std::ostream & stream, const PHG4Cell * cell);
  virtual void Reset();

  // all methods connected to the cell id (encoding/decoding
  virtual void set_cellid(const PHG4CellDefs::keytype i) {return;}

  virtual PHG4CellDefs::keytype get_cellid() const {return ~0x0;}
  virtual bool has_binning(const PHG4CellDefs::CellBinning) const {return false;}

  // this adds hits to the g4 hit list map
  virtual void add_edep(const PHG4HitDefs::keytype g4hitid, const float edep) {return;}
  virtual void add_edep(const PHG4HitDefs::keytype g4hitid, const float edep, const float light_yield) {return;}
  virtual void add_edep(const PHG4HitDefs::keytype g4hitid, const int tbin, const float edep) {return;}
  // this adds showers to the shower map
  virtual void add_shower_edep(const int g4showerid, const float edep) {return;}

  virtual EdepConstRange get_g4hits();

  virtual ShowerEdepConstRange get_g4showers();

  virtual short int get_detid() const {return -1;}
  // for backward compatibility, layers and detector ids are identical
  short int get_layer() const {return get_detid();}

  virtual void add_edep(const float f) {return;}
  virtual double get_edep() const {return NAN;}

  virtual void add_eion(const float f) {return;}
  virtual double get_eion() const {return NAN;}

  virtual void add_light_yield(const float lightYield){return;}
  virtual float get_light_yield() const {return NAN;}

  // get/set methodes - PLEASE add those ALPHABETICALLY

  virtual void set_chip_index(const int i) {return;}
  virtual int get_chip_index() const {return ~0x0;}

  virtual void set_half_stave_index(const int i) {return;}
  virtual int get_half_stave_index() const {return ~0x0;}

  virtual void set_ladder_phi_index(const int i) {return;}
  virtual int get_ladder_phi_index() const {return ~0x0;}

  virtual void set_ladder_z_index(const int i) {return;}
  virtual int get_ladder_z_index() const {return ~0x0;}

  virtual void set_module_index(const int i) {return;}
  virtual int get_module_index() const {return ~0x0;}

  virtual void set_phibin(const int i) {return;}
  virtual int get_phibin() const {return ~0x0;}

  virtual void set_pixel_index(const int i) {return;}
  virtual int get_pixel_index() const {return ~0x0;}

  virtual void set_stave_index(const int i) {return;}
  virtual int get_stave_index() const {return ~0x0;}

//  virtual tpctod* get_train_of_digits() {return 0;}

  virtual void set_zbin(const int i) {return;}
  virtual int get_zbin() const {return ~0x0;}


  virtual void print() const {std::cout<<"virtual PHG4Cell"<<std::endl;}

  //! Procedure to add a new PROPERTY tag:
  //! 1.add new tag below with unique value,
  //! 2.add a short name to PHG4Cell::get_property_info
  enum PROPERTY 
  {//
    // first various coordinates 1-20
    //! Maps coordinates
    prop_stave_index = 1,
    prop_half_stave_index = 2,
    prop_module_index = 3,
    prop_chip_index = 4,
    prop_pixel_index = 5,
    prop_phibin = 6,
    prop_zbin = 7,
    prop_ladder_z_index = 8,
    prop_ladder_phi_index = 9,
    //-- summed energy:  - 20-30  --
    //! deposited energy
    prop_edep = 21,
    //! ionizing energy loss
    prop_eion = 22,

    //! for scintillation detectors, the amount of light produced
    prop_light_yield = 23,

    //! max limit in order to fit into 8 bit unsigned number
    prop_MAX_NUMBER = UCHAR_MAX
  };

  enum PROPERTY_TYPE 
  {//
    type_int = 1,
    type_uint = 2,
    type_float = 3,
    type_unknown = -1
  };

  virtual bool  has_property(const PROPERTY prop_id) const {return false;}
  virtual float get_property_float(const PROPERTY prop_id) const {return NAN;}
  virtual int   get_property_int(const PROPERTY prop_id) const {return INT_MIN;}
  virtual unsigned int   get_property_uint(const PROPERTY prop_id) const {return UINT_MAX;}
  virtual void  set_property(const PROPERTY prop_id, const float value) {return;}
  virtual void  set_property(const PROPERTY prop_id, const int value) {return;}
  virtual void  set_property(const PROPERTY prop_id, const unsigned int value) {return;}
  static std::pair<const std::string,PROPERTY_TYPE> get_property_info(PROPERTY prop_id);
  static bool check_property(const PROPERTY prop_id, const PROPERTY_TYPE prop_type);
  static std::string get_property_type(const PROPERTY_TYPE prop_type);

 protected:
  PHG4Cell() {}
  virtual unsigned int get_property_nocheck(const PROPERTY prop_id) const {return UINT_MAX;}
  virtual void set_property_nocheck(const PROPERTY prop_id,const unsigned int) {return;}
  ClassDef(PHG4Cell,2)
};


#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4CylinderGeom with content:

#line 1 "PHG4CylinderGeom_Dict dictionary payload"

#ifndef CGAL_DISABLE_ROUNDING_MATH_CHECK
  #define CGAL_DISABLE_ROUNDING_MATH_CHECK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
#ifndef G4DETECTORS_PHG4CYLINDERGEOM_H
#define G4DETECTORS_PHG4CYLINDERGEOM_H

#include <phool/PHObject.h>

#include <phool/phool.h>

#include <cmath>
#include <iostream>          // for cout, ostream

class PHParameters;

class PHG4CylinderGeom: public PHObject
{
 public:

  virtual ~PHG4CylinderGeom() {}

  virtual void identify(std::ostream& os = std::cout) const;
  virtual int get_layer() const {PHOOL_VIRTUAL_WARN("get_layer()"); return -99999;}
  virtual double get_radius() const {PHOOL_VIRTUAL_WARN("get_radius()");return NAN;}
  virtual double get_thickness() const {PHOOL_VIRTUAL_WARN("get_thickness()");return NAN;}
  virtual double get_zmin() const {PHOOL_VIRTUAL_WARN("get_zmin()");return NAN;}
  virtual double get_zmax() const {PHOOL_VIRTUAL_WARN("get_zmax()");return NAN;}
  virtual int get_nscint() const {PHOOL_VIRTUAL_WARN("get_nscint()"); return -99999;}
  virtual double get_tiltangle() const {PHOOL_VIRTUAL_WARN("get_tiltangle()");return NAN;}
  virtual double get_phi_slat_zero() const {PHOOL_VIRTUAL_WARN("get_phi_slat_zero()"); return NAN;}

  virtual void set_layer(const int i) {PHOOL_VIRTUAL_WARN("set_layer(const int)");}
  virtual void set_radius(const double r) {PHOOL_VIRTUAL_WARN("set_radius(const double)");}
  virtual void set_thickness(const double t) {PHOOL_VIRTUAL_WARN("set_thickness(const double)");}
  virtual void set_zmin(const double z) {PHOOL_VIRTUAL_WARN("set_zmin(const double)");}
  virtual void set_zmax(const double z) {PHOOL_VIRTUAL_WARN("set_zmax(const double)");}
  virtual void set_nscint(const int i) {PHOOL_VIRTUAL_WARN("set_nscint(const int)"); return;}
  virtual void set_tiltangle(const double i) {PHOOL_VIRTUAL_WARN("set_tiltangle(const double)"); return;}
  virtual void set_phi_slat_zero (const double phi) {PHOOL_VIRTUAL_WARN("set_phi_slat_zero (const double)"); return;}

  virtual void find_segment_center(const int segment_z_bin, const int segment_phi_bin, double location[]){PHOOL_VIRTUAL_WARN("find_sensor_center"); return;}
  virtual void find_strip_center(const int segment_z_bin, const int segment_phi_bin, const int strip_column, const int strip_index, double location[]){PHOOL_VIRTUAL_WARN("find_strip_center"); return;}
 virtual void find_strip_index_values(const int segment_z_bin, const double ypos, const double zpos, int &strip_y_index, int &strip_z_index){PHOOL_VIRTUAL_WARN("find_strip_index_values"); return;}
  virtual void find_strip_center_local_coords(const int segment_z_bin, const int strip_y_index, const int strip_z_index, double location[]){PHOOL_VIRTUAL_WARN("find_strip_center_localcoords"); return;}

  virtual double get_strip_y_spacing() const {PHOOL_VIRTUAL_WARN("get_strip_y_spacing"); return NAN;}
  virtual double get_strip_z_spacing() const {PHOOL_VIRTUAL_WARN("get_strip_z_spacing"); return NAN;}
  virtual double get_strip_tilt() const {PHOOL_VIRTUAL_WARN("get_strip_tilt"); return NAN;}

  virtual int get_N_strip_columns() const {PHOOL_VIRTUAL_WARN("get_N_strip_columns"); return -9999;}
  virtual int get_N_strips_per_column() const {PHOOL_VIRTUAL_WARN("get_N_strips_per_column"); return -9999;}
  virtual int get_N_sensors_in_layer() const {PHOOL_VIRTUAL_WARN("get_N_sensors_in_layer"); return -9999;}

  virtual double get_pixel_z() const {PHOOL_VIRTUAL_WARN("get_pixel_z"); return NAN;}
  virtual double get_pixel_x() const {PHOOL_VIRTUAL_WARN("get_pixel_x"); return NAN;}
  virtual double get_pixel_thickness() const {PHOOL_VIRTUAL_WARN("get_pixel_thickness"); return NAN;}

  //! load parameters from PHParameters, which interface to Database/XML/ROOT files
  virtual void ImportParameters(const PHParameters & param) {return ;}

 protected:
  PHG4CylinderGeom() {}

  ClassDef(PHG4CylinderGeom,1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:9:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_CEmc_Spacal.C:8:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeom_Spacalv1.h:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeomv2.h:6:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeomv1.h:6:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeom.h:63:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(PHG4CylinderGeom,1)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4CylinderGeomv1 with content:

#line 1 "PHG4CylinderGeomv1_Dict dictionary payload"

#ifndef CGAL_DISABLE_ROUNDING_MATH_CHECK
  #define CGAL_DISABLE_ROUNDING_MATH_CHECK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
#ifndef G4DETECTORS_PHG4CYLINDERGEOMV1_H
#define G4DETECTORS_PHG4CYLINDERGEOMV1_H

#include "PHG4CylinderGeom.h"

#include <iostream>  // for cout, ostream

class PHParameters;

class PHG4CylinderGeomv1 : public PHG4CylinderGeom
{
 public:
  PHG4CylinderGeomv1();
  PHG4CylinderGeomv1(const double r, const double zmi, const double zma, const double thickn)
    : layer(-1)
    , radius(r)
    , zmin(zmi)
    , zmax(zma)
    , thickness(thickn)
  {
  }

  virtual ~PHG4CylinderGeomv1() {}

  void identify(std::ostream& os = std::cout) const;
  int get_layer() const { return layer; }
  double get_radius() const { return radius; }
  double get_thickness() const { return thickness; }
  double get_zmin() const { return zmin; }
  double get_zmax() const { return zmax; }

  void set_layer(const int i) { layer = i; }
  void set_radius(const double r) { radius = r; }
  void set_thickness(const double t) { thickness = t; }
  void set_zmin(const double z) { zmin = z; }
  void set_zmax(const double z) { zmax = z; }

  //! load parameters from PHParameters, which interface to Database/XML/ROOT files
  virtual void ImportParameters(const PHParameters& param);

 protected:
  int layer;
  double radius;
  double zmin;
  double zmax;
  double thickness;

  ClassDef(PHG4CylinderGeomv1, 1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:9:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_CEmc_Spacal.C:8:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeom_Spacalv1.h:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeomv2.h:6:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeomv1.h:50:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(PHG4CylinderGeomv1, 1)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4CylinderGeomv2 with content:

#line 1 "PHG4CylinderGeomv2_Dict dictionary payload"

#ifndef CGAL_DISABLE_ROUNDING_MATH_CHECK
  #define CGAL_DISABLE_ROUNDING_MATH_CHECK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
#ifndef G4DETECTORS_PHG4CYLINDERGEOMV2_H
#define G4DETECTORS_PHG4CYLINDERGEOMV2_H

#include "PHG4CylinderGeomv1.h"

#include <iostream>              // for cout, ostream

class PHParameters;

class PHG4CylinderGeomv2: public PHG4CylinderGeomv1
{
 public:
  PHG4CylinderGeomv2();
  PHG4CylinderGeomv2(const double r, const double zmi, const double zma, const double thickn, const int n_scint):
    PHG4CylinderGeomv1(r,zmi,zma,thickn),
    nscint(n_scint)
      {}

  virtual ~PHG4CylinderGeomv2() {}

  void identify(std::ostream& os = std::cout) const;
  void set_nscint(const int i) {nscint = i;}
  int get_nscint() const {return nscint;}

  //! load parameters from PHParameters, which interface to Database/XML/ROOT files
  virtual void ImportParameters(const PHParameters & param);

 protected:
  int nscint;

  ClassDef(PHG4CylinderGeomv2,1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:9:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_CEmc_Spacal.C:8:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeom_Spacalv1.h:15:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeomv2.h:33:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(PHG4CylinderGeomv2,1)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4CylinderGeom_Spacalv1 with content:

#line 1 "PHG4CylinderGeom_Spacalv1_Dict dictionary payload"

#ifndef CGAL_DISABLE_ROUNDING_MATH_CHECK
  #define CGAL_DISABLE_ROUNDING_MATH_CHECK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
// $$Id: PHG4CylinderGeom_Spacalv1.h,v 1.2 2014/08/12 03:49:12 jinhuang Exp $$

/*!
 * \file ${file_name}
 * \brief
 * \author Jin Huang <jhuang@bnl.gov>
 * \version $$Revision: 1.2 $$
 * \date $$Date: 2014/08/12 03:49:12 $$
 */
#ifndef G4DETECTORS_PHG4CYLINDERGEOMSPACALV1_H
#define G4DETECTORS_PHG4CYLINDERGEOMSPACALV1_H

#include "PHG4CylinderGeomv2.h"

#include <iostream>              // for cout, ostream
#include <map>
#include <string>

class PHParameters;

class PHG4CylinderGeom_Spacalv1 : public PHG4CylinderGeomv2
{
 public:
  /** @name Ctor DTor and IDs
   */
  ///@{
  PHG4CylinderGeom_Spacalv1();

  virtual ~PHG4CylinderGeom_Spacalv1()
  {
    sector_map.clear();
  }

  virtual void
  identify(std::ostream &os = std::cout) const;

  virtual void
  Print(Option_t *option = "") const;

  virtual void
  SetDefault();

  //! load parameters from PHParameters, which interface to Database/XML/ROOT files
  virtual void ImportParameters(const PHParameters &param);

  ///@}

  /** @name Set Cylinder Geometry
   */
  ///@{
  double
  get_max_radius() const
  {
    return get_radius() + get_thickness();
  }

  double
  get_half_radius() const
  {
    return get_radius() + get_thickness() / 2.;
  }

  double
  get_length() const
  {
    return get_zmax() - get_zmin();
  }

  double
  get_xpos() const
  {
    return xpos;
  }

  void
  set_xpos(double xpos)
  {
    this->xpos = xpos;
  }

  double
  get_ypos() const
  {
    return ypos;
  }

  void
  set_ypos(double ypos)
  {
    this->ypos = ypos;
  }

  double
  get_zpos() const
  {
    return zpos;
  }

  void
  set_zpos(double zpos)
  {
    this->zpos = zpos;
  }

  ///@}

  /** @name Azimuthal segments
   */
  ///@{
  virtual int
  get_azimuthal_n_sec() const;

  virtual double
  get_azimuthal_distance() const;

  virtual double
  get_z_distance() const;

  //! sector map sector_ID -> azimuthal rotation.
  typedef std::map<int, double> sector_map_t;

  //! sector map sector_ID -> azimuthal rotation.
  const sector_map_t &
  get_sector_map() const
  {
    return sector_map;
  }

  //! sector map sector_ID -> azimuthal rotation.
  sector_map_t &
  get_sector_map()
  {
    return sector_map;
  }

  //! load a default map that populate all the sectors
  void
  init_default_sector_map();

  ///@}

  /** @name Fiber geometry
   */
  ///@{
  double
  get_fiber_outer_r() const
  {
    return get_fiber_clading_thickness() + get_fiber_core_diameter() / 2;
  }

  double
  get_fiber_clading_thickness() const
  {
    return fiber_clading_thickness;
  }

  void
  set_fiber_clading_thickness(double fiberCladingThickness)
  {
    fiber_clading_thickness = fiberCladingThickness;
  }

  double
  get_fiber_core_diameter() const
  {
    return fiber_core_diameter;
  }

  void
  set_fiber_core_diameter(double fiberCoreDiameter)
  {
    fiber_core_diameter = fiberCoreDiameter;
  }

  double
  get_fiber_distance() const
  {
    return fiber_distance;
  }

  void
  set_fiber_distance(double fiberDistance)
  {
    fiber_distance = fiberDistance;
  }

  ///@}

  /** @name Materials
   */
  ///@{
  std::string
  get_absorber_mat() const
  {
    return absorber_mat;
  }

  void
  set_absorber_mat(const std::string &absorberMat)
  {
    absorber_mat = absorberMat;
  }

  std::string
  get_fiber_clading_mat() const
  {
    return fiber_clading_mat;
  }

  void
  set_fiber_clading_mat(const std::string &fiberCladingMat)
  {
    fiber_clading_mat = fiberCladingMat;
  }

  std::string
  get_fiber_core_mat() const
  {
    return fiber_core_mat;
  }

  void
  set_fiber_core_mat(const std::string &fiberCoreMat)
  {
    fiber_core_mat = fiberCoreMat;
  }

  ///@}

  /** @name General options
   */
  ///@{

  double
  get_fiber_core_step_size() const
  {
    return get_fiber_core_diameter() / 10.;
  }

  enum config_t
  {

    //! fiber always placed radially
    kNonProjective = 0,
    //! alias of above, more explicit
    k1DProjectiveSpacal = kNonProjective,

    //! Fully projective spacal with 2D tapered modules
    kFullProjective_2DTaper = 2,

    //! Fully projective spacal with 2D tapered modules. To speed up construction, same-length fiber is used cross one tower
    kFullProjective_2DTaper_SameLengthFiberPerTower = 3,

    //! Fully projective spacal with 2D tapered modules and allow azimuthal tilts
    kFullProjective_2DTaper_Tilted = 4,

    //! Fully projective spacal with 2D tapered modules and allow azimuthal tilts. To speed up construction, same-length fiber is used cross one tower
    kFullProjective_2DTaper_Tilted_SameLengthFiberPerTower = 5,

    //! alias of above, the default 2D-projective SPACAL
    k2DProjectiveSpacal = kFullProjective_2DTaper_Tilted_SameLengthFiberPerTower,

    //! max allowed value, for boundary cross check
    kInvalidSpacalConfig
  };

  config_t
  get_config() const
  {
    return config;
  }

  void
  set_config(config_t config)
  {
    this->config = config;
  }

  bool
  is_virualize_fiber() const
  {
    return virualize_fiber;
  }

  virtual bool is_azimuthal_seg_visible() const
  {
    return false;
  }

  void
  set_virualize_fiber(bool virualizeFiber = true)
  {
    virualize_fiber = virualizeFiber;
  }

  int get_construction_verbose() const
  {
    return construction_verbose;
  }

  void
  set_construction_verbose(int constructionVerbose)
  {
    construction_verbose = constructionVerbose;
  }

  ///@}

 protected:
  std::string absorber_mat;
  std::string fiber_core_mat;
  std::string fiber_clading_mat;
  double xpos;
  double ypos;
  double zpos;
  double fiber_core_diameter;
  double fiber_clading_thickness;
  double fiber_distance;
  config_t config;
  bool virualize_fiber;
  int construction_verbose;

  //! sector map sector_ID -> azimuthal rotation.
  sector_map_t sector_map;

  ClassDef(PHG4CylinderGeom_Spacalv1, 2)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:9:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_CEmc_Spacal.C:8:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4detectors/PHG4CylinderGeom_Spacalv1.h:328:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(PHG4CylinderGeom_Spacalv1, 2)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class RawTowerContainer with content:

#line 1 "RawTowerContainer_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef CALOBASE_RAWTOWERCONTAINER_H
#define CALOBASE_RAWTOWERCONTAINER_H

#include "RawTowerDefs.h"

#include <phool/PHObject.h>

#include <iostream>
#include <map>
#include <utility>

class RawTower;

class RawTowerContainer : public PHObject
{
 public:
  typedef std::map<RawTowerDefs::keytype, RawTower *> Map;
  typedef Map::iterator Iterator;
  typedef Map::const_iterator ConstIterator;
  typedef std::pair<Iterator, Iterator> Range;
  typedef std::pair<ConstIterator, ConstIterator> ConstRange;

  RawTowerContainer(RawTowerDefs::CalorimeterId caloid = RawTowerDefs::NONE)
    : _caloid(caloid)
  {
  }

  virtual ~RawTowerContainer() {}

  void Reset();
  int isValid() const;
  void identify(std::ostream &os = std::cout) const;

  void setCalorimeterID(RawTowerDefs::CalorimeterId caloid) { _caloid = caloid; }
  RawTowerDefs::CalorimeterId getCalorimeterID() { return _caloid; }

  ConstIterator AddTower(const unsigned int ieta, const unsigned int iphi, RawTower *twr);
  ConstIterator AddTower(RawTowerDefs::keytype key, RawTower *twr);

  RawTower *getTower(RawTowerDefs::keytype key);
  const RawTower *getTower(RawTowerDefs::keytype key) const;

  RawTower *getTower(const unsigned int ieta, const unsigned int iphi);
  const RawTower *getTower(const unsigned int ieta, const unsigned int iphi) const;

  //! return all towers
  ConstRange getTowers(void) const;
  Range getTowers(void);

  unsigned int size() const { return _towers.size(); }
  void compress(const double emin);
  double getTotalEdep() const;

 protected:
  RawTowerDefs::CalorimeterId _caloid;
  Map _towers;

  ClassDef(RawTowerContainer, 1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class RawTowerGeomContainer with content:

#line 1 "RawTowerGeomContainer_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef CALOBASE_RAWTOWERGEOMCONTAINER_H
#define CALOBASE_RAWTOWERGEOMCONTAINER_H

#include "RawTowerDefs.h"

#include <phool/PHObject.h>
#include <phool/phool.h>

#include <cmath>
#include <cstddef>
#include <iostream>
#include <map>
#include <type_traits>
#include <utility>


class RawTowerGeom;

/*! \class RawTowerGeomContainer
    \brief base class to describe calorimeter geometries
*/
class RawTowerGeomContainer : public PHObject
{
 public:
  typedef std::map<RawTowerDefs::keytype, RawTowerGeom *> Map;
  typedef Map::iterator Iterator;
  typedef Map::const_iterator ConstIterator;
  typedef std::pair<Iterator, Iterator> Range;
  typedef std::pair<ConstIterator, ConstIterator> ConstRange;

  //! default constructor for ROOT IO
  virtual ~RawTowerGeomContainer() {}

  virtual void identify(std::ostream &os = std::cout) const;

  //! 8-bit calorimeter ID
  virtual void set_calorimeter_id(RawTowerDefs::CalorimeterId) { PHOOL_VIRTUAL_WARN("set_calorimeter_id()"); }
  virtual RawTowerDefs::CalorimeterId get_calorimeter_id() const
  {
    PHOOL_VIRTUAL_WARN("get_calorimeter_id()");
    return RawTowerDefs::NONE;
  }

  //! go through all towers
  virtual ConstIterator add_tower_geometry(RawTowerGeom *geo);
  virtual RawTowerGeom *get_tower_geometry(RawTowerDefs::keytype key)
  {
    PHOOL_VIRTUAL_WARN("get_tower_geometry()");
    return NULL;
  }

  //! return all tower geometries
  virtual ConstRange get_tower_geometries(void) const;
  virtual Range get_tower_geometries(void);

  virtual unsigned int size() const
  {
    PHOOL_VIRTUAL_WARN("size()");
    return 0;
  }

  /**
   * \defgroup cylindrical_calorimeter for cylindrical calorimeter only as implemented in RawTowerGeomContainer_Cylinderv1
   *
   *  Note these: concept do not apply to generic calorimeters, like forward calorimeters
   * @{
   */

  virtual double get_radius() const
  {
    PHOOL_VIRTUAL_WARN("get_radius()");
    return NAN;
  }
  virtual double get_thickness() const
  {
    PHOOL_VIRTUAL_WARN("get_thickness()");
    return NAN;
  }
  virtual int get_phibins() const
  {
    PHOOL_VIRTUAL_WARN("get_phibins()");
    return -1;
  }
  //  virtual double get_phistep() const {PHOOL_VIRTUAL_WARN("get_phistep()"); return NAN;}
  //  virtual double get_phimin() const {PHOOL_VIRTUAL_WARN("get_phimin()"); return NAN;}
  virtual int get_etabins() const
  {
    PHOOL_VIRTUAL_WARN("get_etabins()");
    return -1;
  }
  //  virtual double get_etastep() const {PHOOL_VIRTUAL_WARN("get_etastep()"); return NAN;}
  //  virtual double get_etamin() const {PHOOL_VIRTUAL_WARN("get_etamin()"); return NAN;}

  virtual std::pair<double, double> get_phibounds(const int ibin) const
  {
    PHOOL_VIRTUAL_WARN("get_phibounds(const int)");
    return std::make_pair(NAN, NAN);
  }
  virtual std::pair<double, double> get_etabounds(const int ibin) const
  {
    PHOOL_VIRTUAL_WARN("get_etabounds(const int)");
    return std::make_pair(NAN, NAN);
  }
  virtual double get_etacenter(const int ibin) const
  {
    PHOOL_VIRTUAL_WARN("get_etacenter(const int)");
    return NAN;
  }
  virtual double get_phicenter(const int ibin) const
  {
    PHOOL_VIRTUAL_WARN("get_phicenter(const int)");
    return NAN;
  }

  virtual int get_etabin(const double eta) const
  {
    PHOOL_VIRTUAL_WARN("get_etabin(const double)");
    return -1;
  }
  virtual int get_phibin(const double phi) const
  {
    PHOOL_VIRTUAL_WARN("get_phibin(const double)");
    return -1;
  }

  virtual void set_radius(const double r) { PHOOL_VIRTUAL_WARN("set_radius(const double)"); }
  virtual void set_thickness(const double t) { PHOOL_VIRTUAL_WARN("set_thickness(const double)"); }
  virtual void set_phibins(const int i) { PHOOL_VIRTUAL_WARN("set_phibins(const int)"); }
  //  virtual void set_phistep(const double phi) {PHOOL_VIRTUAL_WARN("set_phistep(const double)");}
  //  virtual void set_phimin(const double phi) {PHOOL_VIRTUAL_WARN("set_phimin(const double)");}
  virtual void set_etabins(const int i) { PHOOL_VIRTUAL_WARN("set_etabins(const int)"); }
  //  virtual void set_etamin(const double z) {PHOOL_VIRTUAL_WARN("set_etamin(const double)");}
  //  virtual void set_etastep(const double z) {PHOOL_VIRTUAL_WARN("set_etastep(const double)");}
  virtual void set_etabounds(const int ibin, const std::pair<double, double> &bounds) { PHOOL_VIRTUAL_WARN("set_etabounds(const int ibin, const std::pair<double, double> & bounds)"); }
  virtual void set_phibounds(const int ibin, const std::pair<double, double> &bounds) { PHOOL_VIRTUAL_WARN("set_etabounds(const int ibin, const std::pair<double, double> & bounds)"); }

  /**@}*/

 protected:
  //! this class is not for use. Base class only
  RawTowerGeomContainer() {}

  ClassDef(RawTowerGeomContainer, 2)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class RawTowerDeadMap with content:

#line 1 "RawTowerDeadMap_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef CALOBASE_RAWTOWERDEADMAP_H
#define CALOBASE_RAWTOWERDEADMAP_H

#include "RawTowerDefs.h"

#include <phool/PHObject.h>

#include <iostream>
#include <set>

class RawTowerDeadMap : public PHObject
{
 public:
  typedef std::set<RawTowerDefs::keytype> Map;

  virtual ~RawTowerDeadMap() {}
  virtual void Reset();
  virtual int isValid() const;

  virtual void identify(std::ostream &os = std::cout) const;

  virtual void setCalorimeterID(RawTowerDefs::CalorimeterId caloid) {}
  virtual RawTowerDefs::CalorimeterId getCalorimeterID() { return RawTowerDefs::NONE; }
  virtual void addDeadTower(const unsigned int ieta, const unsigned int iphi);
  virtual void addDeadTower(RawTowerDefs::keytype key);

  virtual bool isDeadTower(RawTowerDefs::keytype key);
  virtual bool isDeadTower(const unsigned int ieta, const unsigned int iphi);
  //! return all towers
  virtual const Map &getDeadTowers(void) const;
  virtual Map &getDeadTowers(void);

  virtual unsigned int size() const { return 0; }

 protected:
  RawTowerDeadMap(RawTowerDefs::CalorimeterId caloid = RawTowerDefs::NONE)
  {
  }

 private:
  ClassDef(RawTowerDeadMap, 1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class RawTower with content:

#line 1 "RawTower_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef CALOBASE_RAWTOWER_H
#define CALOBASE_RAWTOWER_H

#include "RawTowerDefs.h"

#include <g4detectors/PHG4CellDefs.h>

#include <phool/PHObject.h>
#include <phool/phool.h>

#include <climits>
#include <cmath>
#include <iostream>
#include <map>
#include <utility>

class RawTower : public PHObject
{
 public:
  //! key type for cell map which should be consistent with CellKeyType
  typedef unsigned long long CellKeyType;

  typedef std::map<CellKeyType, float> CellMap;
  typedef CellMap::iterator CellIterator;
  typedef CellMap::const_iterator CellConstIterator;
  typedef std::pair<CellIterator, CellIterator> CellRange;
  typedef std::pair<CellConstIterator, CellConstIterator> CellConstRange;

  typedef std::map<int, float> ShowerMap;
  typedef ShowerMap::iterator ShowerIterator;
  typedef ShowerMap::const_iterator ShowerConstIterator;
  typedef std::pair<ShowerIterator, ShowerIterator> ShowerRange;
  typedef std::pair<ShowerConstIterator, ShowerConstIterator> ShowerConstRange;

  virtual ~RawTower() {}

  virtual void Reset() { PHOOL_VIRTUAL_WARNING; }
  virtual int isValid() const
  {
    PHOOL_VIRTUAL_WARN("isValid()");
    return 0;
  }
  virtual void identify(std::ostream& os = std::cout) const { PHOOL_VIRTUAL_WARN("identify()"); }

  virtual void set_id(RawTowerDefs::keytype id) { PHOOL_VIRTUAL_WARN("set_id()"); }
  virtual RawTowerDefs::keytype get_id() const
  {
    PHOOL_VIRTUAL_WARN("get_id()");
    return 0;
  }

  virtual void set_key(RawTowerDefs::keytype id) { set_id(id); }
  virtual RawTowerDefs::keytype get_key() const { return get_id(); }

  virtual int get_bineta() const
  {
    PHOOL_VIRTUAL_WARN("get_bineta()");
    return -1;
  }

  virtual int get_bintheta() const
  {
    return get_bineta();
  }

  virtual int get_binphi() const
  {
    PHOOL_VIRTUAL_WARN("get_binphi()");
    return -1;
  }
  virtual int get_column() const
  {
    PHOOL_VIRTUAL_WARN("get_column()");
    return -1;
  }
  virtual int get_row() const
  {
    PHOOL_VIRTUAL_WARN("get_row()");
    return -1;
  }

  //! energy assigned to the tower. Depending on stage of process and DST node name, it could be energy deposition, light yield or calibrated energies
  virtual double get_energy() const
  {
    PHOOL_VIRTUAL_WARN("get_energy()");
    return 0.0;
  }
  //! energy assigned to the tower. Depending on stage of process and DST node name, it could be energy deposition, light yield or calibrated energies
  virtual void set_energy(const double)
  {
    PHOOL_VIRTUAL_WARN("set_energy()");
    return;
  }

  //! energy assigned to the tower. Depending on stage of process and DST node name, it could be energy deposition, light yield or calibrated energies
  virtual double get_scint_gammas() const
  {
    PHOOL_VIRTUAL_WARN("get_scint_gammas()");
    return 0.0;
  }
  //! scint_gammas assigned to the tower. Depending on stage of process and DST node name, it could be scint_gammas deposition, light yield or calibrated energies
  virtual void set_scint_gammas(const double)
  {
    PHOOL_VIRTUAL_WARN("set_scint_gammas()");
    return;
  }

  //! energy assigned to the tower. Depending on stage of process and DST node name, it could be energy deposition, light yield or calibrated energies
  virtual double get_cerenkov_gammas() const
  {
    PHOOL_VIRTUAL_WARN("get_cerenkov_gammas()");
    return 0.0;
  }
  //! cerenkov_gammas assigned to the tower. Depending on stage of process and DST node name, it could be cerenkov_gammas deposition, light yield or calibrated energies
  virtual void set_cerenkov_gammas(const double)
  {
    PHOOL_VIRTUAL_WARN("set_cerenkov_gammas()");
    return;
  }

  //! Time stamp assigned to the tower. Depending on the tower maker, it could be rise time or peak time.
  virtual float get_time() const
  {
    PHOOL_VIRTUAL_WARN("get_time()");
    return NAN;
  }
  //! Time stamp assigned to the tower. Depending on the tower maker, it could be rise time or peak time.
  virtual void set_time(const float)
  {
    PHOOL_VIRTUAL_WARN("set_time()");
    return;
  }

  virtual bool empty_g4cells() const { return true; }
  virtual size_t size_g4cells() const { return 0; }
  virtual CellConstRange get_g4cells() const;
  virtual CellIterator find_g4cell(CellKeyType id);
  virtual CellConstIterator find_g4cell(CellKeyType id) const;
  virtual void add_ecell(const CellKeyType g4cellid, const float ecell)
  {
    PHOOL_VIRTUAL_WARN("add_ecell(const CellKeyType g4cellid, const float ecell)");
    return;
  }
  virtual void clear_g4cells() {}

  virtual bool empty_g4showers() const { return true; }
  virtual size_t size_g4showers() const { return 0; }
  virtual ShowerConstRange get_g4showers() const;
  virtual ShowerIterator find_g4shower(int id);
  virtual ShowerConstIterator find_g4shower(int id) const;
  virtual void add_eshower(const int g4showerid, const float eshower)
  {
    PHOOL_VIRTUAL_WARN("add_eshower(const unsigned int g4showerid, const float eshower)");
    return;
  }
  virtual void clear_g4showers() {}

  //! Procedure to add a new PROPERTY tag:
  //! 1.add new tag below with unique value,
  //! 2.add a short name to RawTower::get_property_info
  enum PROPERTY
  {  //

    //! Scintillation photon count or energy
    prop_scint_gammas = 1,

    //! Cherenkov photon count or energy
    prop_cerenkov_gammas = 2,

    //! max limit in order to fit into 8 bit unsigned number
    prop_MAX_NUMBER = UCHAR_MAX
  };

  virtual bool has_property(const PROPERTY prop_id) const { return false; }
  virtual double get_property(const PROPERTY prop_id) const { return NAN; }
  virtual void set_property(const PROPERTY prop_id, const double value) { return; }
  static const std::string get_property_info(PROPERTY prop_id);

 protected:
  RawTower() {}

  virtual unsigned int get_property_nocheck(const PROPERTY prop_id) const { return UINT_MAX; }
  virtual void set_property_nocheck(const PROPERTY prop_id, const unsigned int) { return; }

  ClassDef(RawTower, 1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class RawClusterContainer with content:

#line 1 "RawClusterContainer_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef CALOBASE_RAWCLUSTERCONTAINER_H
#define CALOBASE_RAWCLUSTERCONTAINER_H

#include "RawClusterDefs.h"

#include <phool/PHObject.h>

#include <iostream>
#include <map>
#include <utility>

class RawCluster;

class RawClusterContainer : public PHObject
{
 public:
  typedef std::map<RawClusterDefs::keytype, RawCluster *> Map;
  typedef Map::iterator Iterator;
  typedef Map::const_iterator ConstIterator;
  typedef std::pair<Iterator, Iterator> Range;
  typedef std::pair<ConstIterator, ConstIterator> ConstRange;

  RawClusterContainer() {}
  virtual ~RawClusterContainer() {}

  void Reset();
  int isValid() const;
  void identify(std::ostream &os = std::cout) const;
  ConstIterator AddCluster(RawCluster *clus);

  RawCluster *getCluster(const RawClusterDefs::keytype id);
  const RawCluster *getCluster(const RawClusterDefs::keytype id) const;

  //! return all clusters
  ConstRange getClusters(void) const;
  Range getClusters(void);
  const Map &getClustersMap() const { return _clusters; }
  Map &getClustersMap() { return _clusters; }

  unsigned int size() const { return _clusters.size(); }
  double getTotalEdep() const;

 protected:
  Map _clusters;

  ClassDef(RawClusterContainer, 1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class TrkrCluster with content:

#line 1 "TrkrCluster_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/**
 * @file trackbase/TrkrCluster.h
 * @author D. McGlinchey
 * @date June 2018
 * @brief Base class for cluster object
 */
#ifndef TRACKBASE_TRKRCLUSTER_H
#define TRACKBASE_TRKRCLUSTER_H

#include "TrkrDefs.h"

#include <phool/PHObject.h>

#include <climits>
#include <cmath>
#include <iostream>
#include <memory>


/**
 * @brief Base class for cluster object
 *
 * Virtual base class for cluster object used for all tracking subsystems
 */
class TrkrCluster : public PHObject
{
 public:
  //! dtor
  virtual ~TrkrCluster() {}
  // PHObject virtual overloads
  virtual void identify(std::ostream& os = std::cout) const
  {
    os << "TrkrCluster base class" << std::endl;
  }
  virtual void Reset() {}
  virtual int isValid() const { return 0; }
  //
  // cluster id
  //
  virtual TrkrDefs::cluskey getClusKey() const { return TrkrDefs::CLUSKEYMAX; }
  virtual void setClusKey(TrkrDefs::cluskey id) {}
 
  //
  // cluster position
  //
  virtual float getX() const { return NAN; }
  virtual void setX(float x) {}
  virtual float getY() const { return NAN; }
  virtual void setY(float y) {}
  virtual float getZ() const { return NAN; }
  virtual void setZ(float z) {}
  virtual float getPosition(int coor) const { return NAN; }
  virtual void setPosition(int coor, float xi) {}
  virtual void setGlobal() {}
  virtual void setLocal() {}
  virtual bool isGlobal() { return true; }
  virtual float getLocalX() const { return NAN; }
  virtual void setLocalX(float x) {}
  virtual float getLocalY() const { return NAN; }
  virtual void setLocalY(float y) {}
  //
  // cluster info
  //
  virtual void setAdc(unsigned int adc) {}
  virtual unsigned int getAdc() const { return UINT_MAX; }
  virtual float getSize(unsigned int i, unsigned int j) const { return NAN; }
  virtual void setSize(unsigned int i, unsigned int j, float value) {}
  virtual float getError(unsigned int i, unsigned int j) const { return NAN; }
  virtual void setError(unsigned int i, unsigned int j, float value) {}
  //
  // convenience interface
  //
  virtual float getPhiSize() const { return NAN; }
  virtual float getZSize() const { return NAN; }
  virtual float getPhiError() const { return NAN; }
  virtual float getRPhiError() const { return NAN; }
  virtual float getZError() const { return NAN; }

  /// Acts functions, for Acts modules use only
  virtual void setActsLocalError(unsigned int i, unsigned int j, float value){}
  virtual float getActsLocalError(unsigned int i, unsigned int j) const { return NAN; }
  virtual TrkrDefs::subsurfkey getSubSurfKey() const { return TrkrDefs::SUBSURFKEYMAX; }
  virtual void setSubSurfKey(TrkrDefs::subsurfkey id) {}

 protected:
  TrkrCluster() {}
  ClassDef(TrkrCluster, 1)
};

#endif //TRACKBASE_TRKRCLUSTER_H

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:13:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Intt.C:7:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Mvtx.C:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/mvtx/MvtxClusterizer.h:12:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase/TrkrCluster.h:87:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(TrkrCluster, 1)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class TrkrHit with content:

#line 1 "TrkrHit_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/**
 * @file trackbase/TrkrHit.h
 * @author D. McGlinchey
 * @date 4 June 2018
 * @brief Base class for hit object
 */
#ifndef TRACKBASE_TRKRHIT_H
#define TRACKBASE_TRKRHIT_H

#include "TrkrDefs.h"

#include <phool/PHObject.h>

#include <climits>
#include <cmath>
#include <iostream>

/**
 * @brief Base class for hit object
 *
 * This is the empyt virtual base class for a hit object.
 * Each subsystem should implement an inherited version
 * which contains the actual storage information.
 */
class TrkrHit : public PHObject
{
 public:

  //! dtor
  virtual ~TrkrHit() {}
  // PHObject virtual overloads
  virtual void identify(std::ostream& os = std::cout) const
  {
    os << "TrkrHit base class" << std::endl;
  }
  virtual void Reset() {}
  virtual int isValid() const { return 0; }

  // these set and get the energy before digitization
  virtual void addEnergy(const double edep){}
  virtual double getEnergy() {return 0;}

  // after digitization, these are the adc values
  virtual void setAdc(const unsigned int adc) {}
  virtual unsigned int getAdc() { return 0;}

 protected:

  ClassDef(TrkrHit, 1);
};

#endif //TRACKBASE_TRKRHIT_H

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class TrkrHitSetContainer with content:

#line 1 "TrkrHitSetContainer_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASE_TRKRHITSETCONTAINER_H
#define TRACKBASE_TRKRHITSETCONTAINER_H
/**
 * @file trackbase/TrkrHitSetContainerv1.h
 * @author D. McGlinchey, H. PEREIRA DA COSTA
 * @date June 2018
 * base class for hitset container
 */

#include "TrkrDefs.h"        // for hitsetkey, TrkrId

#include <phool/PHObject.h>

#include <iostream>          // for cout, ostream
#include <map>
#include <utility>           // for pair

class TrkrHitSet;

/**
 * Container for TrkrHitSet objects
 */
class TrkrHitSetContainer : public PHObject
{
 public:
  
  using Map = std::map<TrkrDefs::hitsetkey, TrkrHitSet *>;
  using Iterator = Map::iterator;
  using ConstIterator = Map::const_iterator;
  using Range = std::pair<Iterator, Iterator>;
  using ConstRange = std::pair<ConstIterator, ConstIterator>;

  //! ctor
  TrkrHitSetContainer() = default;
  
  //! dtir
  virtual ~TrkrHitSetContainer() = default;

  //! PHObject functions
  virtual void Reset() 
  {}
  
  virtual void identify(std::ostream & = std::cout) const
  {}

  //! Add a TrkrHitSet to the container
  virtual ConstIterator addHitSet(TrkrHitSet*);

  virtual ConstIterator addHitSetSpecifyKey(const TrkrDefs::hitsetkey, TrkrHitSet*);

  //! preferred removal method, key is currently the hit id
  virtual void removeHitSet(TrkrDefs::hitsetkey key)
  {}

  //! inefficent, use key where possible instead
  virtual void removeHitSet(TrkrHitSet*)
  {}

  //! find or add HitSet
  virtual Iterator findOrAddHitSet(TrkrDefs::hitsetkey);

  //! return all HitSets matching a given detid
  virtual ConstRange getHitSets(const TrkrDefs::TrkrId) const;

  //! return all HitSets matching a given detid, layer
  virtual ConstRange getHitSets(const TrkrDefs::TrkrId trackerid, const uint8_t layer) const;

  //! return all HitSets
  virtual ConstRange getHitSets() const;

  //! return a given HitSet based on its key
  virtual TrkrHitSet *findHitSet(TrkrDefs::hitsetkey)
  { return nullptr; }

  unsigned int size() const
  { return 0; }

  private:

  ClassDef(TrkrHitSetContainer, 1)
};

#endif //TRACKBASE_TRKRHITSETCONTAINER_H

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class TrkrClusterContainer with content:

#line 1 "TrkrClusterContainer_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASE_TRKRCLUSTERCONTAINER_H
#define TRACKBASE_TRKRCLUSTERCONTAINER_H

/**
 * @file trackbase/TrkrClusterContainer.h
 * @author D. McGlinchey, Hugo Pereira Da Costa
 * @date June 2018
 * @brief Cluster container base class
 */

#include "TrkrDefs.h"

#include <phool/PHObject.h>

#include <map>
#include <iostream>          // for cout, ostream
#include <utility>           // for pair

class TrkrCluster;

/**
 * @brief Cluster container object
 */
class TrkrClusterContainer : public PHObject
{
 public:

  //!@name convenient shortuts
  //@{
  using Map = std::map<TrkrDefs::cluskey, TrkrCluster *>;
  using Iterator = Map::iterator;
  using ConstIterator = Map::const_iterator;
  using Range = std::pair<Iterator, Iterator>;
  using ConstRange = std::pair<ConstIterator, ConstIterator>;
  //@}

  //! constructor
  TrkrClusterContainer() = default;

  //! reset method
  virtual void Reset() {}

  //! identify object
  virtual void identify(std::ostream &os = std::cout) const {}

  //! add a cluster
  virtual ConstIterator addCluster(TrkrCluster*);

  //! add a cluster with specific key
  virtual ConstIterator addClusterSpecifyKey(const TrkrDefs::cluskey, TrkrCluster* );

  //! remove cluster
  virtual void removeCluster(TrkrDefs::cluskey) {}

  //! remove cluster
  virtual void removeCluster(TrkrCluster* ) {}

  //! find cluster matching key if any, add a new one otherwise and return cluster
  virtual Iterator findOrAddCluster(TrkrDefs::cluskey);
  
  //! return all clusters
  virtual ConstRange getClusters() const;

  //! get all clusters matching hitset
  virtual ConstRange getClusters(TrkrDefs::hitsetkey) const;

  //! get pointer to map containing clusters mathching hitset
  virtual Map* getClusterMap(TrkrDefs::hitsetkey) { return nullptr; }

  //! find cluster matching given key
  virtual TrkrCluster* findCluster(TrkrDefs::cluskey) const { return nullptr; }

  //! total number of clusters
  virtual unsigned int size() const { return 0; }

  private:

  ClassDef(TrkrClusterContainer, 1)

};

#endif //TRACKBASE_TRKRCLUSTERCONTAINER_H

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class TrkrClusterHitAssoc with content:

#line 1 "TrkrClusterHitAssoc_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/**
 * @file trackbase/TrkrClusterHitAssoc.h
 * @author D. McGlinchey
 * @date June 2018
 * @brief Base class for associating clusters to the hits that went into them
 */
#ifndef TRACKBASE_TRKRCLUSTERHITASSOC_H
#define TRACKBASE_TRKRCLUSTERHITASSOC_H

#include "TrkrDefs.h"

#include <phool/PHObject.h>

#include <iostream>          // for cout, ostream
#include <map>
#include <utility>           // for pair
#include <climits>

/**
 * @brief Base class for associating clusters to the hits that went into them
 *
 * Store the associations between clusters and the hits that went into them.
 */
class TrkrClusterHitAssoc : public PHObject
{
public:

  using Map = std::multimap<TrkrDefs::cluskey, TrkrDefs::hitkey>;
  using ConstIterator = Map::const_iterator;
  using ConstRange = std::pair<Map::const_iterator, Map::const_iterator>;
  
  TrkrClusterHitAssoc() = default;

  virtual void Reset() = 0;

  virtual void identify(std::ostream &os = std::cout) const = 0;
  
  /**
   * @brief Add association between cluster and hit
   * @param[in] ckey Cluster key
   * @param[in] hidx Index of the hit in TrkrHitSet
   */
  virtual void addAssoc(TrkrDefs::cluskey ckey, unsigned int hidx) = 0;

  //! get pointer to cluster-to-hit map corresponding to a given hitset id
  virtual Map* getClusterMap(TrkrDefs::hitsetkey) {return nullptr;}

  /**
   * @brief Get all the hits associated with a cluster by key
   * @param[in] ckey Cluster key
   * @param[out] Range over hits associated with @c ckey
   */

  virtual ConstRange getHits(TrkrDefs::cluskey) = 0;

  virtual unsigned int size() const {return 0;}

private:

  ClassDef(TrkrClusterHitAssoc, 1);
};

#endif // TRACKBASE_TRKRCLUSTERHITASSOC_H

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class TrkrHitTruthAssoc with content:

#line 1 "TrkrHitTruthAssoc_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASE_TRKRHITTRUTHASSOC_H
#define TRACKBASE_TRKRHITTRUTHASSOC_H

/**
 * @file trackbase/TrkrHitCellAssoc
 * @author D. McGlinchey, H. PEREIRA DA COSTA
 * @date June 2018
 * @brief Association object for PHG4Hits contributiong to TrkrHits
 */

#include "TrkrDefs.h"

#include <g4main/PHG4HitDefs.h>
#include <phool/PHObject.h>

#include <iostream>              // for cout, ostream
#include <map>
#include <utility>               // for pair

/**
 * @brief Association object for PHG4Cells contributiong to TrkrHits
 *
 * Association object holding a multimap of PHG4Cells associated with a given TrkrHit
 */
class TrkrHitTruthAssoc : public PHObject
{
  
  public:
  
  //! typedefs for convenience 
  using MMap = std::multimap< TrkrDefs::hitsetkey, std::pair<TrkrDefs::hitkey, PHG4HitDefs::keytype> >; 
  using Iterator = MMap::iterator;
  using ConstIterator = MMap::const_iterator;
  using Range = std::pair<Iterator, Iterator>;
  using ConstRange = std::pair<ConstIterator, ConstIterator>;

  //! ctor                                                                                                                                                                                                  
  TrkrHitTruthAssoc() = default;  
  
  virtual void Reset() 
  {}

  virtual void identify(std::ostream &os = std::cout) const
  {}

  /**
   * @brief Add an association between hit and cell
   * @param[in] hset TrkrHitSet key
   * @param[in] hidx TrkrHit index in TrkrHitSet
   * @param[in] ckey Key for assocuated g4hit
   */
  virtual void addAssoc(const TrkrDefs::hitsetkey hitsetkey, const TrkrDefs::hitkey hitkey, const PHG4HitDefs::keytype  g4hitkey) 
  {}

  /**
   * @brief Add an association between hit and cell if it does not already exist
   * @param[in] hset TrkrHitSet key
   * @param[in] hidx TrkrHit index in TrkrHitSet
   * @param[in] ckey Key for assocuated g4hit
   */
  virtual void findOrAddAssoc(const TrkrDefs::hitsetkey hitsetkey, const TrkrDefs::hitkey hitkey, const PHG4HitDefs::keytype  g4hitkey)
  {}

  virtual void removeAssoc(const TrkrDefs::hitsetkey hitsetkey, const TrkrDefs::hitkey hitkey)
  {}

  /**
   * @brief Get cell keys associated with desired hit
   * @param[in] hset TrkrHitSet key
   * @param[in] hidx TrkrHit index in TrkrHitSet
   */
  virtual void getG4Hits(const TrkrDefs::hitsetkey hitsetkey, const unsigned int hidx, MMap &temp_map) const
  {}

  private:
  
  ClassDef(TrkrHitTruthAssoc, 1);

};

#endif //TRACKBASE_TRKRHITTRUTHASSOC_H

#undef  _BACKWARD_BACKWARD_WARNING_H

Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module InttDeadMap_Dict: '
#line 1 "InttDeadMap_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class InttDeadMap;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module InttDeadMapv1_Dict: '
#line 1 "InttDeadMapv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class InttDeadMapv1;
'
Error in <TInterpreter::AutoParse>: Error parsing payload code for class TrkrHitSet with content:

#line 1 "TrkrHitSet_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASE_TRKRHITSET_H
#define TRACKBASE_TRKRHITSET_H
/**
 * @file trackbase/TrkrHitSet.h
 * @author D. McGlinchey, H. PEREIRA DA COSTA
 * @date 4 June 2018
 * @brief Base Class Container for storing TrkrHit's
 */

#include "TrkrDefs.h"

#include <phool/PHObject.h>

#include <iostream>
#include <map>
#include <utility>  // for pair

//! forward declaration
class TrkrHit;

/**
 * @brief Container for storing TrkrHit's
 *
 * Container object which stores a set of TrkrHit objects.
 * A single TrkrHitSet is meant to represent a geometric detector object
 * which bounds clustering. Therefore, a TrkrHitSet should contain all
 * TrkrHits which could belong the the same cluster.
 */
class TrkrHitSet : public PHObject
{
 public:
  // iterator typedef
  using Map = std::map<TrkrDefs::hitkey, TrkrHit*>;
  using ConstIterator = Map::const_iterator;
  using ConstRange = std::pair<ConstIterator, ConstIterator>;

  //! ctor
  TrkrHitSet() = default;

  //! TObject functions
  virtual void identify(std::ostream& os = std::cout) const
  {
  }

  virtual void Reset()
  {
  }

  /**
   * @brief Set the key for this object
   * @param key
   */
  virtual void setHitSetKey(const TrkrDefs::hitsetkey)
  {
  }

  /**
   * @brief Get the key for this object
   * @param[out] object key
   */
  virtual TrkrDefs::hitsetkey getHitSetKey() const
  {
    return TrkrDefs::HITSETKEYMAX;
  }

  /**
   * @brief Add a hit to this container using a specific key.
   * @param[in] key Hit key
   * @param[in] hit Hit to be added.
   *
   * NOTE: This TrkrHitSet takes ownership of the passed TrkrHit pointer
   * and will delete it in the Reset() method.
   */
  virtual ConstIterator addHitSpecificKey(const TrkrDefs::hitkey, TrkrHit*);

  /**
   * @brief Remove a hit using its key
   * @param[in] key to be removed
   */
  virtual void removeHit(TrkrDefs::hitkey)
  {
  }

  /**
   * @brief Get a specific hit based on its index.
   * @param key of the desired hit
   * @param[out] Pointer to the desired hit. nullptr if no hit.
   *
   * Get a desired hit based on its key.
   */
  virtual TrkrHit* getHit(const TrkrDefs::hitkey) const
  {
    return nullptr;
  }

  /**
   * @brief Get all hits
   * @param[out] Pair of iterator to vector begin and end
   */
  virtual ConstRange getHits() const;

  /**
   * @brief Get the number of hits stored
   * @param[out] number of hits
   */
  // Get number of hits
  virtual unsigned int size() const
  {
    return 0;
  }

  ClassDef(TrkrHitSet, 1);
};

#endif  //TRACKBASE_TRKRHITSET_H

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:8:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_TPC.C:10:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4tpc/PHG4TpcDigitizer.h:9:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase/TrkrHitSet.h:112:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(TrkrHitSet, 1);
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4HitContainer with content:

#line 1 "PHG4HitContainer_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
#ifndef G4MAIN_PHG4HITCONTAINER_H
#define G4MAIN_PHG4HITCONTAINER_H

#include "PHG4HitDefs.h"

#include <phool/PHObject.h>

#include <iostream>
#include <map>
#include <set>
#include <string>
#include <utility>

class PHG4Hit;

class PHG4HitContainer: public PHObject
{

  public:
  typedef std::map<PHG4HitDefs::keytype, PHG4Hit *> Map;
  typedef Map::iterator Iterator;
  typedef Map::const_iterator ConstIterator;
  typedef std::pair<Iterator, Iterator> Range;
  typedef std::pair<ConstIterator, ConstIterator> ConstRange;
  typedef std::set<unsigned int>::const_iterator LayerIter;

  PHG4HitContainer(); //< used only by ROOT for DST readback
  PHG4HitContainer(const std::string &nodename);

  virtual ~PHG4HitContainer() {}

  void Reset();

  void identify(std::ostream& os = std::cout) const;

  //! container ID should follow definition of PHG4HitDefs::get_volume_id(DST nodename)
  void SetID(int i) {id = i;}
  int GetID() const {return id;}
  
  ConstIterator AddHit(PHG4Hit *newhit);

  ConstIterator AddHit(const unsigned int detid, PHG4Hit *newhit);
  
  Iterator findOrAddHit(PHG4HitDefs::keytype key);

  PHG4Hit* findHit(PHG4HitDefs::keytype key );

  PHG4HitDefs::keytype genkey(const unsigned int detid);

  //! return all hits matching a given detid
  ConstRange getHits(const unsigned int detid) const;

  //! return all hist
  ConstRange getHits( void ) const;

  unsigned int size( void ) const
  { return hitmap.size(); }
  unsigned int num_layers(void) const
  { return layers.size(); }
  std::pair<LayerIter, LayerIter> getLayers() const
     { return make_pair(layers.begin(), layers.end());} 
  void AddLayer(const unsigned int ilayer) {layers.insert(ilayer);}
  void RemoveZeroEDep();
  PHG4HitDefs::keytype getmaxkey(const unsigned int detid);

 protected:

  int id; //< unique identifier from hash of node name. Defined following PHG4HitDefs::get_volume_id
  Map hitmap;
  std::set<unsigned int> layers; // layers is not reset since layers must not change event by event

  ClassDef(PHG4HitContainer,1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:8:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_TPC.C:12:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4tpc/PHG4TpcElectronDrift.h:8:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4main/PHG4HitContainer.h:74:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(PHG4HitContainer,1)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4CellContainer with content:

#line 1 "PHG4CellContainer_Dict dictionary payload"

#ifndef CGAL_DISABLE_ROUNDING_MATH_CHECK
  #define CGAL_DISABLE_ROUNDING_MATH_CHECK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
#ifndef G4DETECTORS_PHG4CELLCONTAINER_H
#define G4DETECTORS_PHG4CELLCONTAINER_H

#include "PHG4CellDefs.h"    // for keytype

#include <phool/PHObject.h>

#include <iostream>          // for cout, ostream
#include <map>
#include <utility>           // for pair

class PHG4Cell;

class PHG4CellContainer: public PHObject
{

  public:
  typedef std::map<PHG4CellDefs::keytype,PHG4Cell *> Map;
  typedef Map::iterator Iterator;
  typedef Map::const_iterator ConstIterator;
  typedef std::pair<Iterator, Iterator> Range;
  typedef std::pair<ConstIterator, ConstIterator> ConstRange;

  PHG4CellContainer();

  virtual ~PHG4CellContainer() {}

  void Reset();

  void identify(std::ostream& os = std::cout) const;

  ConstIterator AddCell(PHG4Cell *newCell);
  ConstIterator AddCellSpecifyKey(const PHG4CellDefs::keytype key, PHG4Cell *newCell);
  
  //! preferred removal method, key is currently the cell id
  void RemoveCell(PHG4CellDefs::keytype key) {
    cellmap.erase(key);
  }

  //! inefficent, use key where possible instead
  void RemoveCell(PHG4Cell *cell)
  {
    Iterator its = cellmap.begin();
    Iterator last = cellmap.end();
    for (; its != last;)
      {
	if (its->second == cell)
	  {
	    cellmap.erase(its++);
	  }
	else
	  {
	    ++its;
	  }
      }
  }


  Iterator findOrAddCell(PHG4CellDefs::keytype key);

  //! return all Cells matching a given detid
  ConstRange getCells(const unsigned short int detid) const;

  //! return all hist
  ConstRange getCells( void ) const;

  PHG4Cell* findCell(PHG4CellDefs::keytype key);

  unsigned int size( void ) const
  { return cellmap.size(); }

  double getTotalEdep() const;

 protected:
  Map cellmap;
  ClassDef(PHG4CellContainer,1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4CylinderCellGeomContainer with content:

#line 1 "PHG4CylinderCellGeomContainer_Dict dictionary payload"

#ifndef CGAL_DISABLE_ROUNDING_MATH_CHECK
  #define CGAL_DISABLE_ROUNDING_MATH_CHECK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
#ifndef G4DETECTORS_PHG4CYLINDERCELLGEOMCONTAINER_H
#define G4DETECTORS_PHG4CYLINDERCELLGEOMCONTAINER_H

#include <phool/PHObject.h>

#include <iostream>          // for cout, ostream
#include <map>
#include <utility>           // for make_pair, pair

class PHG4CylinderCellGeom;

class PHG4CylinderCellGeomContainer: public PHObject
{
 public:
  typedef std::map<int, PHG4CylinderCellGeom*> Map;
  typedef Map::iterator Iterator;
  typedef Map::const_iterator ConstIterator;
  typedef std::pair<Iterator, Iterator> Range;
  typedef std::pair<ConstIterator, ConstIterator> ConstRange;

  PHG4CylinderCellGeomContainer(){}
  virtual ~PHG4CylinderCellGeomContainer();

  void identify(std::ostream& os = std::cout) const;

  int AddLayerCellGeom(const int i, PHG4CylinderCellGeom *mygeom);
  int AddLayerCellGeom(PHG4CylinderCellGeom *mygeom);
  PHG4CylinderCellGeom *GetLayerCellGeom(const int i);
  PHG4CylinderCellGeom *GetFirstLayerCellGeom();
  int get_NLayers() const {return layergeoms.size();}
  std::pair<std::map<int,PHG4CylinderCellGeom *>::const_iterator, std::map<int,PHG4CylinderCellGeom *>::const_iterator> get_begin_end() const {return std::make_pair(layergeoms.begin(), layergeoms.end());}

 protected:
  std::map<int,PHG4CylinderCellGeom *> layergeoms ;
  ClassDef(PHG4CylinderCellGeomContainer,1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class PHG4CylinderCellGeom with content:

#line 1 "PHG4CylinderCellGeom_Dict dictionary payload"

#ifndef CGAL_DISABLE_ROUNDING_MATH_CHECK
  #define CGAL_DISABLE_ROUNDING_MATH_CHECK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.
#ifndef G4DETECTORS_PHG4CYLINDERCELLGEOM_H
#define G4DETECTORS_PHG4CYLINDERCELLGEOM_H

#include <phool/PHObject.h>

#include <iostream>          // for cout, ostream
#include <string>
#include <utility>           // for pair

class PHG4CylinderCellGeom: public PHObject
{
 public:
  PHG4CylinderCellGeom();

  virtual ~PHG4CylinderCellGeom() {}

  void identify(std::ostream& os = std::cout) const;
  int get_layer() const {return layer;}
  double get_radius() const {return radius;}
  double get_thickness() const {return thickness;}
  int get_binning() const {return binning;}
  int get_zbins() const;
  int get_phibins() const;
  double get_zmin() const;
  double get_phistep() const;
  double get_phimin() const;
  double get_zstep() const;
  int get_etabins() const;
  double get_etastep() const;
  double get_etamin() const;

  virtual std::pair<double, double> get_zbounds(const int ibin) const;
  virtual std::pair<double, double> get_phibounds(const int ibin) const;
  virtual std::pair<double, double> get_etabounds(const int ibin) const;
  virtual double get_etacenter(const int ibin) const;
  virtual double get_zcenter(const int ibin) const;
  virtual double get_phicenter(const int ibin) const;

  virtual int get_etabin(const double eta) const;
  virtual int get_zbin(const double z) const;
  virtual int get_phibin(const double phi) const;

   void set_layer(const int i) {layer = i;}
   void set_binning(const int i) {binning = i;}
   void set_radius(const double r) {radius = r;}
   void set_thickness(const double t) {thickness = t;}
   void set_zbins(const int i);
   void set_zmin(const double z);
   void set_zstep(const double z);
   void set_phibins(const int i);
   void set_phistep(const double phi);
   void set_phimin(const double phi);
   void set_etabins(const int i);
   void set_etamin(const double z);
   void set_etastep(const double z);
  
 protected:
  void check_binning_method(const int i) const;
  void check_binning_method_eta(const std::string & src = "") const;
  void check_binning_method_phi(const std::string & src = "") const;
  std::string methodname(const int i) const;
  int layer;
  int binning;
  double radius;
  int nzbins;
  double zmin;
  double zstep;
  int nphibins;
  double phimin;
  double phistep;
  double thickness;

  ClassDef(PHG4CylinderCellGeom,1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class MicromegasTile with content:

#line 1 "MicromegasTile_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.

#ifndef MICROMEGAS_MICROMEGASTILE_H
#define MICROMEGAS_MICROMEGASTILE_H

/*!
 * \file MicromegasTile.h
 * \author Hugo Pereira Da Costa <hugo.pereira-da-costa@cea.fr>
 */

#include <phool/PHObject.h>

#include <array>
#include <cassert>
#include <vector>

//! header only class that contains information about a given Tile location inside CylinderGeom
class MicromegasTile: public PHObject
{

  public:

  using List = std::vector<MicromegasTile>;

  //! default constructor
  MicromegasTile()
  {}

// ROOT wants a virtual dtor
  virtual ~MicromegasTile() {}

  //! constructor
  MicromegasTile( std::array<double, 4> values )
    :m_centerPhi( values[0] )
    ,m_centerZ( values[1] )
    ,m_sizePhi( values[2] )
    ,m_sizeZ( values[3] )
  {}

  //! constructor
  MicromegasTile( double centerPhi, double centerZ, double sizePhi, double sizeZ )
    :m_centerPhi( centerPhi )
    ,m_centerZ( centerZ )
    ,m_sizePhi( sizePhi )
    ,m_sizeZ( sizeZ )
  {}

  double m_centerPhi = 0;
  double m_centerZ = 0;
  double m_sizePhi = 0;
  double m_sizeZ = 0;

  ClassDef(MicromegasTile,1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:11:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4micromegas/PHG4MicromegasHitReco.h:12:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/micromegas/MicromegasTile.h:54:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(MicromegasTile,1)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class CylinderGeomMicromegas with content:

#line 1 "CylinderGeomMicromegas_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Tell emacs that this is a C++ source
//  -*- C++ -*-.

#ifndef MICROMEGAS_CYLINDERGEOMMICROMEGAS_H
#define MICROMEGAS_CYLINDERGEOMMICROMEGAS_H

/*!
 * \file CylinderGeomMicromegas.h
 * \author Hugo Pereira Da Costa <hugo.pereira-da-costa@cea.fr>
 */

#include "MicromegasDefs.h"
#include "MicromegasTile.h"
#include <g4detectors/PHG4CylinderGeom.h>

#include <cmath>
#include <iostream>

class TVector3;

class CylinderGeomMicromegas : public PHG4CylinderGeom
{
  public:

  //* empty constructor
  explicit CylinderGeomMicromegas()
  {}

  //* constructor
  CylinderGeomMicromegas(int layer )
    : m_layer( layer )
  {}

  //!@name accessors
  //@{
  virtual int get_layer() const {return m_layer;}
  virtual double get_radius() const {return m_radius;}
  virtual double get_thickness() const { return m_thickness;}
  virtual double get_zmin() const {return m_zmin;}
  virtual double get_zmax() const {return m_zmax;}
  double get_pitch() const { return m_pitch; }

  //! segmentation type
  MicromegasDefs::SegmentationType get_segmentation_type() const {return m_segmentation_type;}

  //! drift direction
  MicromegasDefs::DriftDirection get_drift_direction() const {return m_drift_direction;}

  //! get tile for a given world location
  int find_tile( const TVector3& ) const;

  //! get tile and strip for a give world location
  std::pair<int,int> find_strip( const TVector3& ) const;

  //! get strip for a give world location and tile
  int find_strip( uint tileid, const TVector3& ) const;

  //! get strip length for a given tile
  double get_strip_length( uint tileid ) const;

  //! get number of strips
  uint get_strip_count( uint tileid ) const;

  //! get world location for a given tile and strip
  TVector3 get_world_coordinate( uint tileid, uint stripnum ) const;

  //! print information about this layer
  virtual void identify(std::ostream&) const;

  //@}

  //!@name modifiers
  //@{
  virtual void set_layer(const int i) {m_layer = i;}
  virtual void set_radius(const double value) {m_radius = value;}
  virtual void set_thickness(const double value) {m_thickness = value;}
  virtual void set_zmin(const double value) {m_zmin = value;}
  virtual void set_zmax(const double value) {m_zmax = value;}
  void set_pitch( double value ) { m_pitch = value; }

  //! tiles
  void set_tiles( const MicromegasTile::List& tiles ) {m_tiles = tiles;}

  //! segmentation
  void set_segmentation_type( MicromegasDefs::SegmentationType value ) {m_segmentation_type = value;}

  //! drift direction
  void set_drift_direction( MicromegasDefs::DriftDirection value ) {m_drift_direction = value;}
  //@}

  private:

  // check if hit radius matches this cylinder
  bool check_radius( const TVector3& ) const;

  //! layer id
  int m_layer = 0;

  //! segmentation type
  MicromegasDefs::SegmentationType m_segmentation_type = MicromegasDefs::SegmentationType::SEGMENTATION_PHI;

  //! drift direction
  MicromegasDefs::DriftDirection m_drift_direction = MicromegasDefs::DriftDirection::OUTWARD;

  //! layer radius
  double m_radius = 0;

  //! layer thickness
  double m_thickness = 0;

  //! layer z extend
  double m_zmin = 0;

  //! layer z extend
  double m_zmax = 0;

  //! 1mm pitch by default
  double m_pitch = 0.1;

  //! tiles
  MicromegasTile::List m_tiles;

  ClassDef(CylinderGeomMicromegas, 1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:11:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4micromegas/PHG4MicromegasHitReco.h:47:13: error: no viable overloaded '='
  { m_tiles = tiles; }
    ~~~~~~~ ^ ~~~~~
In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:15:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:95:21: error: no matching constructor for initialization of 'const MicromegasTile::List &' (aka 'const vector<MicromegasTile> &')
    reco->set_tiles({{{phi0, 0, tile_width / radius, tile_length}}});
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4micromegas/PHG4MicromegasHitReco.h:46:47: note: passing argument to parameter 'tiles' here
  void set_tiles( const MicromegasTile::List& tiles )
                                              ^
In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:7:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/G4Setup_sPHENIX.C:15:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:103:26: error: no matching constructor for initialization of 'MicromegasTile::List' (aka 'vector<MicromegasTile>')
    MicromegasTile::List tiles;
                         ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:116:26: error: no matching constructor for initialization of 'MicromegasTile::List' (aka 'vector<MicromegasTile>')
    MicromegasTile::List tiles;
                         ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:130:26: error: no matching constructor for initialization of 'MicromegasTile::List' (aka 'vector<MicromegasTile>')
    MicromegasTile::List tiles;
                         ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Micromegas.C:155:26: error: no matching constructor for initialization of 'MicromegasTile::List' (aka 'vector<MicromegasTile>')
    MicromegasTile::List tiles;
                         ^
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module CaloTriggerInfo_Dict: '
#line 1 "CaloTriggerInfo_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class CaloTriggerInfo;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module CaloTriggerInfov1_Dict: '
#line 1 "CaloTriggerInfov1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class CaloTriggerInfov1;
'
Error in <TInterpreter::AutoParse>: Error parsing payload code for class Jet with content:

#line 1 "Jet_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef G4JET_JET_H
#define G4JET_JET_H

#include <phool/PHObject.h>

#include <cmath>
#include <cstddef>          // for size_t
#include <iostream>
#include <map>

class Jet : public PHObject
{
 public:
  // enums can be extended with new values, but values not altered

  enum ALGO
  {
    NONE = 0,
    ANTIKT = 1,
    KT = 2,
    CAMBRIDGE = 3
  };

  enum SRC
  {
    VOID = 0,
    PARTICLE = 1,
    TRACK = 2,
    CEMC_TOWER = 3,
    CEMC_CLUSTER = 4,
    HCALIN_TOWER = 5,
    HCALIN_CLUSTER = 6,
    HCALOUT_TOWER = 7,
    HCALOUT_CLUSTER = 8,
    FEMC_TOWER = 9,
    FEMC_CLUSTER = 10,
    FHCAL_TOWER = 11,
    FHCAL_CLUSTER = 12,
    CEMC_TOWER_RETOWER = 13, /* needed for HI jet reco */
    CEMC_TOWER_SUB1 = 14,
    HCALIN_TOWER_SUB1 = 15,
    HCALOUT_TOWER_SUB1 = 16, /* needed for HI jet reco */
    CEMC_TOWER_SUB1CS = 17,
    HCALIN_TOWER_SUB1CS = 18,
    HCALOUT_TOWER_SUB1CS = 19, /* needed for CS subtraction w/ HI jet reco */
    HEPMC_IMPORT = 20,         /*Direct import HEPMC containers, such as sHijing HIJFRG truth jets loaded by JetHepMCLoader*/
    HCAL_TOPO_CLUSTER = 21,    /* I+HOCal 3-D topoCluster input */
    ECAL_TOPO_CLUSTER = 22,    /* EMCal 3-D topoCluster input */
    EEMC_TOWER = 23,
    EEMC_CLUSTER = 24,
  };

  enum PROPERTY
  {

    //! jet charge
    prop_JetCharge = 1,

    //! b-jet fraction
    prop_BFrac = 2,

    //! discriminator D = max tower E / average E , used to identify
    //! seeds in 1st iteration of UE determination
    prop_SeedD = 3,

    //! used to tag as seed jet in 1st or 2nd iteration of UE
    //! determination
    prop_SeedItr = 4,

    //! SoftDrop quantities
    prop_zg = 5,
    prop_Rg = 6,
    prop_mu = 7,

  };

  Jet() {}
  virtual ~Jet() {}

  virtual void identify(std::ostream& os = std::cout) const;
  virtual void Reset() { return; }
  virtual int isValid() const { return 0; }
  virtual PHObject* CloneMe() const { return nullptr; }

  // jet info ------------------------------------------------------------------

  virtual unsigned int get_id() const { return 0xFFFFFFFF; }
  virtual void set_id(unsigned int id) { return; }

  virtual float get_px() const { return NAN; }
  virtual void set_px(float px) { return; }

  virtual float get_py() const { return NAN; }
  virtual void set_py(float py) { return; }

  virtual float get_pz() const { return NAN; }
  virtual void set_pz(float pz) { return; }

  virtual float get_e() const { return NAN; }
  virtual void set_e(float e) { return; }

  virtual float get_p() const { return NAN; }
  virtual float get_pt() const { return NAN; }
  virtual float get_et() const { return NAN; }
  virtual float get_eta() const { return NAN; }
  virtual float get_phi() const { return NAN; }
  virtual float get_mass() const { return NAN; }
  virtual float get_mass2() const { return NAN; }

  // extended jet info ---------------------------------------------------------

  virtual bool has_property(Jet::PROPERTY prop_id) const { return false; }
  virtual float get_property(Jet::PROPERTY prop_id) const { return NAN; }
  virtual void set_property(Jet::PROPERTY prop_id, float value) { return; }
  virtual void print_property(std::ostream& os) const { return; }

  // component id storage ------------------------------------------------------

  /*! \addtogroup clustered component
   * clustered component methods (multimap interface based)
   * source type id --> unique id within that storage
   *  @{
   */

  typedef std::multimap<Jet::SRC, unsigned int> typ_comp_ids;
  typedef typ_comp_ids::const_iterator ConstIter;
  typedef typ_comp_ids::iterator Iter;

  virtual bool empty_comp() const { return true; }
  virtual size_t size_comp() const { return 0; }
  virtual size_t count_comp(Jet::SRC source) const { return 0; }

  virtual void clear_comp() { return; }
  virtual void insert_comp(Jet::SRC source, unsigned int compid) { return; }
  virtual size_t erase_comp(Jet::SRC source) { return 0; }
  virtual void erase_comp(Iter iter) { return; }
  virtual void erase_comp(Iter first, Iter last) { return; }

  virtual ConstIter begin_comp() const;
  virtual ConstIter lower_bound_comp(Jet::SRC source) const;
  virtual ConstIter upper_bound_comp(Jet::SRC source) const;
  virtual ConstIter find(Jet::SRC source) const;
  virtual ConstIter end_comp() const;

  virtual Iter begin_comp();
  virtual Iter lower_bound_comp(Jet::SRC source);
  virtual Iter upper_bound_comp(Jet::SRC source);
  virtual Iter find(Jet::SRC source);
  virtual Iter end_comp();

  ClassDef(Jet, 1);
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:12:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_HIJetReco.C:4:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4jets/FastJetAlgo.h:4:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/g4jets/Jet.h:151:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(Jet, 1);
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TowerBackground_Dict: '
#line 1 "TowerBackground_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TowerBackground;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module TowerBackgroundv1_Dict: '
#line 1 "TowerBackgroundv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class TowerBackgroundv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module libKFParticle: '
#line 1 "libKFParticle dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class KFParticleBase;
class KFParticle;
class KFVertex;
class KFPartEfficiencies;
class KFMCParticle;
class KFParticleTest;
'
Error in <TInterpreter::AutoParse>: Error parsing payload code for class KFParticle with content:

#line 1 "libKFParticle dictionary payload"

#ifndef DO_TPCCATRACKER_EFF_PERFORMANCE
  #define DO_TPCCATRACKER_EFF_PERFORMANCE 1
#endif
#ifndef HomogeneousField
  #define HomogeneousField 1
#endif
#ifndef USE_TIMERS
  #define USE_TIMERS 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *               2007-2019 Sergey Gorbunov
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifndef KFPARTICLEBASE_H
#define KFPARTICLEBASE_H

#ifdef __ROOT__ //for the STAR experiment
#define HomogeneousField
#endif

#ifdef HLTCA_STANDALONE
#include "RootTypesDef.h"
#else
#include "TObject.h"
#endif

#include <vector>

/** @class KFParticleBase
 ** @brief The base of KFParticle class, describes particle objects.
 ** @author  S.Gorbunov, I.Kisel, M.Zyzak
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** Contains the main mathematics of the KF Particle . Will be merged with the KFParticle class.
 **/

class KFParticleBase :public TObject {
  
 public:

  /**
   ** Abstract methods are defined in the KFParticle class
   **/ 

  /** Virtual method to access the magnetic field**/
  virtual void GetFieldValue(const float xyz[], float B[]) const = 0;
  
  /** Virtual method to get extrapolation parameter dS=l/p to . Is defined in KFParticle.**/
  virtual float GetDStoPoint( const float xyz[3], float dsdr[6] ) const = 0;
  
  float GetDStoPointLine( const float xyz[3], float dsdr[6] ) const;
  float GetDStoPointBz( float B, const float xyz[3], float dsdr[6], const float* param=0) const;
  float GetDStoPointBy( float By, const float xyz[3], float dsdr[6] ) const;
  float GetDStoPointB( const float* B, const float xyz[3], float dsdr[6] ) const;
  float GetDStoPointCBM( const float xyz[3], float dsdr[6] ) const;

  /** Virtual method to get extrapolation parameter dS=l/p to another particle. Is defined in KFParticle.**/
  virtual void GetDStoParticle( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const = 0;
  
  void GetDStoParticleLine( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const ;
  void GetDStoParticleBz( float Bz, const KFParticleBase &p, float dS[2], float dsdr[4][6], const float* param1=0, const float* param2=0 ) const ;
  void GetDStoParticleBy( float B,  const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const ;
  void GetDStoParticleCBM( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const ;
  
  /** Virtual method to transport a particle on a certain distance along the trajectory. Is defined in KFParticle.**/
  virtual void Transport( float dS, const float dsdr[6], float P[], float C[], float* dsdr1=0, float* F=0, float* F1=0 ) const = 0;


  KFParticleBase();
  virtual ~KFParticleBase() { ; } ///< The default destructor.

  void Initialize( const float Param[], const float Cov[], Int_t Charge, float Mass );
  void Initialize();

  void SetConstructMethod(Int_t m) {fConstructMethod = m;} ///< Defines the construction method for the current particle (see description of fConstructMethod).
  void SetMassHypo(float m) { fMassHypo = m;} ///< Sets the mass hypothesis to the particle, is used when fConstructMethod = 2.
  const float& GetMassHypo() const { return fMassHypo; } ///< Returns the mass hypothesis.
  const float& GetSumDaughterMass() const {return SumDaughterMass;} ///< Returns the sum of masses of the daughters.

  //*
  //*  ACCESSORS
  //*

  //* Simple accessors 

  float GetX    () const { return fP[0]; } ///< Retruns X coordinate of the particle, fP[0].
  float GetY    () const { return fP[1]; } ///< Retruns Y coordinate of the particle, fP[1].
  float GetZ    () const { return fP[2]; } ///< Retruns Z coordinate of the particle, fP[2].
  float GetPx   () const { return fP[3]; } ///< Retruns X component of the momentum, fP[3].
  float GetPy   () const { return fP[4]; } ///< Retruns Y component of the momentum, fP[4].
  float GetPz   () const { return fP[5]; } ///< Retruns Z component of the momentum, fP[5].
  float GetE    () const { return fP[6]; } ///< Returns energy of the particle, fP[6].
  float GetS    () const { return fP[7]; } ///< Returns dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  char  GetQ    () const { return fQ;    } ///< Returns charge of the particle.
  float GetChi2 () const { return fChi2; } ///< Returns Chi2 of the fit.
  Int_t GetNDF  () const { return fNDF;  } ///< Returns number of decrease of freedom.

  const float& X    () const { return fP[0]; } ///< Retruns X coordinate of the particle, fP[0].
  const float& Y    () const { return fP[1]; } ///< Retruns Y coordinate of the particle, fP[1].
  const float& Z    () const { return fP[2]; } ///< Retruns Z coordinate of the particle, fP[2].
  const float& Px   () const { return fP[3]; } ///< Retruns X component of the momentum, fP[3].
  const float& Py   () const { return fP[4]; } ///< Retruns Y component of the momentum, fP[4].
  const float& Pz   () const { return fP[5]; } ///< Retruns Z component of the momentum, fP[5].
  const float& E    () const { return fP[6]; } ///< Returns energy of the particle, fP[6].
  const float& S    () const { return fP[7]; } ///< Returns dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  const char& Q     () const { return fQ;    } ///< Returns charge of the particle.
  const float& Chi2 () const { return fChi2; } ///< Returns Chi2 of the fit.
  const Int_t& NDF  () const { return fNDF;  } ///< Returns number of decrease of freedom.
  
  float GetParameter ( Int_t i )          const { return fP[i];       } ///< Returns P[i] parameter.
  float GetCovariance( Int_t i )          const { return fC[i];       } ///< Returns C[i] element of the covariance matrix in the lower triangular form.
  float GetCovariance( Int_t i, Int_t j ) const { return fC[IJ(i,j)]; } ///< Returns C[i,j] element of the covariance matrix.

  //* Accessors with calculations( &value, &estimated sigma )
  //* error flag returned (0 means no error during calculations) 

  Int_t GetMomentum      ( float &p,   float &error ) const ;
  Int_t GetPt            ( float &pt,  float &error ) const ;
  Int_t GetEta           ( float &eta, float &error ) const ;
  Int_t GetPhi           ( float &phi, float &error ) const ;
  Int_t GetMass          ( float &m,   float &error ) const ;
  Int_t GetDecayLength   ( float &l,   float &error ) const ;
  Int_t GetDecayLengthXY ( float &l,   float &error ) const ;
  Int_t GetLifeTime      ( float &ctau,float &error ) const ;
  Int_t GetR             ( float &r,   float &error ) const ;

  //*
  //*  MODIFIERS
  //*
  
  float & X    () { return fP[0]; } ///< Modifier of X coordinate of the particle, fP[0].
  float & Y    () { return fP[1]; } ///< Modifier of Y coordinate of the particle, fP[1].
  float & Z    () { return fP[2]; } ///< Modifier of Z coordinate of the particle, fP[2].
  float & Px   () { return fP[3]; } ///< Modifier of X component of the momentum, fP[3].
  float & Py   () { return fP[4]; } ///< Modifier of Y component of the momentum, fP[4].
  float & Pz   () { return fP[5]; } ///< Modifier of Z component of the momentum, fP[5].
  float & E    () { return fP[6]; } ///< Modifier of energy of the particle, fP[6].
  float & S    () { return fP[7]; } ///< Modifier of dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  char  & Q    () { return fQ;    } ///< Modifier of charge of the particle.
  float & Chi2 () { return fChi2; } ///< Modifier of Chi2 of the fit.
  Int_t & NDF  () { return fNDF;  } ///< Modifier of number of decrease of freedom.

  float & Parameter ( Int_t i )          { return fP[i];       } ///< Modifier of P[i] parameter.
  float & Covariance( Int_t i )          { return fC[i];       } ///< Modifier of C[i] element of the covariance matrix in the lower triangular form.
  float & Covariance( Int_t i, Int_t j ) { return fC[IJ(i,j)]; } ///< Modifier of C[i,j] element of the covariance matrix.


  //* 
  //* CONSTRUCTION OF THE PARTICLE BY ITS DAUGHTERS AND MOTHER
  //* USING THE KALMAN FILTER METHOD
  //*


  //* Simple way to add daughter ex. D0+= Pion; 

  void operator +=( const KFParticleBase &Daughter );  

  //* Add daughter track to the particle 

  void AddDaughter( const KFParticleBase &Daughter );
  void SubtractDaughter( const KFParticleBase &Daughter );

  void AddDaughterWithEnergyFit( const KFParticleBase &Daughter );
  void AddDaughterWithEnergyFitMC( const KFParticleBase &Daughter );

  //* Set production vertex 

  void SetProductionVertex( const KFParticleBase &Vtx );

  //* Set mass constraint 

  void SetNonlinearMassConstraint( float Mass );
  void SetMassConstraint( float Mass, float SigmaMass = 0 );

  //* Set no decay length for resonances

  void SetNoDecayLength();


  //* Everything in one go  

  void Construct( const KFParticleBase *vDaughters[], Int_t nDaughters, const KFParticleBase *ProdVtx=0,   float Mass=-1 );

  //Transport functions
  void TransportToDecayVertex();
  void TransportToProductionVertex();
  void TransportToDS( float dS, const float* dsdr );
  void TransportBz( float Bz, float dS, const float* dsdr, float P[], float C[], float* dsdr1=0, float* F=0, float* F1=0 ) const;
  void TransportCBM( float dS, const float* dsdr, float P[], float C[], float* dsdr1=0, float* F=0, float* F1=0 ) const;  

  //* 
  //* OTHER UTILITIES
  //*

  //* Calculate distance from another object [cm]

  float GetDistanceFromVertex( const float vtx[] ) const;
  float GetDistanceFromVertex( const KFParticleBase &Vtx ) const;
  float GetDistanceFromParticle( const KFParticleBase &p ) const;

  //* Calculate sqrt(Chi2/ndf) deviation from vertex
  //* v = [xyz], Cv=[Cxx,Cxy,Cyy,Cxz,Cyz,Czz]-covariance matrix

  float GetDeviationFromVertex( const float v[], const float Cv[]=0 ) const;
  float GetDeviationFromVertex( const KFParticleBase &Vtx ) const;
  float GetDeviationFromParticle( const KFParticleBase &p ) const;  

  void SubtractFromVertex( KFParticleBase &Vtx ) const;
  void SubtractFromParticle( KFParticleBase &Vtx ) const;

  static void GetArmenterosPodolanski(KFParticleBase& positive, KFParticleBase& negative, float QtAlfa[2] );
  void RotateXY(float angle, float Vtx[3]);

  int Id() const { return fId; } ///< Returns Id of the particle.
  int NDaughters() const { return fDaughtersIds.size(); } ///< Returns number of daughter particles.
  const std::vector<int>& DaughterIds() const { return fDaughtersIds; } ///< Returns the vector with the indices of daughter particles.
  void CleanDaughtersId() { fDaughtersIds.clear(); } ///< Cleans the vector with the indices of daughter particles.
  
  void SetId( int id ) { fId = id; } ///< Sets the Id of the particle. After the construction of a particle should be set by user.
  void AddDaughterId( int id ) { fDaughtersIds.push_back(id); } ///< Adds index of the daughter particle. 

  void SetPDG ( int pdg ) { fPDG = pdg; } ///< Sets the PDG hypothesis.
  int GetPDG () const { return fPDG; } ///< Returns the PDG hypothesis.

#ifdef __ROOT__ //for the STAR experiment
  virtual void Print(Option_t *opt="") const;
  Int_t        IdTruth() const { return fIdTruth;}
  Int_t        QaTruth() const { return fQuality; }
  Int_t        IdParentMcVx() const {return fIdParentMcVx;}
  Int_t        IdParentVx()   const {return IdParentMcVx();}
  void         SetParentID(Int_t id=0) {fParentID = id;}
  Int_t        GetParentID() const {return fParentID;}
  void         SetIdParentMcVx(Int_t id) {fIdParentMcVx = id;}
  void         SetIdTruth(Int_t idtru,Int_t qatru=0) {fIdTruth = (UShort_t) idtru; fQuality = (UShort_t) qatru;}
  virtual void Clear(Option_t * /*option*/ ="");
#endif

  static void InvertCholetsky3(float a[6]);
  static void MultQSQt( const float Q[], const float S[], float SOut[], const int kN );

 protected:
  /** Converts a pair of indices {i,j} of the covariance matrix to one index corresponding to the triangular form. */
  static Int_t IJ( Int_t i, Int_t j ){ 
    return ( j<=i ) ? i*(i+1)/2+j :j*(j+1)/2+i;
  }
  /** Return an element of the covariance matrix with {i,j} indices. */
  float & Cij( Int_t i, Int_t j ){ return fC[IJ(i,j)]; }
  void TransportLine( float S, const float* dsdr, float P[], float C[], float* dsdr1, float* F, float* F1 ) const ;
  bool GetMeasurement( const KFParticleBase& daughter, float m[], float V[], float D[3][3] ) ;
  void SetMassConstraint( float *mP, float *mC, float mJ[7][7], float mass );

  float fP[8];           ///< Particle parameters { X, Y, Z, Px, Py, Pz, E, S[=DecayLength/P]}.
  float fC[36];          ///< Low-triangle covariance matrix of fP.
  float fChi2;           ///< Chi^2.
  float fSFromDecay;     ///< Distance from the decay vertex to the current position.
  float SumDaughterMass; ///< Sum of the daughter particles masses. Needed to set the constraint on the minimum mass during particle construction.
  float fMassHypo;       ///< The mass hypothesis, used for the constraints during particle construction.
  Int_t fNDF;            ///< Number of degrees of freedom.
  int   fId;             ///< Id of the particle.
#ifdef __ROOT__ //for the STAR experiment
  Short_t    fParentID;     ///< Id of the parent particle.
  Short_t    fIdTruth;      ///< MC track id.
  Short_t    fQuality;      ///< quality of this information (percentage of hits coming from the above MC track).
  Short_t    fIdParentMcVx; ///< for track and McTrack for vertex.
#endif
  Bool_t fAtProductionVertex; ///< Flag shows if particle is at the production point.
  char fQ; ///< The charge of the particle in the units of the elementary charge.
  
  /** \brief Determines the method for the particle construction. \n
   ** 0 - Energy considered as an independent veriable, fitted independently from momentum, without any constraints on mass \n
   ** 2 - Energy considered as an independent variable, fitted independently from momentum, with constraints on mass of daughter particle
   **/
  char fConstructMethod; 
  int fPDG; ///< The PDG hypothesis assigned to the particle.
  
  /** \brief A vector with ids of the daughter particles: \n
   ** 1) if particle is created from a track - the index of the track, in this case the size of the vector is always equal to one; \n
   ** 2) if particle is constructed from other particles - indices of these particles in the same array.
   **/
  std::vector<int> fDaughtersIds;
 
#ifndef KFParticleStandalone
  ClassDef( KFParticleBase, 2 )
#endif
};

#ifdef __ROOT__ //for the STAR experiment
std::ostream&  operator<<(std::ostream& os, KFParticleBase const & particle);
#endif

#endif 
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *               2007-2019 Sergey Gorbunov
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

//#define NonhomogeneousField
// #define HomogeneousField

#ifndef KFPARTICLE_H
#define KFPARTICLE_H

#include "KFParticleBase.h"
#include <cmath>

class KFPTrack;
class KFPVertex;

/** @class KFParticle
 ** @brief The main scalar class of KF Particle package, describes particle objects.
 ** @author  S.Gorbunov, I.Kisel, M.Zyzak
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** The main scalar class of KF Particle pacakge, describes particle objects.
 ** The particle is described with the state vector { X, Y, Z, Px, Py, Pz, E }
 ** and the corresponding covariance matrix.
 ** It contains functionality to create particle-object from track, to construct 
 ** short-lived particles from other tracks or particles. The mathematics is 
 ** based on the Kalman filter method. It also allows to subtract particles from 
 ** the already constructed object,
 ** to transport particles, get parameters together with their errors, get distance 
 ** to other particles and vertices, get deviations from them in terms of errors, etc.
 **/

class KFParticle :public KFParticleBase
{
  
 public:

  //*
  //*  INITIALIZATION
  //*

  //* Set magnetic field for all particles
#ifdef HomogeneousField
  static void SetField( float Bz );
#endif
  //* Constructor (empty)

  KFParticle():KFParticleBase(){ ; }

  //* Destructor (empty)

  ~KFParticle(){ ; }

  //* Construction of mother particle by its 2-3-4 daughters

  KFParticle( const KFParticle &d1, const KFParticle &d2 );

  KFParticle( const KFParticle &d1, const KFParticle &d2, 
              const KFParticle &d3 );

  KFParticle( const KFParticle &d1, const KFParticle &d2, 
              const KFParticle &d3, const KFParticle &d4 );
 
 //* Initialisation from "cartesian" coordinates ( X Y Z Px Py Pz )
 //* Parameters, covariance matrix, charge and PID hypothesis should be provided 

  void Create( const float Param[], const float Cov[], Int_t Charge, float mass /*Int_t PID*/ );
  void Create( const Double_t Param[], const Double_t Cov[], Int_t Charge, float mass /*Int_t PID*/ );

 //* Initialisation from ALICE track, PID hypothesis shoould be provided 

  KFParticle( const KFPTrack &track, const int PID );


  //* Initialisation from VVertex 

  KFParticle( const KFPVertex &vertex );

  //* Initialise covariance matrix and set current parameters to 0.0 

  void Initialize();

  //*
  //*  ACCESSORS
  //*

  //* Simple accessors 

  float GetX    () const ; ///< Retruns X coordinate of the particle, fP[0].
  float GetY    () const ; ///< Retruns Y coordinate of the particle, fP[1].
  float GetZ    () const ; ///< Retruns Z coordinate of the particle, fP[2].
  float GetPx   () const ; ///< Retruns X component of the momentum, fP[3].
  float GetPy   () const ; ///< Retruns Y component of the momentum, fP[4].
  float GetPz   () const ; ///< Retruns Z component of the momentum, fP[5].
  float GetE    () const ; ///< Returns energy of the particle, fP[6].
  float GetS    () const ; ///< Returns dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  char  GetQ    () const ; ///< Returns charge of the particle.
  float GetChi2 () const ; ///< Returns Chi2 of the fit.
  Int_t GetNDF  () const ; ///< Returns number of decrease of freedom.

  Bool_t GetAtProductionVertex() const { return fAtProductionVertex; } ///< Returns a flag which shows if the particle is located at the production point
  void SetAtProductionVertex(Bool_t b) { fAtProductionVertex = b; } ///< Set a flag that particle is at the production point

#ifdef NonhomogeneousField
  const float* GetFieldCoeff() const { return fieldRegion; } ///< Returns the field approximation for the current particle
  void SetFieldCoeff(float c, int i) { fieldRegion[i] = c; } ///< Sets the field coefficient with index i.
#endif

  const float& X    () const { return fP[0]; } ///< Retruns X coordinate of the particle, fP[0].
  const float& Y    () const { return fP[1]; } ///< Retruns Y coordinate of the particle, fP[1].
  const float& Z    () const { return fP[2]; } ///< Retruns Z coordinate of the particle, fP[2].
  const float& Px   () const { return fP[3]; } ///< Retruns X component of the momentum, fP[3].
  const float& Py   () const { return fP[4]; } ///< Retruns Y component of the momentum, fP[4].
  const float& Pz   () const { return fP[5]; } ///< Retruns Z component of the momentum, fP[5].
  const float& E    () const { return fP[6]; } ///< Returns energy of the particle, fP[6].
  const float& S    () const { return fP[7]; } ///< Returns dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  const char&  Q    () const { return fQ;    } ///< Returns charge of the particle.
  const float& Chi2 () const { return fChi2; } ///< Returns Chi2 of the fit.
  const Int_t& NDF  () const { return fNDF;  } ///< Returns number of decrease of freedom.
  
  float GetParameter ( int i ) const ;        ///< Returns P[i] parameter.
  float GetCovariance( int i ) const ;        ///< Returns C[i] element of the covariance matrix in the lower triangular form.
  float GetCovariance( int i, int j ) const ; ///< Returns C[i,j] element of the covariance matrix.

  //* Accessors with calculations, value returned w/o error flag
  
  float GetP             () const; ///< Returns momentum
  float GetPt            () const; ///< Returns transverse momentum
  float GetEta           () const; ///< Returns pseudorapidity
  float GetPhi           () const; ///< Returns the azimuthal angle phi 
  float GetMomentum      () const; ///< Returns momentum
  float GetMass          () const; ///< Returns mass
  float GetDecayLength   () const; ///< Returns decay length
  float GetDecayLengthXY () const; ///< Returns decay length in XY
  float GetLifeTime      () const; ///< Returns life time ctau [cm]
  float GetR             () const; ///< Returns distance to the origin of the coordinate system {0,0,0}

  //* Accessors to estimated errors

  float GetErrX             () const ; ///< Returns the error of X of current position 
  float GetErrY             () const ; ///< Returns the error of Y of current position
  float GetErrZ             () const ; ///< Returns the error of Z of current position
  float GetErrPx            () const ; ///< Returns the error of X-compoment of the particle momentum
  float GetErrPy            () const ; ///< Returns the error of Y-compoment of the particle momentum
  float GetErrPz            () const ; ///< Returns the error of Z-compoment of the particle momentum
  float GetErrE             () const ; ///< Returns the error of energy
  float GetErrS             () const ; ///< Returns the error of decay length / momentum
  float GetErrP             () const ; ///< Returns the error of momentum
  float GetErrPt            () const ; ///< Returns the error of transverse momentum
  float GetErrEta           () const ; ///< Returns the error of pseudorapidity
  float GetErrPhi           () const ; ///< Returns the error of the azimuthal angle phi 
  float GetErrMomentum      () const ; ///< Returns the error of momentum
  float GetErrMass          () const ; ///< Returns the error of mass
  float GetErrDecayLength   () const ; ///< Returns the error of decay length
  float GetErrDecayLengthXY () const ; ///< Returns the error of decay length in XY
  float GetErrLifeTime      () const ; ///< Returns the error of life time
  float GetErrR             () const ; ///< Returns the error of distance to the origin of the coordinate system {0,0,0}

  //* Accessors with calculations( &value, &estimated sigma )
  //* error flag returned (0 means no error during calculations) 

  int GetP             ( float &P, float &SigmaP ) const ;     //* momentum
  int GetPt            ( float &Pt, float &SigmaPt ) const ;   //* transverse momentum
  int GetEta           ( float &Eta, float &SigmaEta ) const ; //* pseudorapidity
  int GetPhi           ( float &Phi, float &SigmaPhi ) const ; //* phi
  int GetMomentum      ( float &P, float &SigmaP ) const ;     //* momentum
  int GetMass          ( float &M, float &SigmaM ) const ;     //* mass
  int GetDecayLength   ( float &L, float &SigmaL ) const ;     //* decay length
  int GetDecayLengthXY ( float &L, float &SigmaL ) const ;     //* decay length in XY
  int GetLifeTime      ( float &T, float &SigmaT ) const ;     //* life time
  int GetR             ( float &R, float &SigmaR ) const ;     //* R
  float GetRapidity() const { return 0.5*log((fP[6] + fP[5])/(fP[6] - fP[5])); } ///< Returns rapidity of the particle
  float GetTheta()    const { return atan2(GetPt(),fP[5]); } ///< Returns the polar angle in RZ


  //*
  //*  MODIFIERS
  //*
  
  float & X    () ; ///< Modifier of X coordinate of the particle, fP[0].
  float & Y    () ; ///< Modifier of Y coordinate of the particle, fP[1].
  float & Z    () ; ///< Modifier of Z coordinate of the particle, fP[2].
  float & Px   () ; ///< Modifier of X component of the momentum, fP[3].
  float & Py   () ; ///< Modifier of Y component of the momentum, fP[4].
  float & Pz   () ; ///< Modifier of Z component of the momentum, fP[5].
  float & E    () ; ///< Modifier of energy of the particle, fP[6].
  float & S    () ; ///< Modifier of dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  char  & Q    () ; ///< Modifier of charge of the particle.
  float & Chi2 () ; ///< Modifier of Chi2 of the fit.
  Int_t & NDF  () ; ///< Modifier of number of decrease of freedom.

  float & Parameter ( int i ) ;        ///< Modifier of P[i] parameter.
  float & Covariance( int i ) ;        ///< Modifier of C[i] element of the covariance matrix in the lower triangular form.
  float & Covariance( int i, int j ) ; ///< Modifier of C[i,j] element of the covariance matrix.
  float * Parameters () ;              ///< Returns pointer to the parameters fP
  float * CovarianceMatrix() ;         ///< Returns pointer to the covariance matrix fC

  //* 
  //* CONSTRUCTION OF THE PARTICLE BY ITS DAUGHTERS AND MOTHER
  //* USING THE KALMAN FILTER METHOD
  //*


  //* Add daughter to the particle 

  void AddDaughter( const KFParticle &Daughter );

  //* Add daughter via += operator: ex.{ D0; D0+=Pion; D0+= Kaon; }

  void operator +=( const KFParticle &Daughter );  

  //* Everything in one go  

  void Construct( const KFParticle *vDaughters[], int nDaughters, 
		  const KFParticle *ProdVtx=0,   float Mass=-1 );

  //*
  //*                   TRANSPORT
  //* 
  //*  ( main transportation parameter is S = SignedPath/Momentum )
  //*  ( parameters of decay & production vertices are stored locally )
  //*

  //* Transport the particle close to xyz[] point 

  void TransportToPoint( const float xyz[] );

  //* Transport the particle close to VVertex  
#ifdef HomogeneousField
  void TransportToVertex( const KFPVertex &v );
#endif
  //* Transport the particle close to another particle p 
  void TransportToParticle( const KFParticle &p );

  //* Get dS to a certain space point 
  float GetDStoPoint( const float xyz[3], float dsdr[6] ) const ;
  
  //* Get dS to other particle p (dSp for particle p also returned) 
  void GetDStoParticle( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const ;
  
  
  //* 
  //* OTHER UTILITIES
  //*
 
  //* Calculate distance from another object [cm] in XY-plane

  Bool_t GetDistanceFromVertexXY( const float vtx[], float &val, float &err ) const ;
  Bool_t GetDistanceFromVertexXY( const float vtx[], const float Cv[], float &val, float &err ) const ;
  Bool_t GetDistanceFromVertexXY( const KFParticle &Vtx, float &val, float &err ) const ;
#ifdef HomogeneousField
  Bool_t GetDistanceFromVertexXY( const KFPVertex &Vtx, float &val, float &err ) const ;
#endif

  float GetDistanceFromVertexXY( const float vtx[] ) const ;
  float GetDistanceFromVertexXY( const KFParticle &Vtx ) const ;
#ifdef HomogeneousField
  float GetDistanceFromVertexXY( const KFPVertex &Vtx ) const ;
#endif
  float GetDistanceFromParticleXY( const KFParticle &p ) const ;

  //* Calculate sqrt(Chi2/ndf) deviation from another object in XY plane
  //* ( v = [xyz]-vertex, Cv=[Cxx,Cxy,Cyy,Cxz,Cyz,Czz]-covariance matrix )

  float GetDeviationFromVertexXY( const float v[], const float Cv[]=0 ) const ;
  float GetDeviationFromVertexXY( const KFParticle &Vtx ) const ;
#ifdef HomogeneousField
  float GetDeviationFromVertexXY( const KFPVertex &Vtx ) const ;
#endif
  float GetDeviationFromParticleXY( const KFParticle &p ) const ;

  //* Get parameters at an arbitrary reconstructed point taking into account its errors
  void GetParametersAtPoint(const float* point, const float* pointCov, float* m, float* mV);
  
  //* Calculate opennig angle between two particles

  float GetAngle  ( const KFParticle &p ) const ;
  float GetAngleXY( const KFParticle &p ) const ;
  float GetAngleRZ( const KFParticle &p ) const ;

  float GetPseudoProperDecayTime( const KFParticle &primVertex, const float& mass, float* timeErr2 = 0 ) const;

  void GetFieldValue( const float xyz[], float B[] ) const ;

  void Transport( float dS, const float* dsdr, float P[], float C[], float* dsdr1=0, float* F=0, float* F1=0 ) const ;

 protected: 
  
  //*
  //*  INTERNAL STUFF
  //* 

  //* Method to access ALICE field 
#ifdef HomogeneousField
  static float GetFieldAlice();
#endif
  
 private:
#ifdef HomogeneousField
  static float fgBz;  ///< Bz compoment of the magnetic field (is defined in case of #ifdef HomogeneousField)
#endif
#ifdef NonhomogeneousField
  /** \brief Approximation of the magnetic field along the track trajectory.
   ** Each component (Bx, By, Bz) is approximated with the parabola depending on Z coordinate. Is defined in case of #ifdef NonhomogeneousField.
   **/
  float fieldRegion[10];
#endif
  
#ifndef KFParticleStandalone
  ClassDef( KFParticle, 3 )
#endif
};



//---------------------------------------------------------------------
//
//     Inline implementation of the KFParticle methods
//
//---------------------------------------------------------------------

#ifdef HomogeneousField
inline void KFParticle::SetField( float Bz )
{ 
  /** Sets the constant homogemeous one-component magnetic field Bz (is defined in case of #ifdef HomogeneousField).
   ** \param[in] Bz - Z-component of the magnetic field
   **/
  fgBz = Bz;
}
#endif

inline KFParticle::KFParticle( const KFParticle &d1, 
                               const KFParticle &d2, 
                               const KFParticle &d3 )
{
  /** Constructs a particle from three input daughter particles
   ** \param[in] d1 - the first daughter particle
   ** \param[in] d2 - the second daughter particle
   ** \param[in] d3 - the third daughter particle
   **/
  KFParticle mother;
  mother+= d1;
  mother+= d2;
  mother+= d3;
  *this = mother;
}

inline KFParticle::KFParticle( const KFParticle &d1, 
                               const KFParticle &d2, 
                               const KFParticle &d3, 
                               const KFParticle &d4 )
{
  /** Constructs a particle from four input daughter particles
   ** \param[in] d1 - the first daughter particle
   ** \param[in] d2 - the second daughter particle
   ** \param[in] d3 - the third daughter particle
   ** \param[in] d4 - the fourth daughter particle
   **/
  KFParticle mother;
  mother+= d1;
  mother+= d2;
  mother+= d3;
  mother+= d4;
  *this = mother;
}


inline void KFParticle::Initialize()
{ 
  /** Calls KFParticleBase::Initialize()*/
  KFParticleBase::Initialize(); 
}

inline float KFParticle::GetX    () const 
{ 
  return KFParticleBase::GetX();    
}

inline float KFParticle::GetY    () const 
{ 
  return KFParticleBase::GetY();    
}

inline float KFParticle::GetZ    () const 
{ 
  return KFParticleBase::GetZ();    
}

inline float KFParticle::GetPx   () const 
{ 
  return KFParticleBase::GetPx();   
}

inline float KFParticle::GetPy   () const 
{ 
  return KFParticleBase::GetPy();   
}

inline float KFParticle::GetPz   () const 
{ 
  return KFParticleBase::GetPz();   
}

inline float KFParticle::GetE    () const 
{ 
  return KFParticleBase::GetE();    
}

inline float KFParticle::GetS    () const 
{ 
  return KFParticleBase::GetS();    
}

inline char    KFParticle::GetQ    () const 
{ 
  return KFParticleBase::GetQ();    
}

inline float KFParticle::GetChi2 () const 
{ 
  return KFParticleBase::GetChi2(); 
}

inline Int_t    KFParticle::GetNDF  () const 
{ 
  return KFParticleBase::GetNDF();  
}

inline float KFParticle::GetParameter ( int i ) const 
{ 
  return KFParticleBase::GetParameter(i);  
}

inline float KFParticle::GetCovariance( int i ) const 
{ 
  return KFParticleBase::GetCovariance(i); 
}

inline float KFParticle::GetCovariance( int i, int j ) const 
{ 
  return KFParticleBase::GetCovariance(i,j);
}


inline float KFParticle::GetP    () const
{
  float par, err;
  if( KFParticleBase::GetMomentum( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetPt   () const
{
  float par, err;
  if( KFParticleBase::GetPt( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetEta   () const
{
  float par, err;
  if( KFParticleBase::GetEta( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetPhi   () const
{
  float par, err;
  if( KFParticleBase::GetPhi( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetMomentum    () const
{
  float par, err;
  if( KFParticleBase::GetMomentum( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetMass        () const
{
  float par, err;
  if( KFParticleBase::GetMass( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetDecayLength () const
{
  float par, err;
  if( KFParticleBase::GetDecayLength( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetDecayLengthXY () const
{
  float par, err;
  if( KFParticleBase::GetDecayLengthXY( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetLifeTime    () const
{
  float par, err;
  if( KFParticleBase::GetLifeTime( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetR   () const
{
  float par, err;
  if( KFParticleBase::GetR( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetErrX           () const 
{
  return sqrt(fabs( GetCovariance(0,0) ));
}

inline float KFParticle::GetErrY           () const 
{
  return sqrt(fabs( GetCovariance(1,1) ));
}

inline float KFParticle::GetErrZ           () const 
{
  return sqrt(fabs( GetCovariance(2,2) ));
}

inline float KFParticle::GetErrPx          () const 
{
  return sqrt(fabs( GetCovariance(3,3) ));
}

inline float KFParticle::GetErrPy          () const 
{
  return sqrt(fabs( GetCovariance(4,4) ));
}

inline float KFParticle::GetErrPz          () const 
{
  return sqrt(fabs( GetCovariance(5,5) ));
}

inline float KFParticle::GetErrE           () const 
{
  return sqrt(fabs( GetCovariance(6,6) ));
}

inline float KFParticle::GetErrS           () const 
{
  return sqrt(fabs( GetCovariance(7,7) ));
}

inline float KFParticle::GetErrP    () const
{
  float par, err;
  if( KFParticleBase::GetMomentum( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrPt    () const
{
  float par, err;
  if( KFParticleBase::GetPt( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrEta    () const
{
  float par, err;
  if( KFParticleBase::GetEta( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrPhi    () const
{
  float par, err;
  if( KFParticleBase::GetPhi( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrMomentum    () const
{
  float par, err;
  if( KFParticleBase::GetMomentum( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrMass        () const
{
  float par, err;
  if( KFParticleBase::GetMass( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrDecayLength () const
{
  float par, err;
  if( KFParticleBase::GetDecayLength( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrDecayLengthXY () const
{
  float par, err;
  if( KFParticleBase::GetDecayLengthXY( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrLifeTime    () const
{
  float par, err;
  if( KFParticleBase::GetLifeTime( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrR    () const
{
  float par, err;
  if( KFParticleBase::GetR( par, err ) ) return 1.e10;
  else return err;
}


inline int KFParticle::GetP( float &P, float &SigmaP ) const 
{
  /** Calculates particle momentum and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] P - momentum of the particle
   ** \param[out] SigmaP - its error
   **/
  return KFParticleBase::GetMomentum( P, SigmaP );
}

inline int KFParticle::GetPt( float &Pt, float &SigmaPt ) const 
{
  /** Calculates particle transverse  momentum and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] Pt - transverse momentum of the particle
   ** \param[out] SigmaPt - its error
   **/
  return KFParticleBase::GetPt( Pt, SigmaPt );
}

inline int KFParticle::GetEta( float &Eta, float &SigmaEta ) const 
{
  /** Calculates particle pseudorapidity and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] Eta - pseudorapidity of the particle
   ** \param[out] SigmaEta - its error
   **/
  return KFParticleBase::GetEta( Eta, SigmaEta );
}

inline int KFParticle::GetPhi( float &Phi, float &SigmaPhi ) const 
{
  /** Calculates particle polar angle at the current point and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] Phi - polar angle of the particle
   ** \param[out] SigmaPhi - its error
   **/
  return KFParticleBase::GetPhi( Phi, SigmaPhi );
}

inline int KFParticle::GetMomentum( float &P, float &SigmaP ) const 
{
  /** Calculates particle momentum and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] P - momentum of the particle
   ** \param[out] SigmaP - its error
   **/
  return KFParticleBase::GetMomentum( P, SigmaP );
}

inline int KFParticle::GetMass( float &M, float &SigmaM ) const 
{
  /** Calculates the mass of the particle and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] M - mass of the particle
   ** \param[out] SigmaM - its error
   **/
  return KFParticleBase::GetMass( M, SigmaM );
}

inline int KFParticle::GetDecayLength( float &L, float &SigmaL ) const 
{
  /** Calculates the decay length of the particle in the laboratory system and its error. If they are well defined returns 0, otherwise 1.
   ** The production point should be set before calling this function.
   ** \param[out] L - the decay length
   ** \param[out] SigmaL - its error
   **/
  return KFParticleBase::GetDecayLength( L, SigmaL );
}

inline int KFParticle::GetDecayLengthXY( float &L, float &SigmaL ) const 
{
  /** Calculates the projection in the XY plane of the decay length of the particle in the laboratory 
   ** system and its error. If they are well defined returns 0, otherwise 1.
   ** The production point should be set before calling this function.
   ** \param[out] L - the decay length
   ** \param[out] SigmaL - its error
   **/
  return KFParticleBase::GetDecayLengthXY( L, SigmaL );
}

inline int KFParticle::GetLifeTime( float &T, float &SigmaT ) const 
{
  /** Calculates the lifetime times speed of life (ctau) [cm] of the particle in the  
   ** center of mass frame and its error. If they are well defined returns 0, otherwise 1.
   ** The production point should be set before calling this function.
   ** \param[out] T - lifetime of the particle [cm]
   ** \param[out] SigmaT - its error
   **/
  return KFParticleBase::GetLifeTime( T, SigmaT );
}

inline int KFParticle::GetR( float &R, float &SigmaR ) const 
{
  /** Calculates the distance to the point {0,0,0} and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] R - polar angle of the particle
   ** \param[out] SigmaR - its error
   **/
  return KFParticleBase::GetR( R, SigmaR );
}

inline float & KFParticle::X() 
{ 
  return KFParticleBase::X();    
}

inline float & KFParticle::Y()
{ 
  return KFParticleBase::Y();    
}

inline float & KFParticle::Z() 
{ 
  return KFParticleBase::Z();    
}

inline float & KFParticle::Px() 
{ 
  return KFParticleBase::Px();   
}

inline float & KFParticle::Py() 
{ 
  return KFParticleBase::Py();   
}

inline float & KFParticle::Pz() 
{ 
  return KFParticleBase::Pz();   
}

inline float & KFParticle::E() 
{ 
  return KFParticleBase::E();    
}

inline float & KFParticle::S() 
{ 
  return KFParticleBase::S();    
}

inline char    & KFParticle::Q() 
{ 
  return KFParticleBase::Q();    
}

inline float & KFParticle::Chi2() 
{ 
  return KFParticleBase::Chi2(); 
}

inline Int_t    & KFParticle::NDF() 
{ 
  return KFParticleBase::NDF();  
}

inline float & KFParticle::Parameter ( int i )        
{ 
  return KFParticleBase::Parameter(i);
}

inline float & KFParticle::Covariance( int i )        
{ 
  return KFParticleBase::Covariance(i);
}

inline float & KFParticle::Covariance( int i, int j ) 
{ 
  return KFParticleBase::Covariance(i,j); 
}

inline float * KFParticle::Parameters ()
{
  return fP;
}

inline float * KFParticle::CovarianceMatrix()
{
  return fC;
}


inline void KFParticle::operator +=( const KFParticle &Daughter )
{
  /** Operator to add daughter to the current particle. Calls AddDaughter() function.
   ** \param[in] Daughter - the daughter particle
   **/
#ifdef NonhomogeneousField
  for(int i=0; i<10; i++)
    SetFieldCoeff(Daughter.GetFieldCoeff()[i], i);
#endif
  KFParticleBase::operator +=( Daughter );
}
  

inline void KFParticle::AddDaughter( const KFParticle &Daughter )
{
  /** Adds daughter to the current particle. Depending on the selected construction method uses: \n
   ** 1) Either simplifyed fast mathematics which consideres momentum and energy as
   ** independent variables and thus ignores constraint on the fixed mass (fConstructMethod = 0).
   ** In this case the mass of the daughter particle can be corrupted when the constructed vertex
   ** is added as the measurement and the mass of the output short-lived particle can become 
   ** unphysical - smaller then the threshold. Implemented in the 
   ** AddDaughterWithEnergyFit() function \n
   ** 2) Or slower but correct mathematics which requires that the masses of daughter particles 
   ** stays fixed in the construction process (fConstructMethod = 2). Implemented in the
   ** AddDaughterWithEnergyFitMC() function.
   ** \param[in] Daughter - the daughter particle
   **/
#ifdef NonhomogeneousField
  for(int i=0; i<10; i++)
    SetFieldCoeff(Daughter.GetFieldCoeff()[i], i);
#endif
  KFParticleBase::AddDaughter( Daughter );
}

inline void KFParticle::Construct( const KFParticle *vDaughters[], int nDaughters, 
                                   const KFParticle *ProdVtx,   float Mass )
{    
  /** Constructs a short-lived particle from a set of daughter particles:\n
   ** 1) all parameters of the "this" objects are initialised;\n
   ** 2) daughters are added one after another;\n
   ** 3) if Parent pointer is not null, the production vertex is set to it;\n
   ** 4) if Mass hypothesis >=0 the mass constraint is set.
   ** \param[in] vDaughters - array of daughter particles
   ** \param[in] nDaughters - number of daughter particles in the input array
   ** \param[in] Parent - optional parrent particle
   ** \param[in] Mass - optional mass hypothesis
   **/  
#ifdef NonhomogeneousField
  for(int i=0; i<10; i++)
    SetFieldCoeff(vDaughters[0]->GetFieldCoeff()[i], i);
#endif
  KFParticleBase::Construct( ( const KFParticleBase**)vDaughters, nDaughters, 
                             ( const KFParticleBase*)ProdVtx, Mass );
}

inline void KFParticle::TransportToPoint( const float xyz[] )
{ 
  /** Transports particle to the distance of closest approach to the point xyz.
   ** \param[in] xyz[3] - point, where particle should be transported
   **/
  float dsdr[6] = {0.f};
  float dS = GetDStoPoint(xyz, dsdr);
  TransportToDS( dS, dsdr );
}
#ifdef HomogeneousField
inline void KFParticle::TransportToVertex( const KFPVertex &v )
{ 
  /** Transports particle to the distance of closest approach to the vertex v.
   ** \param[in] v - vertex, where particle should be transported
   **/
  TransportToPoint( KFParticle(v).fP );
}
#endif
inline void KFParticle::TransportToParticle( const KFParticle &p )
{ 
  /** Transports particle to the distance of closest approach to the particle p.
   ** \param[in] p - particle, to which the current particle should be transported.
   **/
  float dsdr[4][6];
  float dS[2];
  GetDStoParticle( p, dS, dsdr );
  TransportToDS( dS[0], dsdr[0] );
}

inline float KFParticle::GetDStoPoint( const float xyz[], float* dsdr ) const 
{
  /** Returns dS = l/p parameter, where \n
   ** 1) l - signed distance to the DCA point with the input xyz point;\n
   ** 2) p - momentum of the particle; \n
   ** Also calculates partial derivatives dsdr of the parameter dS over the state vector of the current particle.
   ** If "HomogeneousField" is defined KFParticleBase::GetDStoPointBz() is called,
   ** if "NonhomogeneousField" is defined - KFParticleBase::GetDStoPointCBM()
   ** \param[in] xyz[3] - point, to which particle should be transported
   ** \param[out] dsdr[6] = ds/dr partial derivatives of the parameter dS over the state vector of the current particle
   ** \param[in] param - optional parameter, is used in case if the parameters of the particle are rotated
   ** to other coordinate system (see GetDStoPointBy() function), otherwise fP are used
   **/
#ifdef HomogeneousField
  return KFParticleBase::GetDStoPointBz( GetFieldAlice(), xyz, dsdr );
#endif
#ifdef NonhomogeneousField
  return KFParticleBase::GetDStoPointCBM( xyz, dsdr );
#endif
}

#ifdef HomogeneousField
inline float KFParticle::GetFieldAlice()
{ 
  /** Returns value of the constant homogemeous one-component magnetic field Bz, (is defined in case of #ifdef HomogeneousField). */
  return fgBz; 
}
#endif

#ifdef HomogeneousField
inline void KFParticle::GetFieldValue( const float * /*xyz*/, float B[] ) const 
{    
  /** Calculates the Bx, By, Bz components at the point xyz using approximation of the
   ** magnetic field along the particle trajectory.
   ** \param[in] xyz[3] - X, Y, Z coordiantes of the point where the magnetic field should be calculated
   ** \param[out] B[3] - value of X, Y, Z components of the calculated magnetic field at the given point
   **/
  
  B[0] = B[1] = 0;
  B[2] = GetFieldAlice();
}
#endif

#ifdef NonhomogeneousField
inline void KFParticle::GetFieldValue( const float xyz[], float B[] ) const 
{
  /** Calculates the Bx, By, Bz components at the point xyz using approximation of the
   ** magnetic field along the particle trajectory.
   ** \param[in] xyz[3] - X, Y, Z coordiantes of the point where the magnetic field should be calculated
   ** \param[out] B[3] - value of X, Y, Z components of the calculated magnetic field at the given point
   **/
  
  const float dz = (xyz[2]-fieldRegion[9]);
  const float dz2 = dz*dz;

  B[0] = fieldRegion[0] + fieldRegion[1]*dz + fieldRegion[2]*dz2;
  B[1] = fieldRegion[3] + fieldRegion[4]*dz + fieldRegion[5]*dz2;
  B[2] = fieldRegion[6] + fieldRegion[7]*dz + fieldRegion[8]*dz2;
}
#endif

inline void KFParticle::GetDStoParticle( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const
{ 
  /** Calculates dS = l/p parameters for two particles, where \n
   ** 1) l - signed distance to the DCA point with the other particle;\n
   ** 2) p - momentum of the particle \n
   ** dS[0] is the transport parameter for the current particle, dS[1] - for the particle "p".
   ** Also calculates partial derivatives dsdr of the parameters dS[0] and dS[1] over the state vectors of the particles:\n
   ** 1) dsdr[0][6] = d(dS[0])/d(param1);\n
   ** 2) dsdr[1][6] = d(dS[0])/d(param2);\n
   ** 3) dsdr[2][6] = d(dS[1])/d(param1);\n
   ** 4) dsdr[3][6] = d(dS[1])/d(param2);\n
   ** where param1 are parameters of the current particle fP and
   ** param2 are parameters of the second particle p.fP. If "HomogeneousField" is defined KFParticleBase::GetDStoParticleBz() is called,
   ** if "NonhomogeneousField" is defined - KFParticleBase::GetDStoParticleCBM()
   ** \param[in] p - second particle
   ** \param[out] dS[2] - transport parameters dS for the current particle (dS[0]) and the second particle "p" (dS[1])
   ** \param[out] dsdr[4][6] - partial derivatives of the parameters dS[0] and dS[1] over the state vectors of the both particles
   **/
#ifdef HomogeneousField
  KFParticleBase::GetDStoParticleBz( GetFieldAlice(), p, dS, dsdr ) ;
#endif
#ifdef NonhomogeneousField
  KFParticleBase::GetDStoParticleCBM( p, dS, dsdr ) ;
#endif
}

inline void KFParticle::Transport( float dS, const float* dsdr, float P[], float C[], float* dsdr1, float* F, float* F1 ) const 
{
  /** Transports the parameters and their covariance matrix of the current particle
   ** on a length defined by the transport parameter dS = l/p, where l is the signed distance and p is 
   ** the momentum of the current particle. If "HomogeneousField" is defined KFParticleBase::TransportBz()
   ** is called, if "NonhomogeneousField" - KFParticleBase::TransportCBM().
   ** The obtained parameters and covariance matrix are stored to the arrays P and 
   ** C respectively. P and C can be set to the parameters fP and covariance matrix fC of the current particle. In this
   ** case the particle parameters will be modified. Dependence of the transport parameter dS on the state vector of the
   ** current particle is taken into account in the covariance matrix using partial derivatives dsdr = d(dS)/d(fP). If
   ** a pointer to F is initialised the transport jacobian F = d(fP new)/d(fP old) is stored.
   ** Since dS can depend on the state vector r1 of other particle or vertex, the corelation matrix 
   ** F1 = d(fP new)/d(r1) can be optionally calculated if a pointer F1 is provided.
   *  Parameters F and F1 should be either both initialised or both set to null pointer.
   ** \param[in] dS - transport parameter which defines the distance to which particle should be transported
   ** \param[in] dsdr[6] = ds/dr - partial derivatives of the parameter dS over the state vector of the current particle
   ** \param[out] P[8] - array, where transported parameters should be stored
   ** \param[out] C[36] - array, where transported covariance matrix (8x8) should be stored in the lower triangular form 
   ** \param[in] dsdr1[6] = ds/dr - partial derivatives of the parameter dS over the state vector of another particle 
   ** or vertex
   ** \param[out] F[36] - optional parameter, transport jacobian, 6x6 matrix F = d(fP new)/d(fP old)
   ** \param[out] F1[36] - optional parameter, corelation 6x6 matrix betweeen the current particle and particle or vertex
   ** with the state vector r1, to which the current particle is being transported, F1 = d(fP new)/d(r1)
   **/ 
#ifdef HomogeneousField
  KFParticleBase::TransportBz( GetFieldAlice(), dS, dsdr, P, C, dsdr1, F, F1 );
#endif
#ifdef NonhomogeneousField
  KFParticleBase::TransportCBM( dS, dsdr, P, C, dsdr1, F, F1 );
#endif
}

#endif 
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifndef KFVERTEX_H
#define KFVERTEX_H

#include "KFParticle.h"
#include "KFPVertex.h"

/** @class KFVertex
 ** @brief Mathematics for reconstruction of primary vertices based on KFParticle.
 ** @author  S.Gorbunov, I.Kisel, M.Zyzak
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** The class is inherited from KFParticle, adds functionality for reconstruction of
 ** primary vertices.
 **/

class KFVertex : public KFParticle
{
 public:

  KFVertex():KFParticle(),fIsConstrained(0){ } 
  KFVertex( const KFParticle &particle ): KFParticle(particle), fIsConstrained(0) {} ///< Vertex is constructed from the current position of a given particle.
  KFVertex( const KFPVertex &vertex );
  ~KFVertex(){}

  Int_t GetNContributors() const { return fIsConstrained ?fNDF/2:(fNDF+3)/2; } ///< Returns number of particles used for construction of the vertex.


  void operator +=( const KFParticle &Daughter );  ///< Adds particle to a vertex.
  KFVertex operator -( const KFParticle &Daughter ) const; ///< Subtracts particle from a vertex, returns temporary object. Initial vertex stays untouched.
  void operator -=( const KFParticle &Daughter );  ///< Subtracts particle from a current vertex.

  void SetBeamConstraint( float X, float Y, float Z, 
                          float ErrX, float ErrY, float ErrZ );
  void SetBeamConstraintOff();

  void ConstructPrimaryVertex( const KFParticle *vDaughters[], int nDaughters,
                               Bool_t vtxFlag[], float ChiCut=3.5  );

 protected:

  Bool_t fIsConstrained; ///< Flag showing if the the beam constraint is set
  
#ifndef KFParticleStandalone
  ClassDef( KFVertex, 2 )
#endif
};


//---------------------------------------------------------------------
//
//     Inline implementation of the KFVertex methods
//
//---------------------------------------------------------------------


inline void KFVertex::operator+=( const KFParticle &Daughter )
{
  KFParticle::operator+=( Daughter );
}
  

inline void KFVertex::operator-=( const KFParticle &Daughter )
{
  Daughter.SubtractFromVertex( *this );
}
  
inline KFVertex KFVertex::operator-( const KFParticle &Daughter ) const 
{
  KFVertex tmp = *this;
  Daughter.SubtractFromVertex( tmp );
  return tmp;
}


#endif 
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef KFPartEfficiencies_H
#define KFPartEfficiencies_H

#include <map>
#include <iomanip>
#include "KFMCCounter.h"

#ifdef HLTCA_STANDALONE
#include "RootTypesDef.h"
#else
#include "TObject.h"
#endif

/** @class KFEfficiencyParticleInfo
 ** @brief A helper class to define parameters of the decay list in KFPartEfficiencies.
 ** @author  M.Zyzak, I.Kisel
 ** @date 05.02.2019
 ** @version 1.0
 **/

class KFEfficiencyParticleInfo
{
 public:
  KFEfficiencyParticleInfo():fName("null"),fTitle("null"),fPDG(0),fHistoMin(0.f),fHistoMax(0.f),fMass(0.f),fLifeTime(0.f),fCharge(0), fMassSigma(0.001) {};
  /** \brief Constructor with all parameters set in. There is no other way to define the parameters other then use this constructor.*/
  KFEfficiencyParticleInfo(std::string name, std::string title, int pdg, float histoMin, float histoMax, float mass, float lifeTime, int charge, float massSigma ):
    fName(name), fTitle(title), fPDG(pdg), fHistoMin(histoMin), fHistoMax(histoMax), fMass(mass), fLifeTime(lifeTime), fCharge(charge), fMassSigma(massSigma) {};
  ~KFEfficiencyParticleInfo() {};
  
  //accessors
  std::string Name()      const { return fName; }      ///< Returns name of the decay in the file with histograms.
  std::string Title()     const { return fTitle; }     ///< Returns name of the decay in the output table with efficiency.
  int         PDG()       const { return fPDG; }       ///< Returns the assigned PDG code.
  float       HistoMin()  const { return fHistoMin; }  ///< Returns lower boundary in the mass histogram for the current decay.
  float       HistoMax()  const { return fHistoMax; }  ///< Returns upper boundary in the mass histogram for the current decay.
  float       Mass()      const { return fMass; }      ///< Returns table mass of the particle.
  float       LifeTime()  const { return fLifeTime; }  ///< Returns lifetime of the particle.
  int         Charge()    const { return fCharge; }    ///< Returns charge of the particle in units of the elementary charge.
  float       MassSigma() const { return fMassSigma; } ///< Returns expected width of the mass peak, used in the side bands method.
  
 private:
  std::string fName;  ///< Name of the decay in the file with histograms.
  std::string fTitle; ///< Name of the decay in the output table with efficiency.
  int fPDG;           ///< PDG code assigned to the current decay in the scheme of KF Particle Finder.
  float fHistoMin;    ///< Lower boundary in the mass histogram for the current decay.
  float fHistoMax;    ///< Upper boundary in the mass histogram for the current decay.
  float fMass;        ///< Table mass of the particle.
  float fLifeTime;    ///< Lifetime of the particle in seconds.
  int fCharge;        ///< Charge in units of the elementary charge.
  float fMassSigma;   ///< Expected width of the decay, determines peak sigma for the side bands method.
};

/** @class KFPartEfficiencies
 ** @brief Class to calculate efficiency of KF Particle Finder.
 ** @author  M.Zyzak, I.Kisel
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** The class has two main purposes:\n
 ** 1) Defines the list of decays to be analysed: a unique code of the decay, its mass, lifetime,
 ** a list of daughter particles, etc. See KFPartEfficiencies::KFPartEfficiencies() for more details.\n
 ** 2) It calculates reconstruction efficiency of the decays from the KF Particle Finder scheme.\n
 ** Definitions:\n
 ** background - physics background, when daughter particle come from the real particle, but the pdg
 ** hypothesis is incorrect, for example, Lambda->p pi will create a physics background for
 ** K0s if the proton is misidentified;\n
 ** ghost - combinatorial background, tracks do not form a real vertex;\n
 ** clone - a particle is reconstructed several times, for example, particle track is split into 
 ** to parts due to the multiple scattering.
 **/

class KFPartEfficiencies :public TObject
{
 public:

  /** \brief The default constructor. Defines the list of decays to be analysed and their properties. Please, see the code for indexing scheme. */
  KFPartEfficiencies():
    partDaughterPdg(0),
    names(),
    indices(),
    fPdgToIndex(),
    ratio_reco1(),
    ratio_reco2(),
    ratio_reco3(),
    mc1(),
    mc2(),
    mc3(),
    reco(),
    ratio_ghost(),
    ratio_bg(),
    ratio_clone(),
    ghost(),
    bg(),
    clone()
  {                                    
    KFEfficiencyParticleInfo particleInfo[nParticles] = 
    {
      //                       name                title               PDG code   min   max    mass       lifetime    Q
#ifdef CBM
      KFEfficiencyParticleInfo("Ks",               "KShort        ",        310, 0.3f, 1.3f, 0.497614   , 8.954e-11,  0, 0.0045), //0
#else
      KFEfficiencyParticleInfo("Ks",               "KShort        ",        310, 0.3f, 1.3f, 0.497614   , 8.954e-11,  0, 0.0057), //0
#endif
      KFEfficiencyParticleInfo("Lambda",           "Lambda        ",       3122, 1.0f, 2.0f, 1.115683   , 2.632e-10,  0, 0.0020), //1
      KFEfficiencyParticleInfo("Lambdab",          "Lambda b      ",      -3122, 1.0f, 2.0f, 1.115683   , 2.632e-10,  0, 0.0020), //2
      KFEfficiencyParticleInfo("Xi-",              "Xi-           ",       3312, 1.0f, 3.0f, 1.32171    , 1.639e-10, -1, 0.0022), //3
      KFEfficiencyParticleInfo("Xi+",              "Xi+           ",      -3312, 1.0f, 3.0f, 1.32171    , 1.639e-10,  1, 0.0022), //4
      KFEfficiencyParticleInfo("Xi0",              "Xi0           ",       3322, 1.0f, 3.0f, 1.31486    , 2.9e-10,    0, 0.0030), //5
      KFEfficiencyParticleInfo("Xi0b",             "Xi0 b         ",      -3322, 1.0f, 3.0f, 1.31486    , 2.9e-10,    0, 0.0030), //6
      KFEfficiencyParticleInfo("Omega-",           "Omega-        ",       3334, 1.0f, 3.0f, 1.67245    , 0.821e-10, -1, 0.0022), //7
      KFEfficiencyParticleInfo("Omega+",           "Omega+        ",      -3334, 1.0f, 3.0f, 1.67245    , 0.821e-10,  1, 0.0022), //8
      KFEfficiencyParticleInfo("Sigma^0",          "Sigma0        ",       3212, 1.0f, 3.0f, 1.192642   , 7.4e-20,    0, 0.0030), //9
      KFEfficiencyParticleInfo("Sigma^0b",         "Sigma0 b      ",      -3212, 1.0f, 3.0f, 1.192642   , 7.4e-20,    0, 0.0030), //10
      KFEfficiencyParticleInfo("Sigma^+",          "Sigma+        ",       3222, 1.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0030), //11
      KFEfficiencyParticleInfo("Sigma^-b",         "Sigma- b      ",      -3222, 1.0f, 3.0f, 1.18937    , 0.8018e-10,-1, 0.0030), //12
      KFEfficiencyParticleInfo("K*0",              "K*0           ",        313, 0.6f, 2.6f, 0.8958     , 1.38e-23,   0, 0.0300), //13
      KFEfficiencyParticleInfo("K*0b",             "K*0 b         ",       -313, 0.6f, 2.6f, 0.8958     , 1.38e-23,   0, 0.0300), //14
      KFEfficiencyParticleInfo("K*+",              "K*+           ",        323, 0.6f, 2.6f, 0.89166    , 1.30e-23,   1, 0.0300), //15
      KFEfficiencyParticleInfo("K*-",              "K*-           ",       -323, 0.6f, 2.6f, 0.89166    , 1.30e-23,  -1, 0.0300), //16
      KFEfficiencyParticleInfo("K*0_K0,pi0",       "K*0_K0pi0     ",     100313, 0.6f, 2.6f, 0.8958     , 1.38e-23,   0, 0.0030), //17
      KFEfficiencyParticleInfo("K*+_K+,pi0",       "K*+_K+pi0     ",     100323, 0.6f, 2.6f, 0.89166    , 1.30e-23,   1, 0.0030), //18
      KFEfficiencyParticleInfo("K*-_K-,pi0",       "K*-_K-pi0     ",    -100323, 0.6f, 2.6f, 0.89166    , 1.30e-23,  -1, 0.0030), //19
      KFEfficiencyParticleInfo("Sigma*+",          "Sigma*+       ",       3224, 1.0f, 3.0f, 1.3828     , 1.83e-23,   1, 0.0100), //20
      KFEfficiencyParticleInfo("Sigma*-",          "Sigma*-       ",       3114, 1.0f, 3.0f, 1.3872     , 1.67e-23,  -1, 0.0100), //21
      KFEfficiencyParticleInfo("Sigma*+b",         "Sigma*+ b     ",      -3114, 1.0f, 3.0f, 1.3828     , 1.83e-23,  -1, 0.0100), //22
      KFEfficiencyParticleInfo("Sigma*-b",         "Sigma*- b     ",      -3224, 1.0f, 3.0f, 1.3872     , 1.67e-23,   1, 0.0100), //23
      KFEfficiencyParticleInfo("Sigma*0",          "Sigma*0       ",       3214, 1.0f, 3.0f, 1.3837     , 1.83e-23,   0, 0.0030), //24
      KFEfficiencyParticleInfo("Sigma*0b",         "Sigma*0 b     ",      -3214, 1.0f, 3.0f, 1.3837     , 1.83e-23,   0, 0.0030), //25
      KFEfficiencyParticleInfo("Lambda*",          "Lambda*       ",       3124, 1.4f, 3.4f, 1.5195     , 4.22e-23,   0, 0.0100), //26
      KFEfficiencyParticleInfo("Lambda*b",         "Lambda* b     ",      -3124, 1.4f, 3.4f, 1.5195     , 4.22e-23,   0, 0.0100), //27
      KFEfficiencyParticleInfo("Xi*0",             "Xi*0          ",       3324, 1.4f, 3.4f, 1.53180    , 7.23e-23,   0, 0.0100), //28
      KFEfficiencyParticleInfo("Xi*0b",            "Xi*0 b        ",      -3324, 1.4f, 3.4f, 1.53180    , 7.23e-23,   0, 0.0100), //29
      KFEfficiencyParticleInfo("Xi*-_LK",          "Xi*-_lk       ",    1003314, 1.4f, 3.4f, 1.823      , 2.74e-23,  -1, 0.0030), //30
      KFEfficiencyParticleInfo("Xi*+_LK",          "Xi*+_lk       ",   -1003314, 1.4f, 3.4f, 1.823      , 2.74e-23,   1, 0.0030), //31
      KFEfficiencyParticleInfo("Xi*-_xi-,pi0",     "Xi*-_XiPi     ",       3314, 1.4f, 3.4f, 1.535      , 6.65e-23,  -1, 0.0030), //32
      KFEfficiencyParticleInfo("Xi*+_xi+,pi0",     "Xi*+_XiPi     ",      -3314, 1.4f, 3.4f, 1.535      , 6.65e-23,   1, 0.0030), //33
      KFEfficiencyParticleInfo("Omega*-",          "Omega*-       ",    1003334, 1.8f, 3.8f, 2.252      , 1.2e-23,   -1, 0.0030), //34
      KFEfficiencyParticleInfo("Omega*+",          "Omega*+       ",   -1003334, 1.8f, 3.8f, 2.252      , 1.2e-23,    1, 0.0030), //35
      KFEfficiencyParticleInfo("H0_LL",            "H0_LL         ",       3000, 1.5f, 3.5f, 2.21       , 1.32e-10,   0, 0.0030), //36
      KFEfficiencyParticleInfo("phi_KK",           "phi_KK        ",        333, 0.8f, 2.8f, 1.019455   , 1.55e-22,   0, 0.0030), //37
      KFEfficiencyParticleInfo("rho_pipi",         "rho_pipi      ",        113, 0.0f, 2.0f, 0.77526    , 4.45e-24,   0, 0.0030), //38
      KFEfficiencyParticleInfo("rho_ee",           "rho_ee        ",     100113, 0.0f, 2.0f, 0.77526    , 4.45e-24,   0, 0.0030), //39
      KFEfficiencyParticleInfo("rho_mm",           "rho_mm        ",     200113, 0.0f, 2.0f, 0.77526    , 4.45e-24,   0, 0.0030), //40
      KFEfficiencyParticleInfo("gamma",            "gamma         ",         22, 0.0f, 3.0f, 0.         , 1.e20,      0, 0.0030), //41
      KFEfficiencyParticleInfo("pi0",              "pi0           ",        111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //42
      KFEfficiencyParticleInfo("eta",              "eta           ",        221, 0.0f, 3.0f, 0.547862   , 5.0e-19,    0, 0.0030), //43
//Delta and N resonances
      KFEfficiencyParticleInfo("Delta0",           "Delta0        ",       2114, 1.0f, 3.0f, 1.232      , 5.63e-24,   0, 0.0030), //44
      KFEfficiencyParticleInfo("Delta0 b",         "Delta0 b      ",      -2114, 1.0f, 3.0f, 1.232      , 5.63e-24,   0, 0.0030), //45
      KFEfficiencyParticleInfo("Delta++",          "Delta++       ",       2224, 1.0f, 3.0f, 1.232      , 5.63e-24,   2, 0.0030), //46
      KFEfficiencyParticleInfo("Delta-- b",        "Delta-- b     ",      -2224, 1.0f, 3.0f, 1.232      , 5.63e-24,  -2, 0.0030), //47
//charmonium
      KFEfficiencyParticleInfo("JPsi_ee",          "JPsi_ee       ",        443, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //48
      KFEfficiencyParticleInfo("JPsi_mumu",        "JPsi_mm       ",     100443, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //49
      KFEfficiencyParticleInfo("JPsi_pp",          "JPsi_pp       ",     200443, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //50
      KFEfficiencyParticleInfo("JPsi_LL",          "JPsi_LL       ",     300443, 2.0f, 5.0f, 3.096916   , 7.1e-21,    0, 0.0030), //51
      KFEfficiencyParticleInfo("JPsi_XiXi",        "JPsi_XiXi     ",     400443, 2.0f, 5.0f, 3.096916   , 7.1e-21,    0, 0.0030), //52
      KFEfficiencyParticleInfo("Psi_OO",           "Psi_OO        ",     500443, 3.0f, 6.0f, 3.686109   , 2.1e-22,    0, 0.0030), //53
//open charm
      KFEfficiencyParticleInfo("D0",               "D0            ",        421, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //54
      KFEfficiencyParticleInfo("D0b",              "D0b           ",       -421, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //55
      KFEfficiencyParticleInfo("D0_4",             "D0_4          ",        429, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0100), //56
      KFEfficiencyParticleInfo("D0b_4",            "D0b_4         ",       -429, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0100), //57
      KFEfficiencyParticleInfo("D0_pipi",          "D0_pipi       ",        420, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //58
      KFEfficiencyParticleInfo("D0_2pi2pi",        "D0_2pi2pi     ",        470, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //59
      KFEfficiencyParticleInfo("D0_K0pipi",        "D0_K0pipi     ",        425, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0150), //60
      KFEfficiencyParticleInfo("D0_KK",            "D0_KK         ",        426, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0130), //61
      KFEfficiencyParticleInfo("D0_KKK0",          "D0_KKK0       ",        427, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //62
      KFEfficiencyParticleInfo("D0_pi0",           "D0_#pi0       ",        428, 1.0f, 3.0f, 1.86486    , 4.1e-13,    0, 0.0030), //63
      KFEfficiencyParticleInfo("D+",               "D+            ",        411, 1.0f, 3.0f, 1.86962    , 1.04e-13,   1, 0.0114), //64
      KFEfficiencyParticleInfo("D-",               "D-            ",       -411, 1.0f, 3.0f, 1.86962    , 1.04e-13,  -1, 0.0114), //65
      KFEfficiencyParticleInfo("D+_K0pi+",         "D+_K0pi+      ",     100411, 0.6f, 4.6f, 1.86962    , 1.04e-13,   1, 0.0030), //66
      KFEfficiencyParticleInfo("D-_K0pi-",         "D-_K0pi-      ",    -100411, 0.6f, 4.6f, 1.86962    , 1.04e-13,  -1, 0.0030), //67
      KFEfficiencyParticleInfo("D+_K03pi",         "D+_K03pi      ",     200411, 0.6f, 4.6f, 1.86962    , 1.04e-13,   1, 0.0030), //68
      KFEfficiencyParticleInfo("D-_K03pi",         "D-_K03pi      ",    -200411, 0.6f, 4.6f, 1.86962    , 1.04e-13,  -1, 0.0030), //69
      KFEfficiencyParticleInfo("D+_3pi",           "D+_3pi        ",     300411, 0.6f, 4.6f, 1.86962    , 1.04e-13,   1, 0.0030), //70
      KFEfficiencyParticleInfo("D-_3pi",           "D-_3pi        ",    -300411, 0.6f, 4.6f, 1.86962    , 1.04e-13,  -1, 0.0030), //71
      KFEfficiencyParticleInfo("Ds+",              "Ds+           ",        431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0110), //72
      KFEfficiencyParticleInfo("Ds-",              "Ds-           ",       -431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0110), //73
      KFEfficiencyParticleInfo("Ds+_K0K+",         "Ds+_K0K+      ",     100431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0030), //74
      KFEfficiencyParticleInfo("Ds-_K0K-",         "Ds-_K0K-      ",    -100431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0030), //75
      KFEfficiencyParticleInfo("Ds+_K0K0pi+",      "Ds+_K0K0pi+   ",     200431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0030), //76
      KFEfficiencyParticleInfo("Ds-_K0K0pi-",      "Ds-_K0K0pi-   ",    -200431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0030), //77
      KFEfficiencyParticleInfo("Ds+_K0K+pipi",     "Ds+_K0K+pipi  ",     300431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0030), //78
      KFEfficiencyParticleInfo("Ds-_K0K-pipi",     "Ds-_K0K-pipi  ",    -300431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0030), //79
      KFEfficiencyParticleInfo("Ds+_K+pipi",       "Ds+_K+pipi    ",     400431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0030), //80
      KFEfficiencyParticleInfo("Ds-_K-pipi",       "Ds-_K-pipi    ",    -400431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0030), //81
      KFEfficiencyParticleInfo("Lc",               "Lambdac       ",       4122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0110), //82
      KFEfficiencyParticleInfo("Lcb",              "Lambdac b     ",      -4122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0110), //83
      KFEfficiencyParticleInfo("Lc_{pK0}",         "Lc   {pK0}    ",     104122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //84
      KFEfficiencyParticleInfo("Lcb_{pK0}",        "Lc b {pK0}    ",    -104122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //85
      KFEfficiencyParticleInfo("Lc_{pK02pi}",      "Lc   {pK02pi} ",     204122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //86
      KFEfficiencyParticleInfo("Lcb_{pK02pi}",     "Lc b {pK02pi} ",    -204122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //87
      KFEfficiencyParticleInfo("Lc_{Lpi}",         "Lc   {Lpi}    ",     304122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //88
      KFEfficiencyParticleInfo("Lcb_{Lpi}",        "Lc b {Lpi}    ",    -304122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //89
      KFEfficiencyParticleInfo("Lc_{L3pi}",        "Lc   {L3pi}   ",     404122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //90
      KFEfficiencyParticleInfo("Lcb_{L3pi}",       "Lc b {L3pi}   ",    -404122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //91
      KFEfficiencyParticleInfo("Lc_{p2pi}",        "Lc   {p2pi}   ",     504122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //92
      KFEfficiencyParticleInfo("Lcb_{p2pi}",       "Lc b {p2pi}   ",    -504122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //93  
      KFEfficiencyParticleInfo("Xic0",             "Xic0          ",       4132, 2.1f, 4.1f, 2.47087    , 1.0e-13,    0, 0.0030), //94
      KFEfficiencyParticleInfo("Xic0b",            "Xic0b         ",      -4132, 2.1f, 4.1f, 2.47087    , 1.0e-13,    0, 0.0030), //95  
      KFEfficiencyParticleInfo("D*0",              "D*0           ",      10421, 1.8f, 3.8f, 2.00699    , 3.0e-22,    0, 0.0030), //96
      KFEfficiencyParticleInfo("D*0b",             "D*0 b         ",     -10421, 1.8f, 3.8f, 2.00699    , 3.0e-22,    0, 0.0030), //97
      KFEfficiencyParticleInfo("D*+",              "D*+           ",      10411, 1.8f, 3.8f, 2.01029    , 6.86e-21,   1, 0.0030), //98
      KFEfficiencyParticleInfo("D*-",              "D*-           ",     -10411, 1.8f, 3.8f, 2.01029    , 6.86e-21,  -1, 0.0030), //99
      KFEfficiencyParticleInfo("D*+_4",            "D*+_4         ",      20411, 1.8f, 3.8f, 2.01029    , 6.86e-21,   1, 0.0030), //100
      KFEfficiencyParticleInfo("D*-_4",            "D*-_4         ",     -20411, 1.8f, 3.8f, 2.01029    , 6.86e-21,  -1, 0.0030), //101
      KFEfficiencyParticleInfo("D0*_pi0",          "D0*_#pi0      ",      10428, 1.8f, 3.8f, 2.00699    , 6.86e-21,   0, 0.0030), //102
//B mesons
      KFEfficiencyParticleInfo("B_Jpsi_ee",        "B_Jpsi_ee     ",        500, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //103
      KFEfficiencyParticleInfo("B_Jpsi_mm",        "B_Jpsi_mm     ",        501, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //104
      KFEfficiencyParticleInfo("B+_D0bPi+",        "B+ {D0bPi+}   ",        521, 3.0f, 7.0f, 5.27931    , 1.638e-12,  0, 0.0030), //105
      KFEfficiencyParticleInfo("B-_D0Pi-",         "B- {D0Pi-}    ",       -521, 3.0f, 7.0f, 5.27931    , 1.638e-12,  0, 0.0030), //106
      KFEfficiencyParticleInfo("B+_D0bK+",         "B+ {D0bK+}    ",        529, 3.0f, 7.0f, 5.27931    , 1.638e-12,  0, 0.0030), //107
      KFEfficiencyParticleInfo("B-_D0K-",          "B- {D0K+}     ",       -529, 3.0f, 7.0f, 5.27931    , 1.638e-12,  0, 0.0030), //108
      KFEfficiencyParticleInfo("B0_D-Pi+",         "B0 {D-Pi+}    ",        511, 3.0f, 7.0f, 5.27962    , 1.520e-12,  0, 0.0030), //109
      KFEfficiencyParticleInfo("B0b_D+Pi-",        "B0b {D+Pi-}   ",       -511, 3.0f, 7.0f, 5.27962    , 1.520e-12,  0, 0.0030), //110
      KFEfficiencyParticleInfo("B0_D-K+",          "B0 {D-K+}     ",        519, 3.0f, 7.0f, 5.27962    , 1.520e-12,  0, 0.0030), //111
      KFEfficiencyParticleInfo("B0b_D+K-",         "B0b {D+K-}    ",       -519, 3.0f, 7.0f, 5.27962    , 1.520e-12,  0, 0.0030), //112
      KFEfficiencyParticleInfo("H0_{Lppi}",        "H0            ",       3001, 2.0f, 4.0f, 2.21       , 1.32e-10,   0, 0.0030), //113
//hypernuclei
      KFEfficiencyParticleInfo("LambdaN",          "LambdaN       ",       3003, 1.0f, 3.0f, 2.05395    , 1.00e-10,   0, 0.0030), //114
      KFEfficiencyParticleInfo("LambdaNb",         "LambdaN b     ",      -3003, 1.0f, 3.0f, 2.05395    , 1.00e-10,   0, 0.0030), //115
      KFEfficiencyParticleInfo("LambdaNN",         "LambdaNN      ",       3103, 2.0f, 4.0f, 2.99352    , 1.00e-10,   0, 0.0030), //116
      KFEfficiencyParticleInfo("LambdaNNb",        "LambdaNN b    ",      -3103, 2.0f, 4.0f, 2.99352    , 1.00e-10,   0, 0.0030), //117
      KFEfficiencyParticleInfo("H3L",              "H3L           ",       3004, 2.0f, 4.0f, 2.99339    , 1.85e-10,   1, 0.0030), //118
      KFEfficiencyParticleInfo("H3Lb",             "H3L b         ",      -3004, 2.0f, 4.0f, 2.99339    , 1.85e-10,  -1, 0.0030), //119
      KFEfficiencyParticleInfo("H4L",              "H4L           ",       3005, 3.0f, 5.0f, 3.92975    , 1.80e-10,   1, 0.0030), //120
      KFEfficiencyParticleInfo("H4Lb",             "H4L b         ",      -3005, 3.0f, 5.0f, 3.92975    , 1.80e-10,  -1, 0.0030), //121
      KFEfficiencyParticleInfo("He4L",             "He4L          ",       3006, 3.0f, 5.0f, 3.93070    , 1.50e-10,   2, 0.0030), //122
      KFEfficiencyParticleInfo("He4Lb",            "He4L b        ",      -3006, 3.0f, 5.0f, 3.93070    , 1.50e-10,  -2, 0.0030), //123
      KFEfficiencyParticleInfo("He5L",             "He5L          ",       3007, 4.0f, 6.0f, 4.86824    , 1.40e-10,   2, 0.0030), //124
      KFEfficiencyParticleInfo("He5Lb",            "He5L b        ",      -3007, 4.0f, 6.0f, 4.86824    , 1.40e-10,  -2, 0.0030), //125
      KFEfficiencyParticleInfo("LLn",              "LLn           ",       3203, 3.0f, 5.0f, 3.16964    , 1.00e-10,   0, 0.0030), //126
      KFEfficiencyParticleInfo("H4LL_{He4Lpi-}",   "H4LL_{He4Lpi-}",       3008, 3.0f, 5.0f, 4.10791    ,  1.0e-10,   1, 0.0030), //127
      KFEfficiencyParticleInfo("H4LL_{H3Lppi-}",   "H4LL_{H3Lppi-}",       3009, 3.0f, 5.0f, 4.10791    ,  1.0e-10,   1, 0.0030), //128
      KFEfficiencyParticleInfo("H5LL_{He5Lpi-}",   "H5LL_{He5Lpi-}",       3010, 4.0f, 6.0f, 5.04748    ,  1.0e-10,   1, 0.0030), //129
      KFEfficiencyParticleInfo("He6LL",            "He6LL         ",       3011, 5.0f, 7.0f, 5.98575    ,  1.0e-10,   2, 0.0030), //130
//missing mass method      
      KFEfficiencyParticleInfo("pi-_{mu,nu}",      "pi-_{mnu}     ",   -7000211,-1.0f, 1.0f, 0.139570   , 2.6e-8,    -1, 0.0030), //131
      KFEfficiencyParticleInfo("nu_{pi-}",         "nu_{mupi-} b  ",   -7000014,-1.0f, 1.0f, 0.         , 1.0e20,     0, 0.0030), //132
      KFEfficiencyParticleInfo("pi+_{mu,nu}",      "pi+_{mnu}     ",    7000211,-1.0f, 1.0f, 0.139570   , 2.6e-8,     1, 0.0030), //133
      KFEfficiencyParticleInfo("nu_{pi+}",         "nu_{mupi+}    ",    7000014,-1.0f, 1.0f, 0.         , 1.0e20,     0, 0.0030), //134
      KFEfficiencyParticleInfo("K-_{mu,nu}",       "K-_{mnu}      ",   -7000321,-1.0f, 1.0f, 0.493677   , 1.238e-8,  -1, 0.0030), //135
      KFEfficiencyParticleInfo("nu_{K-}",          "nu_{K-} b     ",   -8000014,-1.0f, 1.0f, 0.         , 1.0e20,     0, 0.0030), //136
      KFEfficiencyParticleInfo("K+_{mu,nu}",       "K+_{mnu}      ",    7000321,-1.0f, 1.0f, 0.493677   , 1.238e-8,   1, 0.0030), //137
      KFEfficiencyParticleInfo("nu_{K+}",          "nu_{K+}       ",    8000014,-1.0f, 1.0f, 0.         , 1.0e20,     0, 0.0030), //138
      KFEfficiencyParticleInfo("Sigma-_{pi-,n}",   "Sigma-_{pi-n} ",    7003112, 0.0f, 3.0f, 1.192642   , 1.479e-10, -1, 0.0100), //139
      KFEfficiencyParticleInfo("n_{Sigma-}",       "n_{Sigma-}    ",    7002112, 0.0f, 1.5f, 0.9395654  , 880,        0, 0.0030), //140
      KFEfficiencyParticleInfo("Sigma+_{pi+n}b",   "Sigma+{pi+n} b",   -7003112, 0.0f, 3.0f, 1.192642   , 1.479e-10, -1, 0.0030), //141
      KFEfficiencyParticleInfo("n_{Sigma+} b",     "n_{Sigma+b} b ",   -7002112, 0.0f, 1.5f, 0.9395654  , 880,        0, 0.0030), //142
      KFEfficiencyParticleInfo("Sigma-_{pi-n}b",   "Sigma+{pi-n} b",   -7003222, 0.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0030), //143
      KFEfficiencyParticleInfo("n_{Sigma-} b",     "n_{Sigma-_b} b",   -8002112, 0.0f, 1.5f, 0.9395654  , 0.93956541, 0, 0.0030), //144
      KFEfficiencyParticleInfo("Sigma+_{pi+n}",    "Sigma+_{pi+n} ",    7003222, 0.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0100), //145
      KFEfficiencyParticleInfo("n_{Sigma+}",       "n_{Sigma+}    ",    8002112, 0.0f, 1.5f, 0.9395654  , 880,        0, 0.0030), //146
      KFEfficiencyParticleInfo("Xi-_{pi-L}",       "Xi-_{pi-L}    ",    7003312, 0.0f, 3.0f, 1.32171    , 1.639e-10, -1, 0.0030), //147
      KFEfficiencyParticleInfo("Lambda_{Xi-}",     "Lambda_{Xi-}  ",    7003122, 0.0f, 2.0f, 1.115683   , 2.632e-10,  0, 0.0030), //148
      KFEfficiencyParticleInfo("Xi+_{pi+L_b}",     "Xi+_{pi+L_b}  ",   -7003312, 0.0f, 3.0f, 1.32171    , 1.639e-10,  1, 0.0030), //149
      KFEfficiencyParticleInfo("Lambda_{Xi+} b",   "Lambda_{Xi+} b",   -7003122, 0.0f, 2.0f, 1.115683   , 2.632e-10,  0, 0.0030), //150
      KFEfficiencyParticleInfo("Omega-_{Xi-pi0}",  "Omega-{pi-Xi0}",    7003334, 0.0f, 3.0f, 1.67245    , 0.821e-10, -1, 0.0030), //151
      KFEfficiencyParticleInfo("Xi0_{Omega-}",     "Xi0_{Omega-}  ",    7003322, 0.0f, 3.0f, 1.31486    , 2.9e-10,    0, 0.0030), //152
      KFEfficiencyParticleInfo("Omega+_{Xi+pi0}",  "Omega+_{Xipi0}",   -7003334, 0.0f, 3.0f, 1.67245    , 0.821e-10,  1, 0.0030), //153
      KFEfficiencyParticleInfo("Xi0_{Omega+} b",   "Xi0_{Omega+} b",   -7003322, 0.0f, 3.0f, 1.31486    , 2.9e-10,    0, 0.0030), //154
      KFEfficiencyParticleInfo("K-_{pi-pi0}",      "K-_{pi-pi0}   ",   -9000321, 0.0f, 3.0f, 0.493677   , 1.24e-8,   -1, 0.0030), //155
      KFEfficiencyParticleInfo("pi0_{K-}",         "pi0_{K-}      ",   -9000111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //156
      KFEfficiencyParticleInfo("K+_{pi+pi0}",      "K+_{pi+pi0}   ",    9000321, 0.0f, 3.0f, 0.493677   , 1.24e-8,    1, 0.0030), //157
      KFEfficiencyParticleInfo("pi0_{K+}",         "pi0_{K+}      ",    9000111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //158
      KFEfficiencyParticleInfo("Omega-{K-L}",      "Omega-_{K-L}  ",    8003334, 0.0f, 3.0f, 1.67245    , 0.821e-10, -1, 0.0030), //159
      KFEfficiencyParticleInfo("Lambda_{Omega-}",  "Lambda_{O-}   ",    8003122, 0.0f, 3.0f, 1.115683   , 2.632e-10,  0, 0.0030), //160
      KFEfficiencyParticleInfo("Omega+_{K+L_b}",   "Omega+_{K+Lb} ",   -8003334, 0.0f, 3.0f, 1.67245    , 0.821e-10,  1, 0.0030), //161
      KFEfficiencyParticleInfo("Lamda_{Omega+} b", "Lambda_{O+} b ",   -8003122, 0.0f, 3.0f, 1.115683   , 2.632e-10,  0, 0.0030), //162
      KFEfficiencyParticleInfo("Sigma-{p_b pi0} b","Sigma-{ppi0} b",   -8003222, 0.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0030), //163
      KFEfficiencyParticleInfo("pi0_{Sigma-b}",    "pi0_{Sigma-_b}",   -8000111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //164
      KFEfficiencyParticleInfo("Sigma+_{p pi0}",   "Sigma+_{ppi0} ",    8003222, 0.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0250), //165
      KFEfficiencyParticleInfo("pi0_{Sigma+}",     "pi0_{Sigma+}  ",    8000111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //166
//tracks
      KFEfficiencyParticleInfo("e-",               "e-            ",         11, 0.0f,0.01f, 5.485799e-4, 1.0e20,    -1, 0.0030), //167
      KFEfficiencyParticleInfo("e+",               "e+            ",        -11, 0.0f,0.01f, 5.485799e-4, 1.0e20,     1, 0.0030), //168
      KFEfficiencyParticleInfo("mu-",              "mu-           ",         13, 0.0f, 1.0f, 0.105658   , 2.2e-6,    -1, 0.0030), //169
      KFEfficiencyParticleInfo("mu+",              "mu+           ",        -13, 0.0f, 1.0f, 0.105658   , 2.2e-6,     1, 0.0030), //170
      KFEfficiencyParticleInfo("pi+",              "pi+           ",        211, 0.0f, 1.0f, 0.139570   , 2.6e-8,     1, 0.0030), //171
      KFEfficiencyParticleInfo("pi-",              "pi-           ",       -211, 0.0f, 1.0f, 0.139570   , 2.6e-8,    -1, 0.0030), //172
      KFEfficiencyParticleInfo("K+",               "K+            ",        321, 0.0f, 1.0f, 0.493677   , 1.238e-8,   1, 0.0030), //173
      KFEfficiencyParticleInfo("K-",               "K-            ",       -321, 0.0f, 1.0f, 0.493677   , 1.238e-8,  -1, 0.0030), //174
      KFEfficiencyParticleInfo("p+",               "p+            ",       2212, 0.0f, 1.5f, 0.938272   , 1.0e20,     1, 0.0030), //175
      KFEfficiencyParticleInfo("p-",               "p-            ",      -2212, 0.0f, 1.5f, 0.938272   , 1.0e20,    -1, 0.0030), //176
      KFEfficiencyParticleInfo("d+",               "d+            ", 1000010020, 0.0f, 2.5f, 1.876124   , 1.0e20,     1, 0.0030), //177
      KFEfficiencyParticleInfo("d-",               "d-            ",-1000010020, 0.0f, 2.5f, 1.876124   , 1.0e20,    -1, 0.0030), //178
      KFEfficiencyParticleInfo("t+",               "t+            ", 1000010030, 0.0f, 3.5f, 2.809432   , 1.0e20,     1, 0.0030), //179
      KFEfficiencyParticleInfo("t-",               "t-            ",-1000010030, 0.0f, 3.5f, 2.809432   , 1.0e20,    -1, 0.0030), //180
      KFEfficiencyParticleInfo("He3+",             "He3+          ", 1000020030, 0.0f, 3.5f, 2.809413   , 1.0e20,     2, 0.0030), //181
      KFEfficiencyParticleInfo("He3-",             "He3-          ",-1000020030, 0.0f, 3.5f, 2.809413   , 1.0e20,    -2, 0.0030), //182
      KFEfficiencyParticleInfo("He4+",             "He4+          ", 1000020040, 0.0f, 4.5f, 3.728400   , 1.0e20,     2, 0.0030), //183
      KFEfficiencyParticleInfo("He4-",             "He4-          ",-1000020040, 0.0f, 4.5f, 3.728400   , 1.0e20,    -2, 0.0030), //184
//background for subtraction
      KFEfficiencyParticleInfo("pi+pi+",           "pi+pi+        ",       9001, 0.0f, 2.0f, 0          , 1.0e20,     0, 0.0030), //185
      KFEfficiencyParticleInfo("pi+K+",            "pi+K+         ",       9002, 0.6f, 5.6f, 0          , 1.0e20,     0, 0.0030), //186
      KFEfficiencyParticleInfo("K+K+",             "K+K+          ",       9003, 0.8f, 3.8f, 0          , 1.0e20,     0, 0.0030), //187
      KFEfficiencyParticleInfo("K+p+",             "K+p+          ",       9004, 1.4f, 5.4f, 0          , 1.0e20,     0, 0.0030), //188
      KFEfficiencyParticleInfo("pi-pi-",           "pi-pi-        ",      -9001, 0.0f, 2.0f, 0          , 1.0e20,     0, 0.0030), //189
      KFEfficiencyParticleInfo("pi-K-",            "pi-K-         ",      -9002, 0.6f, 5.6f, 0          , 1.0e20,     0, 0.0030), //190
      KFEfficiencyParticleInfo("K-K-",             "K-K-          ",      -9003, 0.8f, 3.8f, 0          , 1.0e20,     0, 0.0030), //191
      KFEfficiencyParticleInfo("K-p-",             "K-p-          ",      -9004, 1.4f, 5.4f, 0          , 1.0e20,     0, 0.0030), //192
//V0
      KFEfficiencyParticleInfo("V0",               "V0            ",  123456789, 0.3f, 1.3f, 0          , 0,          0, 0.0030)  //193
    };
                                        
    int mPartMaxMult[nParticles];
    for(int i=0; i<nParticles; i++)
      mPartMaxMult[i] = 20;
    mPartMaxMult[fFirstStableParticleIndex + 4] = 500;
    mPartMaxMult[fFirstStableParticleIndex + 5] = 500;
    mPartMaxMult[fFirstStableParticleIndex + 6] = 50;
    mPartMaxMult[fFirstStableParticleIndex + 7] = 50;
    mPartMaxMult[fFirstStableParticleIndex + 8] = 500;
                                    
    //set decay mode
    partDaughterPdg.resize(nParticles);

    int curPart = 0;
    
    partDaughterPdg[curPart].push_back(  211); //K0s -> pi+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambda -> p pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-2212); //Lambda_bar -> p- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Xi- -> Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Xi+ -> Lambda_bar pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Xi0 -> Lambda Pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Xi0_bar -> Lambda_bar Pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Omega- -> Lambda K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Omega+ -> Lambda_bar K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   22); //Sigma0 -> Lambda Gamma
    partDaughterPdg[curPart].push_back( 3122);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   22); //Sigma0_bar -> Lambda_bar Gamma
    partDaughterPdg[curPart].push_back(-3122);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //Sigma+ -> p Pi0
    partDaughterPdg[curPart].push_back( 2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //Sigma+_bar -> p- Pi0
    partDaughterPdg[curPart].push_back(-2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //K*0 -> K+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -321); //K*0_bar -> K- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //K*+ -> K0s pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //K*- -> K0s pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //K*0 -> K0 pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //K*+ -> K+ pi0
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //K*- -> K- pi0
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Sigma+ -> Lambda pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Sigma- -> Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Sigma+_bar -> Lambda_bar pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Sigma-_bar -> Lambda_bar pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Sigma*0 -> Lambda pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Sigma*0_bar -> Lambda_bar pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambda* -> p K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-2212); //Lambda*_bar -> p- K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3312); //Xi*0 -> Xi- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3312); //Xi*0_bar -> Xi+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Xi*- -> Lambda K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Xi*+ -> Lambda_bar K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3312); //Xi*- -> Xi- pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3312); //Xi*+ -> Xi+ pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3312); //Omega*- -> Xi- pi+ K-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3312); //Omega*- -> Xi+ pi- K+
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //H-dibar -> Lambda Lambda
    partDaughterPdg[curPart].push_back( 3122);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //phi -> K+ K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //rho, omega, phi -> pi+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   11); //rho, omega, phi -> e+ e-
    partDaughterPdg[curPart].push_back(  -11);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   13); //rho, omega, phi -> mu+ mu-
    partDaughterPdg[curPart].push_back(  -13);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   11); //gamma -> e+ e-
    partDaughterPdg[curPart].push_back(  -11);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   22); //pi0 -> gamma gamma
    partDaughterPdg[curPart].push_back(   22);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //eta -> pi0 pi0
    partDaughterPdg[curPart].push_back(  111);
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Delta0 -> p pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Delta0_bar -> p- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back( 2212); //Delta++ -> p pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Delta--_bar -> p- pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   11); //JPsi -> e+ e-
    partDaughterPdg[curPart].push_back(  -11);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   13); //JPsi -> mu+ mu-
    partDaughterPdg[curPart].push_back(  -13);
    curPart++;

    partDaughterPdg[curPart].push_back(   2212); //JPsi -> p p-
    partDaughterPdg[curPart].push_back(  -2212);
    curPart++;

    partDaughterPdg[curPart].push_back(   3122); //JPsi -> Lambda Lambda_bar
    partDaughterPdg[curPart].push_back(  -3122);
    curPart++;

    partDaughterPdg[curPart].push_back(   3312); //JPsi -> Xi- Xi+
    partDaughterPdg[curPart].push_back(  -3312);
    curPart++;

    partDaughterPdg[curPart].push_back(   3334); //Psi -> Omega- Omega+
    partDaughterPdg[curPart].push_back(  -3334);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //D0 -> pi+ K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -211); //D0_bar -> K+ pi-
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //D0 -> pi+ pi+ pi- K-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -211); //D0_bar -> pi- pi- pi+ K+
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  321);
    curPart++;

    partDaughterPdg[curPart].push_back(  211); //D0 -> pi+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(  211); //D0 -> 2pi+ 2pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D0_bar -> K0 pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //D0_bar -> K+ K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;

    partDaughterPdg[curPart].push_back(  321); //D0_bar -> K+ K- K0
    partDaughterPdg[curPart].push_back( -321);
    partDaughterPdg[curPart].push_back(  310);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D0_bar -> K0 pi+ pi- pi0
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -321); //D+ -> K- pi+ pi+
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //D- -> K+ pi- pi-
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D+ -> K0 pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D- -> K0 pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D+ -> K0 pi+ pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D- -> K0 pi+ pi- pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //D+ -> pi+ pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //D- -> pi+ pi- pi-
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -321); //Ds+ -> K- K+ pi+
    partDaughterPdg[curPart].push_back(  321);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //Ds- -> K+ K- pi-
    partDaughterPdg[curPart].push_back( -321);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //Ds+ -> K0 K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //Ds- -> K0 K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //Ds+ -> K0 K0 pi+
    partDaughterPdg[curPart].push_back(  310);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back(  310); //Ds- -> K0 K0 pi-
    partDaughterPdg[curPart].push_back(  310);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //Ds+ -> K0 K+ pi+ pi-
    partDaughterPdg[curPart].push_back(  321);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(  310); //Ds- -> K0 K- pi+ pi-
    partDaughterPdg[curPart].push_back( -321);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //Ds+ -> K+ pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back( -321); //Ds- -> K- pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    
    partDaughterPdg[curPart].push_back(  211); //Lambdac -> pi+ K- p
    partDaughterPdg[curPart].push_back( -321);
    partDaughterPdg[curPart].push_back( 2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -211); //Lambdac_bar -> pi- K+ p-
    partDaughterPdg[curPart].push_back(  321);
    partDaughterPdg[curPart].push_back(-2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambdac -> p K0s
    partDaughterPdg[curPart].push_back(  310);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Lambdac_bar -> p_bar K0s
    partDaughterPdg[curPart].push_back(  310);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambdac -> p K0s pi+ pi-
    partDaughterPdg[curPart].push_back(  310);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Lambdac_bar -> p_bar K0s pi+ pi-
    partDaughterPdg[curPart].push_back(  310);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Lambdac -> Lambda pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back(-3122); //Lambdac_bar -> Lambda_bar pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Lambdac -> Lambda 2pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-3122); //Lambdac_bar -> Lambda_bar 2pi- pi+
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;  
    
    partDaughterPdg[curPart].push_back( 3312); //Xic0 -> Xi- 2pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3312); //Xic0_bar -> Xi+ 2pi- pi+
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambdac -> p pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Lambdac_bar -> p_bar pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    
    partDaughterPdg[curPart].push_back(  411); //D*0 -> D+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -411); //D*0_bar -> D- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  421); //D*+ -> D0 pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -421); //D*- -> D0_bar pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  429); //D*+ -> D04 pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -429); //D*- -> D04_bar pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(  428); //D*0 -> D04 pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   11); //B -> e+ e-
    partDaughterPdg[curPart].push_back(  -11);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   13); //B -> mu+ mu-
    partDaughterPdg[curPart].push_back(  -13);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -421); //B+ -> D0_bar pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  421); //B- -> D0 pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -421); //B+ -> D0_bar K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  421); //B- -> D0 K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;

    partDaughterPdg[curPart].push_back( -411); //B0 -> D- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  411); //B0_bar -> D+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -411); //B0 -> D0_bar K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  411); //B0_bar -> D0 K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;

    partDaughterPdg[curPart].push_back( 3122); //H0-> Lambda pi- p
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( 2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 1000010020); //LambdaN -> d+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000010020); //LambdaN_bar-> d- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back( 1000010030); //LambdaNN -> t+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000010030); //LambdaNN_bar -> t- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 1000020030); //H3Lambda -> He3+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000020030); //H3Lambda_bar -> He3- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back( 1000020040); //H4Lambda -> He4+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000020040); //H4Lambda_bar -> He4- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 1000020030); //He4Lambda -> He3+ p+ pi-
    partDaughterPdg[curPart].push_back( 2212);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000020030); //He4Lambda_bar -> He3- p- pi+
    partDaughterPdg[curPart].push_back(-2212);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 1000020040); //He5Lambda -> He4+ p+ pi-
    partDaughterPdg[curPart].push_back( 2212);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000020040); //He5Lambda_bar -> He4- p- pi+
    partDaughterPdg[curPart].push_back(-2212);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3004); //LLn -> H3Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3006); //H4LL -> He4Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back( 3004); //H4LL -> H3Lambda p pi-
    partDaughterPdg[curPart].push_back( 2212);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back( 3007); //H5LL -> He5Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3007); //He6LL -> He5Lambda p pi-
    partDaughterPdg[curPart].push_back( 2212);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(      13); // pi- -> mu- + nu_mu_bar
    partDaughterPdg[curPart].push_back(-7000014); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(    -211); // nu_mu_bar <- pi- - mu-
    partDaughterPdg[curPart].push_back(      13); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -13); // pi+ -> mu+ + nu_mu
    partDaughterPdg[curPart].push_back( 7000014); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(    211); // nu_mu <- pi+ - mu+
    partDaughterPdg[curPart].push_back(    -13); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      13); // K- -> mu- + nu_mu_bar
    partDaughterPdg[curPart].push_back(-8000014); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(    -321); // nu_mu_bar <- K- - mu-
    partDaughterPdg[curPart].push_back(      13); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -13); // K+ -> mu+ + nu_mu
    partDaughterPdg[curPart].push_back( 8000014); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     321); // nu_mu <- K+ - mu+
    partDaughterPdg[curPart].push_back(     -13); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -211); // Sigma- -> pi- + n
    partDaughterPdg[curPart].push_back(  7002112); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     3112); // n <- Sigma- - pi-
    partDaughterPdg[curPart].push_back(     -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // Sigma-b -> pi+ + nb
    partDaughterPdg[curPart].push_back(  -7002112); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3112); // nb <- Sigma-b - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -211); // Sigma+b -> pi- + nb
    partDaughterPdg[curPart].push_back(  -8002112); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(    -3222); // nb <- Sigma+b - pi-
    partDaughterPdg[curPart].push_back(     -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // Sigma+ -> pi+ + n
    partDaughterPdg[curPart].push_back(   8002112); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3222); // n <- Sigma+ - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -211); // Xi- -> pi- + lam
    partDaughterPdg[curPart].push_back(   7003122); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3312); // lam <- Xi- - pi-
    partDaughterPdg[curPart].push_back(      -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // Xi-b -> pi+ + lam_b
    partDaughterPdg[curPart].push_back(  -7003122); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3312); // lam_b <- Xi-b - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -211); // Om- -> pi- + Xi0
    partDaughterPdg[curPart].push_back(   7003322); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3334); // Xi0 <- Om- - pi-
    partDaughterPdg[curPart].push_back(      -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // Om-b -> pi+ + Xi0_b
    partDaughterPdg[curPart].push_back(  -7003322); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3334); // Xi0_b <- Om-b - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -211); // K- -> pi- + Pi0_b
    partDaughterPdg[curPart].push_back(  -9000111); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -321); // Pi0_b <- K- - pi-
    partDaughterPdg[curPart].push_back(      -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // K+ -> pi+ + Pi0
    partDaughterPdg[curPart].push_back(   9000111); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       321); // Pi0 <- K+ - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -321); // Om- -> K- + Lam
    partDaughterPdg[curPart].push_back(   8003122); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3334); // Lam <- Om- - K-
    partDaughterPdg[curPart].push_back(      -321); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       321); // Om+ -> K+ + Lam_b
    partDaughterPdg[curPart].push_back(  -8003122); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3334); // Lam_b <- Om+ - K+
    partDaughterPdg[curPart].push_back(       321); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -2212); // Si+b -> p_b + Pi0
    partDaughterPdg[curPart].push_back(  -8000111); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3222); // Pi0 <- Si+b - p_b
    partDaughterPdg[curPart].push_back(     -2212); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      2212); // Si+ -> p + Pi0
    partDaughterPdg[curPart].push_back(   8000111); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3222); // Pi0 <- Si+ - p
    partDaughterPdg[curPart].push_back(      2212); //
    curPart++;
    
    for(int iP=0; iP<nParticles; iP++)
    {
      partPDG[iP] = particleInfo[iP].PDG();
      partName[iP] = particleInfo[iP].Name();
      partTitle[iP] = particleInfo[iP].Title();
      partMHistoMin[iP] = particleInfo[iP].HistoMin();
      partMHistoMax[iP] = particleInfo[iP].HistoMax();
      partMaxMult[iP] = mPartMaxMult[iP];
      partMass[iP] = particleInfo[iP].Mass();
      partLifeTime[iP] = particleInfo[iP].LifeTime();
      partCharge[iP] = particleInfo[iP].Charge();
      partMassSigma[iP] = particleInfo[iP].MassSigma();
    }

    for(int iP=0; iP<nParticles; iP++)
    {
      AddCounter(partName[iP],           partTitle[iP] + "     ");
      AddCounter(partName[iP] + "_prim", partTitle[iP] + " Prim");
      AddCounter(partName[iP] + "_sec",  partTitle[iP] + " Sec ");
    }

    for(int iP=0; iP<nParticles; iP++)
      fPdgToIndex[particleInfo[iP].PDG()] = iP;
  }

  virtual ~KFPartEfficiencies(){};

  /** \brief Returns index of the decay with a given PDG code in the scheme of the KF Particle Finder. If it is not present there - returns "-1". */
  int GetParticleIndex(int pdg)
  {
    std::map<int, int>::iterator it;
    it=fPdgToIndex.find(pdg);
    if(it != fPdgToIndex.end()) return it->second;
    else return -1;
  }

  /** \brief Returns the map between PDG codes and index of the decay in the scheme of the KF Particle Finder. */
  std::map<int,int> GetPdgToIndexMap() const { return fPdgToIndex; } 
  
  virtual void AddCounter(std::string shortname, std::string name)
  {
    /** Adds a counter with the name defined by "name" to all counter
     ** objects. For easiness of operation with counters, a shortname is assigned
     ** to each of them and the corresponding entry in the map indices is done.
     ** \param[in] shortname - a short name of the counter for fast and easy access to its index
     ** \param[in] name - name of the counter which is added to each counter object.
     **/
    indices[shortname] = names.size();
    names.push_back(name);

    ratio_reco1.AddCounter();
    ratio_reco2.AddCounter();
    ratio_reco3.AddCounter();

    mc1.AddCounter();
    mc2.AddCounter();
    mc3.AddCounter();
    
    reco.AddCounter();

    ratio_ghost.AddCounter();
    ratio_bg.AddCounter();
    ratio_clone.AddCounter();
    ghost.AddCounter();
    bg.AddCounter();
    clone.AddCounter();
  };

  /** \brief Operator to add efficiency table from object "a" to the current object. Returns the current object after addition. */
  KFPartEfficiencies& operator+=(KFPartEfficiencies& a){
    mc1 += a.mc1; mc2 += a.mc2; mc3 += a.mc3; reco += a.reco;
    ghost += a.ghost; bg += a.bg; clone += a.clone;
    return *this;
  };
  
  /** \brief Function to calculate efficiency after all counters are set. If the counters are modified the function should be called again. */
  void CalcEff(){
    ratio_reco1 = reco/mc1;
    ratio_reco2 = reco/mc2;
    ratio_reco3 = reco/mc3;

    KFMCCounter<int> allReco = reco + ghost + bg;
    ratio_ghost = ghost/allReco;
    ratio_bg  = bg/allReco;
    ratio_clone  = clone/allReco;
  };
  
  void Inc(bool isReco, int nClones, bool isMC1, bool isMC2, bool isMC3, std::string name)
  {
    /** Increases counters by one, if the corresponding boolean variable is "true".
     ** \param[in] isReco - "true" if particle is reconstructed
     ** \param[in] nClones - number of double reconstructed particles for the given MC particle,
     ** will be added to the "clone" counters
     ** \param[in] isMC1 - "true" if particle is reconstructable in 4pi, mc1 is increased
     ** \param[in] isMC2 - "true" if all daughters are reconstructable, mc2 is increased
     ** \param[in] isMC3 - "true" if all daughters are reconstructed, mc3 is increased
     ** \param[in] name  - "shortname" of the set of counters, which should be increased
     **/
    const int index = indices[name];
    
    if(isMC1) mc1.counters[index]++;
    if(isMC2) mc2.counters[index]++;
    if(isMC3) mc3.counters[index]++;
    
    if(isReco) reco.counters[index]++;
    if(nClones > 0)
      clone.counters[index] += nClones;
  };

  void IncReco(bool isGhost, bool isBg, std::string name)
  {
    /** Increases counters by one, if the corresponding boolean variable is "true".
     ** \param[in] isGhost - "true" if ghost is added
     ** \param[in] isBg - "true" if physics background is added
     ** \param[in] name  - "shortname" of the set of counters, which should be increased
     **/
    const int index = indices[name];

    if (isGhost) ghost.     counters[index]++;
    if (isBg)    bg.counters[index]++;
  };

  /** \brief Prints the efficiency table on the screen. */
  void PrintEff(){
    std::ios_base::fmtflags original_flags = std::cout.flags();
    std::cout.setf(std::ios::fixed);
    std::cout.setf(std::ios::showpoint);
    std::cout.precision(3);
    std::cout << "Particle             : "
         <<        "   Eff 4pi "
         <<" / "<< " Eff accept"
         <<" / "<< "  Eff KFPF "
         <<" / "<< "     Ghost "
         <<" / "<< "    BackGr "
         <<" / "<< "   N Ghost "
         <<" / "<< "  N BackGr "
         <<" / "<< "    N Reco "
         <<" / "<< "   N Clone "
         <<" | "<< "  N MC 4pi " 
         <<" | "<< "N MC accept" 
         <<" | "<< " N MC KFPF "  << std::endl;
    
    int NCounters = mc1.NCounters;
    for (int iC = 0; iC < NCounters; iC++){
        std::cout << names[iC]
             << "  : " << std::setw(10) << ratio_reco1.counters[iC]    
             << "  / " << std::setw(10) << ratio_reco2.counters[iC]
             << "  / " << std::setw(10) << ratio_reco3.counters[iC]
             << "  / " << std::setw(10) << ratio_ghost.counters[iC]  // particles w\o MCParticle
             << "  / " << std::setw(10) << ratio_bg.counters[iC]     // particles with incorrect MCParticle
             << "  / " << std::setw(10) << ghost.counters[iC]
             << "  / " << std::setw(10) << bg.counters[iC]
             << "  / " << std::setw(10) << reco.counters[iC]
             << "  / " << std::setw(10) << clone.counters[iC]
             << "  | " << std::setw(10) << mc1.counters[iC] 
             << "  | " << std::setw(10) << mc2.counters[iC]
             << "  | " << std::setw(10) << mc3.counters[iC]  << std::endl;
    }
    std::cout.flags(original_flags); 
  };
  
  float GetTotal4piEfficiency(int iDecay) { return ratio_reco1.counters[3*iDecay]; }  ///< Returns efficiency in 4pi for decay "iDecay".
  float GetTotalKFPEfficiency(int iDecay) { return ratio_reco3.counters[3*iDecay]; }  ///< Returns efficiency of KF Particle Finder method (cuts) for decay "iDecay".
  float GetPrimary4piEfficiency(int iDecay) { return ratio_reco1.counters[3*iDecay+1]; } ///< Returns efficiency in 4pi for decay "iDecay" for primary particles.
  float GetPrimaryKFPEfficiency(int iDecay) { return ratio_reco3.counters[3*iDecay+1]; } ///< Returns efficiency of KF Particle Finder method (cuts) for decay "iDecay" for primary particles.
  float GetSecondary4piEfficiency(int iDecay) { return ratio_reco1.counters[3*iDecay+2]; } ///< Returns efficiency in 4pi for decay "iDecay" for secondary particles.
  float GetSecondaryKFPEfficiency(int iDecay) { return ratio_reco3.counters[3*iDecay+2]; } ///< Returns efficiency of KF Particle Finder method (cuts) for decay "iDecay" for secondary particles.
  
  /** \brief Operator to write efficiencies to file. */
  friend std::fstream & operator<<(std::fstream &strm, KFPartEfficiencies &a) 
  {
    strm << a.ratio_reco1;
    strm << a.ratio_reco2;
    strm << a.ratio_reco3;
    strm << a.mc1;
    strm << a.mc2;
    strm << a.mc3;
    strm << a.reco;
    strm << a.ratio_ghost;
    strm << a.ratio_bg;
    strm << a.ratio_clone;
    strm << a.ghost;
    strm << a.bg;
    strm << a.clone;

    return strm;
  }
  /** \brief Operator to read efficiencies from file. */
  friend std::fstream & operator>>(std::fstream &strm, KFPartEfficiencies &a)
  {
    strm >> a.ratio_reco1;
    strm >> a.ratio_reco2;
    strm >> a.ratio_reco3;
    strm >> a.mc1;
    strm >> a.mc2;
    strm >> a.mc3;
    strm >> a.reco;
    strm >> a.ratio_ghost;
    strm >> a.ratio_bg;
    strm >> a.ratio_clone;
    strm >> a.ghost;
    strm >> a.bg;
    strm >> a.clone;

    return strm;
  }
  /** \brief Adds efficiency from the file with the name defined by "fileName" to the current objects. */
  void AddFromFile(std::string fileName)
  {
    std::fstream file(fileName.data(),std::fstream::in);
    file >> *this;
  }
  
  int GetNDaughters(int iParticle) const { return partDaughterPdg[iParticle].size(); } ///< Returns number of daughter particles for the decay with index "iParticle".
  /** \brief Returns the PDG code of the daughter "iDaughter" from the decay with index "iParticle". */
  int GetDaughterPDG(int iParticle, int iDaughter) const { return partDaughterPdg[iParticle][iDaughter]; }
  
  float GetMass(int iParticle) const { return partMass[iParticle]; } ///< Returns the table mass of the decay with index "iParticle".
  float GetMassSigma(int iParticle) const { return partMassSigma[iParticle]; } ///< Returns expected width of the mass peak of the decay with index "iParticle".
  
  static const int nParticles = 194;                     ///< Number of particles.
  static const int fFirstHypernucleusIndex = 114;        ///< Index of the first hypernuclei in the list.
  static const int fLastHypernucleusIndex = 130;         ///< Index of the last hypernuclei in the list.
  static const int fFirstMissingMassParticleIndex = 131; ///< Index of the first decay reconstructed by the missing mass method.
  static const int fLastMissingMassParticleIndex = 166;  ///< Index of the last decay reconstructed by the missing mass method.
  static const int fFirstStableParticleIndex = 167;      ///< Index of the first stable particle in the list.
  static const int fLastStableParticleIndex = 184;       ///< Index of the last stable particle in the list.
  
  int partPDG[nParticles];                        ///< Array of PDG codes assigned to the decays.
  std::string partName[nParticles];               ///< Array of names of the decay in the file with histograms.
  std::string partTitle[nParticles];              ///< Array of names of the decay in the output table with efficiency.
  std::vector<std::vector<int> > partDaughterPdg; ///< Array with vectors of daughter particles for each decay.
  float partMHistoMin[nParticles];                ///< Array with lower boundary in the mass histograms for each decay.
  float partMHistoMax[nParticles];                ///< Array with upper boundary in the mass histograms for each decay.
  int partMaxMult[nParticles];                    ///< Array with upper boundary in the multiplicity histograms of each decay.
  float partMass[nParticles];                     ///< Array with table masses of each decay.
  float partLifeTime[nParticles];                 ///< Array with lifetimes in seconds of each decay.
  int partCharge[nParticles];                     ///< Array with charge of each particle specie in units of the elementary charge.
  float partMassSigma[nParticles];                ///< Array with expected width of mass peaks used for the side band method.

  
 private:
  std::vector<std::string> names;     ///< Names of the counters. The same for all counters objects.
  std::map<std::string, int> indices; ///< Map between the counter index and its short name.

  std::map<int, int> fPdgToIndex;     ///< The map between PDG code assigned to the decay and index in the decay list.

  KFMCCounter<double> ratio_reco1;    ///< Efficiency in 4 pi for all decays.
  KFMCCounter<double> ratio_reco2;    ///< Efficiency normalised on the particles with all daughters reconstructable for all decays.
  KFMCCounter<double> ratio_reco3;    ///< Efficiency normalised on the particles with all daughters reconstructed for all decays.

  KFMCCounter<int> mc1;               ///< Counters of the Monte Carlo particles of all species.
  KFMCCounter<int> mc2;               ///< Counters of the Monte Carlo particles with all daughters reconstructable for all species.
  KFMCCounter<int> mc3;               ///< Counters of the Monte Carlo particles with all daughters found for all species.

  KFMCCounter<int> reco;              ///< Counters of the reconstructed particles for all species.

  KFMCCounter<double> ratio_ghost;    ///< Ratio of the ghost candidates to the total number of candidates for all species.
  KFMCCounter<double> ratio_bg;       ///< Ratio of the physics background candidates to the total number of candidates for all species.
  KFMCCounter<double> ratio_clone;    ///< Ratio of double reconstructed particles to the total number of signal candidates for all species.

  KFMCCounter<int> ghost;             ///< Counters of the ghost candidates for all species.
  KFMCCounter<int> bg;                ///< Counters of the physics background candidates for all species.
  KFMCCounter<int> clone;             ///< Counters of the double reconstructed particles for all species.
  
#ifndef KFParticleStandalone
  ClassDef( KFPartEfficiencies, 1 )
#endif
};

#endif
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _KFMCParticle_h_
#define _KFMCParticle_h_

#include <vector>

#ifdef HLTCA_STANDALONE
#include "RootTypesDef.h"
#else
#include "TObject.h"
#endif

/** @class KFMCParticle
 ** @brief A class to store relations between mother and daughter Monte Carlo simulated particles.
 ** @author  M.Zyzak, I.Kisel
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** The class is used to calculate reconstruction efficiency of all Monte Carlo particles. It is
 ** simplifies the procedure for short-lived particles. Contains a vector with unique Ids of all
 ** MC daughters, a unique Id of the corresponding MC track, a unique Id of the MC mother particle,
 ** the PDG code of the MC particle, flags showing if particle can be reconstructed according
 ** to several different definitions, flags showing if particle creates a secondary vertex with
 ** two or more daughters, an index of the initial particle Id in case of the K->mu+nu and pi-> mu+nu
 ** decays, since GEANT engines do not store neutrinos. 
 **/

class KFMCParticle :public TObject
{
 public:
  KFMCParticle();
  ~KFMCParticle();

  void AddDaughter( int i ); ///< Adds an Id of the new particle to the list with Ids of daughter particles.
  int  NDaughters() const { return fDaughterIds.size(); } ///< Returns number of daughter particles.
  const std::vector<int>&  GetDaughterIds() const { return fDaughterIds; } ///< Returns a reference to the vector with Id of daughter particle KFMCParticle::fDaughterIds.
  void CleanDaughters() { fDaughterIds.resize(0); } ///< Remove Ids of all daughter particles from the current object.

  void SetPDG(int pdg) {fPDG = pdg;} ///< Set the PDG code of the current particle KFMCParticle::fPDG.
  void SetMCTrackID(int id) {fMCTrackID = id;} ///< Sets the Id of the corresponding Monte Carlo track KFMCParticle::fMCTrackID.
  void SetMotherId(int id) {fMotherId = id;} ///< Sets the Id of the mother particle or primary vertex KFMCParticle::fMotherId.
  
  int  GetMCTrackID()      const {return fMCTrackID;} ///< Returns Id of the corresponding MC track KFMCParticle::fMCTrackID.
  int  GetMotherId()       const {return fMotherId;}  ///< Returns Id of the mother particle or primary vertex KFMCParticle::fMotherId.
  int  GetPDG()            const {return fPDG;}       ///< Returns PDG code of the current particle KFMCParticle::fPDG.
  
  bool IsReconstructable(int i) const {return fIsReconstructable[i];} ///< Returns a flag showing if particle can be reconstructed with KFMCParticle::fIsReconstructable index "i".
  void SetAsReconstructable(int i) { fIsReconstructable[i] = 1;} ///< Defines the particle as those which should be reconstructed for the efficiency set "i".
    
  bool IsReconstructableV0(int i) const {return fIsV0[i];} ///< Returns a flag showing if particle is a reconstructable V0.
  void SetAsReconstructableV0(int i) { fIsV0[i] = 1;}      ///< Defines the particle as V0 which should be reconstructed for the efficiency set "i".
  
  void SetInitialParticleId(int i) {fInitialParticleId = i;} ///< Sets Id of the Monte Carlo particle, from which the current particle was copied.
  int InitialParticleId() const {return fInitialParticleId;} ///< Returns the Id of the Monte Carlo particle, from which the current particle was copied.
 private: //data
  std::vector<int> fDaughterIds; ///< A vector with Ids of the daughter Monte Carlo particles.
  int fMCTrackID; ///< A unique Id of the corresponding Monte Carlo track.
  int fMotherId;  ///< A unique Id of the mother particle. If the current particle is primary the Id of the primary vertex with a negative sigh is stored.
  int fPDG;       ///< A PDG code of the current particle.
  
  /** Flags for calculation of the efficiency, define the denominator in each set of efficiency. 
   ** Flags 0-2 are used for particles reconstructed by the conventional method, 3 and 4 are used
   ** for particles found by the missing mass method: \n
   ** [0] - true for all particles, is used for calculation of the efficiency in 4pi;\n
   ** [1] - true if the particle is long-lived and can be reconstructed in the detector or
   ** if the particle is short-lived and all its daughter particles can be reconstructed; detector-dependent;\n
   ** [2] - true if the particle is long-lived and is reconstructed in the detector or
   ** if the particle is short-lived and all its daughter particles are reconstructed, 
   ** is used in calculation of efficiency of the KF Particle Finder method;\n
   ** [3] - true if the particle is long-lived and is reconstructed in the detector or
   ** if the particle is short-lived, can be reconstructed by the missing mass method
   ** and all its daughter particles are reconstructed; \n
   ** [4] - true for all particles, which can be found by the missing mass method,
   ** is used for calculation of the efficiency in 4pi.
   **/
  bool fIsReconstructable[5];
  /** Flags to calculate efficiency of short-lived particles producing a secondary vertex with 
   ** two or more daughters; similar to KFMCParticle::fIsReconstructable[0-2].
   **/
  bool fIsV0[3]; 

  /** For calculation of missing mass method efficiency a copy of the mother particle
   ** is created. fInitialParticleId is an Id of the initial mother particle.
   **/
  int fInitialParticleId;
#ifndef KFParticleStandalone
  ClassDef( KFMCParticle, 1 )
#endif
};

#endif

/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef KFParticleTest_H
#define KFParticleTest_H

class KFParticle;
class KFParticleSIMD;

class KFParticleTest
{
 public:
  
  KFParticleTest();
  ~KFParticleTest();
  
  void PrintTutorial();
  void RunTest();
  
 private:
   
  void RunTestSingle();
  void RunTestSIMD();
  void CompareSingleAndSIMDResults();
  
  KFParticle* fMotherSingle;
  KFParticleSIMD* fMotherSIMD;
  
#ifndef KFParticleStandalone
  ClassDef( KFParticleTest, 1 )
#endif
};

#endif //KFParticleTest_H


#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class KFParticleBase with content:

#line 1 "libKFParticle dictionary payload"

#ifndef DO_TPCCATRACKER_EFF_PERFORMANCE
  #define DO_TPCCATRACKER_EFF_PERFORMANCE 1
#endif
#ifndef HomogeneousField
  #define HomogeneousField 1
#endif
#ifndef USE_TIMERS
  #define USE_TIMERS 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *               2007-2019 Sergey Gorbunov
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifndef KFPARTICLEBASE_H
#define KFPARTICLEBASE_H

#ifdef __ROOT__ //for the STAR experiment
#define HomogeneousField
#endif

#ifdef HLTCA_STANDALONE
#include "RootTypesDef.h"
#else
#include "TObject.h"
#endif

#include <vector>

/** @class KFParticleBase
 ** @brief The base of KFParticle class, describes particle objects.
 ** @author  S.Gorbunov, I.Kisel, M.Zyzak
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** Contains the main mathematics of the KF Particle . Will be merged with the KFParticle class.
 **/

class KFParticleBase :public TObject {
  
 public:

  /**
   ** Abstract methods are defined in the KFParticle class
   **/ 

  /** Virtual method to access the magnetic field**/
  virtual void GetFieldValue(const float xyz[], float B[]) const = 0;
  
  /** Virtual method to get extrapolation parameter dS=l/p to . Is defined in KFParticle.**/
  virtual float GetDStoPoint( const float xyz[3], float dsdr[6] ) const = 0;
  
  float GetDStoPointLine( const float xyz[3], float dsdr[6] ) const;
  float GetDStoPointBz( float B, const float xyz[3], float dsdr[6], const float* param=0) const;
  float GetDStoPointBy( float By, const float xyz[3], float dsdr[6] ) const;
  float GetDStoPointB( const float* B, const float xyz[3], float dsdr[6] ) const;
  float GetDStoPointCBM( const float xyz[3], float dsdr[6] ) const;

  /** Virtual method to get extrapolation parameter dS=l/p to another particle. Is defined in KFParticle.**/
  virtual void GetDStoParticle( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const = 0;
  
  void GetDStoParticleLine( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const ;
  void GetDStoParticleBz( float Bz, const KFParticleBase &p, float dS[2], float dsdr[4][6], const float* param1=0, const float* param2=0 ) const ;
  void GetDStoParticleBy( float B,  const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const ;
  void GetDStoParticleCBM( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const ;
  
  /** Virtual method to transport a particle on a certain distance along the trajectory. Is defined in KFParticle.**/
  virtual void Transport( float dS, const float dsdr[6], float P[], float C[], float* dsdr1=0, float* F=0, float* F1=0 ) const = 0;


  KFParticleBase();
  virtual ~KFParticleBase() { ; } ///< The default destructor.

  void Initialize( const float Param[], const float Cov[], Int_t Charge, float Mass );
  void Initialize();

  void SetConstructMethod(Int_t m) {fConstructMethod = m;} ///< Defines the construction method for the current particle (see description of fConstructMethod).
  void SetMassHypo(float m) { fMassHypo = m;} ///< Sets the mass hypothesis to the particle, is used when fConstructMethod = 2.
  const float& GetMassHypo() const { return fMassHypo; } ///< Returns the mass hypothesis.
  const float& GetSumDaughterMass() const {return SumDaughterMass;} ///< Returns the sum of masses of the daughters.

  //*
  //*  ACCESSORS
  //*

  //* Simple accessors 

  float GetX    () const { return fP[0]; } ///< Retruns X coordinate of the particle, fP[0].
  float GetY    () const { return fP[1]; } ///< Retruns Y coordinate of the particle, fP[1].
  float GetZ    () const { return fP[2]; } ///< Retruns Z coordinate of the particle, fP[2].
  float GetPx   () const { return fP[3]; } ///< Retruns X component of the momentum, fP[3].
  float GetPy   () const { return fP[4]; } ///< Retruns Y component of the momentum, fP[4].
  float GetPz   () const { return fP[5]; } ///< Retruns Z component of the momentum, fP[5].
  float GetE    () const { return fP[6]; } ///< Returns energy of the particle, fP[6].
  float GetS    () const { return fP[7]; } ///< Returns dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  char  GetQ    () const { return fQ;    } ///< Returns charge of the particle.
  float GetChi2 () const { return fChi2; } ///< Returns Chi2 of the fit.
  Int_t GetNDF  () const { return fNDF;  } ///< Returns number of decrease of freedom.

  const float& X    () const { return fP[0]; } ///< Retruns X coordinate of the particle, fP[0].
  const float& Y    () const { return fP[1]; } ///< Retruns Y coordinate of the particle, fP[1].
  const float& Z    () const { return fP[2]; } ///< Retruns Z coordinate of the particle, fP[2].
  const float& Px   () const { return fP[3]; } ///< Retruns X component of the momentum, fP[3].
  const float& Py   () const { return fP[4]; } ///< Retruns Y component of the momentum, fP[4].
  const float& Pz   () const { return fP[5]; } ///< Retruns Z component of the momentum, fP[5].
  const float& E    () const { return fP[6]; } ///< Returns energy of the particle, fP[6].
  const float& S    () const { return fP[7]; } ///< Returns dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  const char& Q     () const { return fQ;    } ///< Returns charge of the particle.
  const float& Chi2 () const { return fChi2; } ///< Returns Chi2 of the fit.
  const Int_t& NDF  () const { return fNDF;  } ///< Returns number of decrease of freedom.
  
  float GetParameter ( Int_t i )          const { return fP[i];       } ///< Returns P[i] parameter.
  float GetCovariance( Int_t i )          const { return fC[i];       } ///< Returns C[i] element of the covariance matrix in the lower triangular form.
  float GetCovariance( Int_t i, Int_t j ) const { return fC[IJ(i,j)]; } ///< Returns C[i,j] element of the covariance matrix.

  //* Accessors with calculations( &value, &estimated sigma )
  //* error flag returned (0 means no error during calculations) 

  Int_t GetMomentum      ( float &p,   float &error ) const ;
  Int_t GetPt            ( float &pt,  float &error ) const ;
  Int_t GetEta           ( float &eta, float &error ) const ;
  Int_t GetPhi           ( float &phi, float &error ) const ;
  Int_t GetMass          ( float &m,   float &error ) const ;
  Int_t GetDecayLength   ( float &l,   float &error ) const ;
  Int_t GetDecayLengthXY ( float &l,   float &error ) const ;
  Int_t GetLifeTime      ( float &ctau,float &error ) const ;
  Int_t GetR             ( float &r,   float &error ) const ;

  //*
  //*  MODIFIERS
  //*
  
  float & X    () { return fP[0]; } ///< Modifier of X coordinate of the particle, fP[0].
  float & Y    () { return fP[1]; } ///< Modifier of Y coordinate of the particle, fP[1].
  float & Z    () { return fP[2]; } ///< Modifier of Z coordinate of the particle, fP[2].
  float & Px   () { return fP[3]; } ///< Modifier of X component of the momentum, fP[3].
  float & Py   () { return fP[4]; } ///< Modifier of Y component of the momentum, fP[4].
  float & Pz   () { return fP[5]; } ///< Modifier of Z component of the momentum, fP[5].
  float & E    () { return fP[6]; } ///< Modifier of energy of the particle, fP[6].
  float & S    () { return fP[7]; } ///< Modifier of dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  char  & Q    () { return fQ;    } ///< Modifier of charge of the particle.
  float & Chi2 () { return fChi2; } ///< Modifier of Chi2 of the fit.
  Int_t & NDF  () { return fNDF;  } ///< Modifier of number of decrease of freedom.

  float & Parameter ( Int_t i )          { return fP[i];       } ///< Modifier of P[i] parameter.
  float & Covariance( Int_t i )          { return fC[i];       } ///< Modifier of C[i] element of the covariance matrix in the lower triangular form.
  float & Covariance( Int_t i, Int_t j ) { return fC[IJ(i,j)]; } ///< Modifier of C[i,j] element of the covariance matrix.


  //* 
  //* CONSTRUCTION OF THE PARTICLE BY ITS DAUGHTERS AND MOTHER
  //* USING THE KALMAN FILTER METHOD
  //*


  //* Simple way to add daughter ex. D0+= Pion; 

  void operator +=( const KFParticleBase &Daughter );  

  //* Add daughter track to the particle 

  void AddDaughter( const KFParticleBase &Daughter );
  void SubtractDaughter( const KFParticleBase &Daughter );

  void AddDaughterWithEnergyFit( const KFParticleBase &Daughter );
  void AddDaughterWithEnergyFitMC( const KFParticleBase &Daughter );

  //* Set production vertex 

  void SetProductionVertex( const KFParticleBase &Vtx );

  //* Set mass constraint 

  void SetNonlinearMassConstraint( float Mass );
  void SetMassConstraint( float Mass, float SigmaMass = 0 );

  //* Set no decay length for resonances

  void SetNoDecayLength();


  //* Everything in one go  

  void Construct( const KFParticleBase *vDaughters[], Int_t nDaughters, const KFParticleBase *ProdVtx=0,   float Mass=-1 );

  //Transport functions
  void TransportToDecayVertex();
  void TransportToProductionVertex();
  void TransportToDS( float dS, const float* dsdr );
  void TransportBz( float Bz, float dS, const float* dsdr, float P[], float C[], float* dsdr1=0, float* F=0, float* F1=0 ) const;
  void TransportCBM( float dS, const float* dsdr, float P[], float C[], float* dsdr1=0, float* F=0, float* F1=0 ) const;  

  //* 
  //* OTHER UTILITIES
  //*

  //* Calculate distance from another object [cm]

  float GetDistanceFromVertex( const float vtx[] ) const;
  float GetDistanceFromVertex( const KFParticleBase &Vtx ) const;
  float GetDistanceFromParticle( const KFParticleBase &p ) const;

  //* Calculate sqrt(Chi2/ndf) deviation from vertex
  //* v = [xyz], Cv=[Cxx,Cxy,Cyy,Cxz,Cyz,Czz]-covariance matrix

  float GetDeviationFromVertex( const float v[], const float Cv[]=0 ) const;
  float GetDeviationFromVertex( const KFParticleBase &Vtx ) const;
  float GetDeviationFromParticle( const KFParticleBase &p ) const;  

  void SubtractFromVertex( KFParticleBase &Vtx ) const;
  void SubtractFromParticle( KFParticleBase &Vtx ) const;

  static void GetArmenterosPodolanski(KFParticleBase& positive, KFParticleBase& negative, float QtAlfa[2] );
  void RotateXY(float angle, float Vtx[3]);

  int Id() const { return fId; } ///< Returns Id of the particle.
  int NDaughters() const { return fDaughtersIds.size(); } ///< Returns number of daughter particles.
  const std::vector<int>& DaughterIds() const { return fDaughtersIds; } ///< Returns the vector with the indices of daughter particles.
  void CleanDaughtersId() { fDaughtersIds.clear(); } ///< Cleans the vector with the indices of daughter particles.
  
  void SetId( int id ) { fId = id; } ///< Sets the Id of the particle. After the construction of a particle should be set by user.
  void AddDaughterId( int id ) { fDaughtersIds.push_back(id); } ///< Adds index of the daughter particle. 

  void SetPDG ( int pdg ) { fPDG = pdg; } ///< Sets the PDG hypothesis.
  int GetPDG () const { return fPDG; } ///< Returns the PDG hypothesis.

#ifdef __ROOT__ //for the STAR experiment
  virtual void Print(Option_t *opt="") const;
  Int_t        IdTruth() const { return fIdTruth;}
  Int_t        QaTruth() const { return fQuality; }
  Int_t        IdParentMcVx() const {return fIdParentMcVx;}
  Int_t        IdParentVx()   const {return IdParentMcVx();}
  void         SetParentID(Int_t id=0) {fParentID = id;}
  Int_t        GetParentID() const {return fParentID;}
  void         SetIdParentMcVx(Int_t id) {fIdParentMcVx = id;}
  void         SetIdTruth(Int_t idtru,Int_t qatru=0) {fIdTruth = (UShort_t) idtru; fQuality = (UShort_t) qatru;}
  virtual void Clear(Option_t * /*option*/ ="");
#endif

  static void InvertCholetsky3(float a[6]);
  static void MultQSQt( const float Q[], const float S[], float SOut[], const int kN );

 protected:
  /** Converts a pair of indices {i,j} of the covariance matrix to one index corresponding to the triangular form. */
  static Int_t IJ( Int_t i, Int_t j ){ 
    return ( j<=i ) ? i*(i+1)/2+j :j*(j+1)/2+i;
  }
  /** Return an element of the covariance matrix with {i,j} indices. */
  float & Cij( Int_t i, Int_t j ){ return fC[IJ(i,j)]; }
  void TransportLine( float S, const float* dsdr, float P[], float C[], float* dsdr1, float* F, float* F1 ) const ;
  bool GetMeasurement( const KFParticleBase& daughter, float m[], float V[], float D[3][3] ) ;
  void SetMassConstraint( float *mP, float *mC, float mJ[7][7], float mass );

  float fP[8];           ///< Particle parameters { X, Y, Z, Px, Py, Pz, E, S[=DecayLength/P]}.
  float fC[36];          ///< Low-triangle covariance matrix of fP.
  float fChi2;           ///< Chi^2.
  float fSFromDecay;     ///< Distance from the decay vertex to the current position.
  float SumDaughterMass; ///< Sum of the daughter particles masses. Needed to set the constraint on the minimum mass during particle construction.
  float fMassHypo;       ///< The mass hypothesis, used for the constraints during particle construction.
  Int_t fNDF;            ///< Number of degrees of freedom.
  int   fId;             ///< Id of the particle.
#ifdef __ROOT__ //for the STAR experiment
  Short_t    fParentID;     ///< Id of the parent particle.
  Short_t    fIdTruth;      ///< MC track id.
  Short_t    fQuality;      ///< quality of this information (percentage of hits coming from the above MC track).
  Short_t    fIdParentMcVx; ///< for track and McTrack for vertex.
#endif
  Bool_t fAtProductionVertex; ///< Flag shows if particle is at the production point.
  char fQ; ///< The charge of the particle in the units of the elementary charge.
  
  /** \brief Determines the method for the particle construction. \n
   ** 0 - Energy considered as an independent veriable, fitted independently from momentum, without any constraints on mass \n
   ** 2 - Energy considered as an independent variable, fitted independently from momentum, with constraints on mass of daughter particle
   **/
  char fConstructMethod; 
  int fPDG; ///< The PDG hypothesis assigned to the particle.
  
  /** \brief A vector with ids of the daughter particles: \n
   ** 1) if particle is created from a track - the index of the track, in this case the size of the vector is always equal to one; \n
   ** 2) if particle is constructed from other particles - indices of these particles in the same array.
   **/
  std::vector<int> fDaughtersIds;
 
#ifndef KFParticleStandalone
  ClassDef( KFParticleBase, 2 )
#endif
};

#ifdef __ROOT__ //for the STAR experiment
std::ostream&  operator<<(std::ostream& os, KFParticleBase const & particle);
#endif

#endif 
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *               2007-2019 Sergey Gorbunov
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

//#define NonhomogeneousField
// #define HomogeneousField

#ifndef KFPARTICLE_H
#define KFPARTICLE_H

#include "KFParticleBase.h"
#include <cmath>

class KFPTrack;
class KFPVertex;

/** @class KFParticle
 ** @brief The main scalar class of KF Particle package, describes particle objects.
 ** @author  S.Gorbunov, I.Kisel, M.Zyzak
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** The main scalar class of KF Particle pacakge, describes particle objects.
 ** The particle is described with the state vector { X, Y, Z, Px, Py, Pz, E }
 ** and the corresponding covariance matrix.
 ** It contains functionality to create particle-object from track, to construct 
 ** short-lived particles from other tracks or particles. The mathematics is 
 ** based on the Kalman filter method. It also allows to subtract particles from 
 ** the already constructed object,
 ** to transport particles, get parameters together with their errors, get distance 
 ** to other particles and vertices, get deviations from them in terms of errors, etc.
 **/

class KFParticle :public KFParticleBase
{
  
 public:

  //*
  //*  INITIALIZATION
  //*

  //* Set magnetic field for all particles
#ifdef HomogeneousField
  static void SetField( float Bz );
#endif
  //* Constructor (empty)

  KFParticle():KFParticleBase(){ ; }

  //* Destructor (empty)

  ~KFParticle(){ ; }

  //* Construction of mother particle by its 2-3-4 daughters

  KFParticle( const KFParticle &d1, const KFParticle &d2 );

  KFParticle( const KFParticle &d1, const KFParticle &d2, 
              const KFParticle &d3 );

  KFParticle( const KFParticle &d1, const KFParticle &d2, 
              const KFParticle &d3, const KFParticle &d4 );
 
 //* Initialisation from "cartesian" coordinates ( X Y Z Px Py Pz )
 //* Parameters, covariance matrix, charge and PID hypothesis should be provided 

  void Create( const float Param[], const float Cov[], Int_t Charge, float mass /*Int_t PID*/ );
  void Create( const Double_t Param[], const Double_t Cov[], Int_t Charge, float mass /*Int_t PID*/ );

 //* Initialisation from ALICE track, PID hypothesis shoould be provided 

  KFParticle( const KFPTrack &track, const int PID );


  //* Initialisation from VVertex 

  KFParticle( const KFPVertex &vertex );

  //* Initialise covariance matrix and set current parameters to 0.0 

  void Initialize();

  //*
  //*  ACCESSORS
  //*

  //* Simple accessors 

  float GetX    () const ; ///< Retruns X coordinate of the particle, fP[0].
  float GetY    () const ; ///< Retruns Y coordinate of the particle, fP[1].
  float GetZ    () const ; ///< Retruns Z coordinate of the particle, fP[2].
  float GetPx   () const ; ///< Retruns X component of the momentum, fP[3].
  float GetPy   () const ; ///< Retruns Y component of the momentum, fP[4].
  float GetPz   () const ; ///< Retruns Z component of the momentum, fP[5].
  float GetE    () const ; ///< Returns energy of the particle, fP[6].
  float GetS    () const ; ///< Returns dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  char  GetQ    () const ; ///< Returns charge of the particle.
  float GetChi2 () const ; ///< Returns Chi2 of the fit.
  Int_t GetNDF  () const ; ///< Returns number of decrease of freedom.

  Bool_t GetAtProductionVertex() const { return fAtProductionVertex; } ///< Returns a flag which shows if the particle is located at the production point
  void SetAtProductionVertex(Bool_t b) { fAtProductionVertex = b; } ///< Set a flag that particle is at the production point

#ifdef NonhomogeneousField
  const float* GetFieldCoeff() const { return fieldRegion; } ///< Returns the field approximation for the current particle
  void SetFieldCoeff(float c, int i) { fieldRegion[i] = c; } ///< Sets the field coefficient with index i.
#endif

  const float& X    () const { return fP[0]; } ///< Retruns X coordinate of the particle, fP[0].
  const float& Y    () const { return fP[1]; } ///< Retruns Y coordinate of the particle, fP[1].
  const float& Z    () const { return fP[2]; } ///< Retruns Z coordinate of the particle, fP[2].
  const float& Px   () const { return fP[3]; } ///< Retruns X component of the momentum, fP[3].
  const float& Py   () const { return fP[4]; } ///< Retruns Y component of the momentum, fP[4].
  const float& Pz   () const { return fP[5]; } ///< Retruns Z component of the momentum, fP[5].
  const float& E    () const { return fP[6]; } ///< Returns energy of the particle, fP[6].
  const float& S    () const { return fP[7]; } ///< Returns dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  const char&  Q    () const { return fQ;    } ///< Returns charge of the particle.
  const float& Chi2 () const { return fChi2; } ///< Returns Chi2 of the fit.
  const Int_t& NDF  () const { return fNDF;  } ///< Returns number of decrease of freedom.
  
  float GetParameter ( int i ) const ;        ///< Returns P[i] parameter.
  float GetCovariance( int i ) const ;        ///< Returns C[i] element of the covariance matrix in the lower triangular form.
  float GetCovariance( int i, int j ) const ; ///< Returns C[i,j] element of the covariance matrix.

  //* Accessors with calculations, value returned w/o error flag
  
  float GetP             () const; ///< Returns momentum
  float GetPt            () const; ///< Returns transverse momentum
  float GetEta           () const; ///< Returns pseudorapidity
  float GetPhi           () const; ///< Returns the azimuthal angle phi 
  float GetMomentum      () const; ///< Returns momentum
  float GetMass          () const; ///< Returns mass
  float GetDecayLength   () const; ///< Returns decay length
  float GetDecayLengthXY () const; ///< Returns decay length in XY
  float GetLifeTime      () const; ///< Returns life time ctau [cm]
  float GetR             () const; ///< Returns distance to the origin of the coordinate system {0,0,0}

  //* Accessors to estimated errors

  float GetErrX             () const ; ///< Returns the error of X of current position 
  float GetErrY             () const ; ///< Returns the error of Y of current position
  float GetErrZ             () const ; ///< Returns the error of Z of current position
  float GetErrPx            () const ; ///< Returns the error of X-compoment of the particle momentum
  float GetErrPy            () const ; ///< Returns the error of Y-compoment of the particle momentum
  float GetErrPz            () const ; ///< Returns the error of Z-compoment of the particle momentum
  float GetErrE             () const ; ///< Returns the error of energy
  float GetErrS             () const ; ///< Returns the error of decay length / momentum
  float GetErrP             () const ; ///< Returns the error of momentum
  float GetErrPt            () const ; ///< Returns the error of transverse momentum
  float GetErrEta           () const ; ///< Returns the error of pseudorapidity
  float GetErrPhi           () const ; ///< Returns the error of the azimuthal angle phi 
  float GetErrMomentum      () const ; ///< Returns the error of momentum
  float GetErrMass          () const ; ///< Returns the error of mass
  float GetErrDecayLength   () const ; ///< Returns the error of decay length
  float GetErrDecayLengthXY () const ; ///< Returns the error of decay length in XY
  float GetErrLifeTime      () const ; ///< Returns the error of life time
  float GetErrR             () const ; ///< Returns the error of distance to the origin of the coordinate system {0,0,0}

  //* Accessors with calculations( &value, &estimated sigma )
  //* error flag returned (0 means no error during calculations) 

  int GetP             ( float &P, float &SigmaP ) const ;     //* momentum
  int GetPt            ( float &Pt, float &SigmaPt ) const ;   //* transverse momentum
  int GetEta           ( float &Eta, float &SigmaEta ) const ; //* pseudorapidity
  int GetPhi           ( float &Phi, float &SigmaPhi ) const ; //* phi
  int GetMomentum      ( float &P, float &SigmaP ) const ;     //* momentum
  int GetMass          ( float &M, float &SigmaM ) const ;     //* mass
  int GetDecayLength   ( float &L, float &SigmaL ) const ;     //* decay length
  int GetDecayLengthXY ( float &L, float &SigmaL ) const ;     //* decay length in XY
  int GetLifeTime      ( float &T, float &SigmaT ) const ;     //* life time
  int GetR             ( float &R, float &SigmaR ) const ;     //* R
  float GetRapidity() const { return 0.5*log((fP[6] + fP[5])/(fP[6] - fP[5])); } ///< Returns rapidity of the particle
  float GetTheta()    const { return atan2(GetPt(),fP[5]); } ///< Returns the polar angle in RZ


  //*
  //*  MODIFIERS
  //*
  
  float & X    () ; ///< Modifier of X coordinate of the particle, fP[0].
  float & Y    () ; ///< Modifier of Y coordinate of the particle, fP[1].
  float & Z    () ; ///< Modifier of Z coordinate of the particle, fP[2].
  float & Px   () ; ///< Modifier of X component of the momentum, fP[3].
  float & Py   () ; ///< Modifier of Y component of the momentum, fP[4].
  float & Pz   () ; ///< Modifier of Z component of the momentum, fP[5].
  float & E    () ; ///< Modifier of energy of the particle, fP[6].
  float & S    () ; ///< Modifier of dS=l/p, l - decay length, fP[7], defined if production vertex is set.
  char  & Q    () ; ///< Modifier of charge of the particle.
  float & Chi2 () ; ///< Modifier of Chi2 of the fit.
  Int_t & NDF  () ; ///< Modifier of number of decrease of freedom.

  float & Parameter ( int i ) ;        ///< Modifier of P[i] parameter.
  float & Covariance( int i ) ;        ///< Modifier of C[i] element of the covariance matrix in the lower triangular form.
  float & Covariance( int i, int j ) ; ///< Modifier of C[i,j] element of the covariance matrix.
  float * Parameters () ;              ///< Returns pointer to the parameters fP
  float * CovarianceMatrix() ;         ///< Returns pointer to the covariance matrix fC

  //* 
  //* CONSTRUCTION OF THE PARTICLE BY ITS DAUGHTERS AND MOTHER
  //* USING THE KALMAN FILTER METHOD
  //*


  //* Add daughter to the particle 

  void AddDaughter( const KFParticle &Daughter );

  //* Add daughter via += operator: ex.{ D0; D0+=Pion; D0+= Kaon; }

  void operator +=( const KFParticle &Daughter );  

  //* Everything in one go  

  void Construct( const KFParticle *vDaughters[], int nDaughters, 
		  const KFParticle *ProdVtx=0,   float Mass=-1 );

  //*
  //*                   TRANSPORT
  //* 
  //*  ( main transportation parameter is S = SignedPath/Momentum )
  //*  ( parameters of decay & production vertices are stored locally )
  //*

  //* Transport the particle close to xyz[] point 

  void TransportToPoint( const float xyz[] );

  //* Transport the particle close to VVertex  
#ifdef HomogeneousField
  void TransportToVertex( const KFPVertex &v );
#endif
  //* Transport the particle close to another particle p 
  void TransportToParticle( const KFParticle &p );

  //* Get dS to a certain space point 
  float GetDStoPoint( const float xyz[3], float dsdr[6] ) const ;
  
  //* Get dS to other particle p (dSp for particle p also returned) 
  void GetDStoParticle( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const ;
  
  
  //* 
  //* OTHER UTILITIES
  //*
 
  //* Calculate distance from another object [cm] in XY-plane

  Bool_t GetDistanceFromVertexXY( const float vtx[], float &val, float &err ) const ;
  Bool_t GetDistanceFromVertexXY( const float vtx[], const float Cv[], float &val, float &err ) const ;
  Bool_t GetDistanceFromVertexXY( const KFParticle &Vtx, float &val, float &err ) const ;
#ifdef HomogeneousField
  Bool_t GetDistanceFromVertexXY( const KFPVertex &Vtx, float &val, float &err ) const ;
#endif

  float GetDistanceFromVertexXY( const float vtx[] ) const ;
  float GetDistanceFromVertexXY( const KFParticle &Vtx ) const ;
#ifdef HomogeneousField
  float GetDistanceFromVertexXY( const KFPVertex &Vtx ) const ;
#endif
  float GetDistanceFromParticleXY( const KFParticle &p ) const ;

  //* Calculate sqrt(Chi2/ndf) deviation from another object in XY plane
  //* ( v = [xyz]-vertex, Cv=[Cxx,Cxy,Cyy,Cxz,Cyz,Czz]-covariance matrix )

  float GetDeviationFromVertexXY( const float v[], const float Cv[]=0 ) const ;
  float GetDeviationFromVertexXY( const KFParticle &Vtx ) const ;
#ifdef HomogeneousField
  float GetDeviationFromVertexXY( const KFPVertex &Vtx ) const ;
#endif
  float GetDeviationFromParticleXY( const KFParticle &p ) const ;

  //* Get parameters at an arbitrary reconstructed point taking into account its errors
  void GetParametersAtPoint(const float* point, const float* pointCov, float* m, float* mV);
  
  //* Calculate opennig angle between two particles

  float GetAngle  ( const KFParticle &p ) const ;
  float GetAngleXY( const KFParticle &p ) const ;
  float GetAngleRZ( const KFParticle &p ) const ;

  float GetPseudoProperDecayTime( const KFParticle &primVertex, const float& mass, float* timeErr2 = 0 ) const;

  void GetFieldValue( const float xyz[], float B[] ) const ;

  void Transport( float dS, const float* dsdr, float P[], float C[], float* dsdr1=0, float* F=0, float* F1=0 ) const ;

 protected: 
  
  //*
  //*  INTERNAL STUFF
  //* 

  //* Method to access ALICE field 
#ifdef HomogeneousField
  static float GetFieldAlice();
#endif
  
 private:
#ifdef HomogeneousField
  static float fgBz;  ///< Bz compoment of the magnetic field (is defined in case of #ifdef HomogeneousField)
#endif
#ifdef NonhomogeneousField
  /** \brief Approximation of the magnetic field along the track trajectory.
   ** Each component (Bx, By, Bz) is approximated with the parabola depending on Z coordinate. Is defined in case of #ifdef NonhomogeneousField.
   **/
  float fieldRegion[10];
#endif
  
#ifndef KFParticleStandalone
  ClassDef( KFParticle, 3 )
#endif
};



//---------------------------------------------------------------------
//
//     Inline implementation of the KFParticle methods
//
//---------------------------------------------------------------------

#ifdef HomogeneousField
inline void KFParticle::SetField( float Bz )
{ 
  /** Sets the constant homogemeous one-component magnetic field Bz (is defined in case of #ifdef HomogeneousField).
   ** \param[in] Bz - Z-component of the magnetic field
   **/
  fgBz = Bz;
}
#endif

inline KFParticle::KFParticle( const KFParticle &d1, 
                               const KFParticle &d2, 
                               const KFParticle &d3 )
{
  /** Constructs a particle from three input daughter particles
   ** \param[in] d1 - the first daughter particle
   ** \param[in] d2 - the second daughter particle
   ** \param[in] d3 - the third daughter particle
   **/
  KFParticle mother;
  mother+= d1;
  mother+= d2;
  mother+= d3;
  *this = mother;
}

inline KFParticle::KFParticle( const KFParticle &d1, 
                               const KFParticle &d2, 
                               const KFParticle &d3, 
                               const KFParticle &d4 )
{
  /** Constructs a particle from four input daughter particles
   ** \param[in] d1 - the first daughter particle
   ** \param[in] d2 - the second daughter particle
   ** \param[in] d3 - the third daughter particle
   ** \param[in] d4 - the fourth daughter particle
   **/
  KFParticle mother;
  mother+= d1;
  mother+= d2;
  mother+= d3;
  mother+= d4;
  *this = mother;
}


inline void KFParticle::Initialize()
{ 
  /** Calls KFParticleBase::Initialize()*/
  KFParticleBase::Initialize(); 
}

inline float KFParticle::GetX    () const 
{ 
  return KFParticleBase::GetX();    
}

inline float KFParticle::GetY    () const 
{ 
  return KFParticleBase::GetY();    
}

inline float KFParticle::GetZ    () const 
{ 
  return KFParticleBase::GetZ();    
}

inline float KFParticle::GetPx   () const 
{ 
  return KFParticleBase::GetPx();   
}

inline float KFParticle::GetPy   () const 
{ 
  return KFParticleBase::GetPy();   
}

inline float KFParticle::GetPz   () const 
{ 
  return KFParticleBase::GetPz();   
}

inline float KFParticle::GetE    () const 
{ 
  return KFParticleBase::GetE();    
}

inline float KFParticle::GetS    () const 
{ 
  return KFParticleBase::GetS();    
}

inline char    KFParticle::GetQ    () const 
{ 
  return KFParticleBase::GetQ();    
}

inline float KFParticle::GetChi2 () const 
{ 
  return KFParticleBase::GetChi2(); 
}

inline Int_t    KFParticle::GetNDF  () const 
{ 
  return KFParticleBase::GetNDF();  
}

inline float KFParticle::GetParameter ( int i ) const 
{ 
  return KFParticleBase::GetParameter(i);  
}

inline float KFParticle::GetCovariance( int i ) const 
{ 
  return KFParticleBase::GetCovariance(i); 
}

inline float KFParticle::GetCovariance( int i, int j ) const 
{ 
  return KFParticleBase::GetCovariance(i,j);
}


inline float KFParticle::GetP    () const
{
  float par, err;
  if( KFParticleBase::GetMomentum( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetPt   () const
{
  float par, err;
  if( KFParticleBase::GetPt( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetEta   () const
{
  float par, err;
  if( KFParticleBase::GetEta( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetPhi   () const
{
  float par, err;
  if( KFParticleBase::GetPhi( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetMomentum    () const
{
  float par, err;
  if( KFParticleBase::GetMomentum( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetMass        () const
{
  float par, err;
  if( KFParticleBase::GetMass( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetDecayLength () const
{
  float par, err;
  if( KFParticleBase::GetDecayLength( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetDecayLengthXY () const
{
  float par, err;
  if( KFParticleBase::GetDecayLengthXY( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetLifeTime    () const
{
  float par, err;
  if( KFParticleBase::GetLifeTime( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetR   () const
{
  float par, err;
  if( KFParticleBase::GetR( par, err ) ) return 0;
  else return par;
}

inline float KFParticle::GetErrX           () const 
{
  return sqrt(fabs( GetCovariance(0,0) ));
}

inline float KFParticle::GetErrY           () const 
{
  return sqrt(fabs( GetCovariance(1,1) ));
}

inline float KFParticle::GetErrZ           () const 
{
  return sqrt(fabs( GetCovariance(2,2) ));
}

inline float KFParticle::GetErrPx          () const 
{
  return sqrt(fabs( GetCovariance(3,3) ));
}

inline float KFParticle::GetErrPy          () const 
{
  return sqrt(fabs( GetCovariance(4,4) ));
}

inline float KFParticle::GetErrPz          () const 
{
  return sqrt(fabs( GetCovariance(5,5) ));
}

inline float KFParticle::GetErrE           () const 
{
  return sqrt(fabs( GetCovariance(6,6) ));
}

inline float KFParticle::GetErrS           () const 
{
  return sqrt(fabs( GetCovariance(7,7) ));
}

inline float KFParticle::GetErrP    () const
{
  float par, err;
  if( KFParticleBase::GetMomentum( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrPt    () const
{
  float par, err;
  if( KFParticleBase::GetPt( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrEta    () const
{
  float par, err;
  if( KFParticleBase::GetEta( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrPhi    () const
{
  float par, err;
  if( KFParticleBase::GetPhi( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrMomentum    () const
{
  float par, err;
  if( KFParticleBase::GetMomentum( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrMass        () const
{
  float par, err;
  if( KFParticleBase::GetMass( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrDecayLength () const
{
  float par, err;
  if( KFParticleBase::GetDecayLength( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrDecayLengthXY () const
{
  float par, err;
  if( KFParticleBase::GetDecayLengthXY( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrLifeTime    () const
{
  float par, err;
  if( KFParticleBase::GetLifeTime( par, err ) ) return 1.e10;
  else return err;
}

inline float KFParticle::GetErrR    () const
{
  float par, err;
  if( KFParticleBase::GetR( par, err ) ) return 1.e10;
  else return err;
}


inline int KFParticle::GetP( float &P, float &SigmaP ) const 
{
  /** Calculates particle momentum and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] P - momentum of the particle
   ** \param[out] SigmaP - its error
   **/
  return KFParticleBase::GetMomentum( P, SigmaP );
}

inline int KFParticle::GetPt( float &Pt, float &SigmaPt ) const 
{
  /** Calculates particle transverse  momentum and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] Pt - transverse momentum of the particle
   ** \param[out] SigmaPt - its error
   **/
  return KFParticleBase::GetPt( Pt, SigmaPt );
}

inline int KFParticle::GetEta( float &Eta, float &SigmaEta ) const 
{
  /** Calculates particle pseudorapidity and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] Eta - pseudorapidity of the particle
   ** \param[out] SigmaEta - its error
   **/
  return KFParticleBase::GetEta( Eta, SigmaEta );
}

inline int KFParticle::GetPhi( float &Phi, float &SigmaPhi ) const 
{
  /** Calculates particle polar angle at the current point and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] Phi - polar angle of the particle
   ** \param[out] SigmaPhi - its error
   **/
  return KFParticleBase::GetPhi( Phi, SigmaPhi );
}

inline int KFParticle::GetMomentum( float &P, float &SigmaP ) const 
{
  /** Calculates particle momentum and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] P - momentum of the particle
   ** \param[out] SigmaP - its error
   **/
  return KFParticleBase::GetMomentum( P, SigmaP );
}

inline int KFParticle::GetMass( float &M, float &SigmaM ) const 
{
  /** Calculates the mass of the particle and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] M - mass of the particle
   ** \param[out] SigmaM - its error
   **/
  return KFParticleBase::GetMass( M, SigmaM );
}

inline int KFParticle::GetDecayLength( float &L, float &SigmaL ) const 
{
  /** Calculates the decay length of the particle in the laboratory system and its error. If they are well defined returns 0, otherwise 1.
   ** The production point should be set before calling this function.
   ** \param[out] L - the decay length
   ** \param[out] SigmaL - its error
   **/
  return KFParticleBase::GetDecayLength( L, SigmaL );
}

inline int KFParticle::GetDecayLengthXY( float &L, float &SigmaL ) const 
{
  /** Calculates the projection in the XY plane of the decay length of the particle in the laboratory 
   ** system and its error. If they are well defined returns 0, otherwise 1.
   ** The production point should be set before calling this function.
   ** \param[out] L - the decay length
   ** \param[out] SigmaL - its error
   **/
  return KFParticleBase::GetDecayLengthXY( L, SigmaL );
}

inline int KFParticle::GetLifeTime( float &T, float &SigmaT ) const 
{
  /** Calculates the lifetime times speed of life (ctau) [cm] of the particle in the  
   ** center of mass frame and its error. If they are well defined returns 0, otherwise 1.
   ** The production point should be set before calling this function.
   ** \param[out] T - lifetime of the particle [cm]
   ** \param[out] SigmaT - its error
   **/
  return KFParticleBase::GetLifeTime( T, SigmaT );
}

inline int KFParticle::GetR( float &R, float &SigmaR ) const 
{
  /** Calculates the distance to the point {0,0,0} and its error. If they are well defined returns 0, otherwise 1.
   ** \param[out] R - polar angle of the particle
   ** \param[out] SigmaR - its error
   **/
  return KFParticleBase::GetR( R, SigmaR );
}

inline float & KFParticle::X() 
{ 
  return KFParticleBase::X();    
}

inline float & KFParticle::Y()
{ 
  return KFParticleBase::Y();    
}

inline float & KFParticle::Z() 
{ 
  return KFParticleBase::Z();    
}

inline float & KFParticle::Px() 
{ 
  return KFParticleBase::Px();   
}

inline float & KFParticle::Py() 
{ 
  return KFParticleBase::Py();   
}

inline float & KFParticle::Pz() 
{ 
  return KFParticleBase::Pz();   
}

inline float & KFParticle::E() 
{ 
  return KFParticleBase::E();    
}

inline float & KFParticle::S() 
{ 
  return KFParticleBase::S();    
}

inline char    & KFParticle::Q() 
{ 
  return KFParticleBase::Q();    
}

inline float & KFParticle::Chi2() 
{ 
  return KFParticleBase::Chi2(); 
}

inline Int_t    & KFParticle::NDF() 
{ 
  return KFParticleBase::NDF();  
}

inline float & KFParticle::Parameter ( int i )        
{ 
  return KFParticleBase::Parameter(i);
}

inline float & KFParticle::Covariance( int i )        
{ 
  return KFParticleBase::Covariance(i);
}

inline float & KFParticle::Covariance( int i, int j ) 
{ 
  return KFParticleBase::Covariance(i,j); 
}

inline float * KFParticle::Parameters ()
{
  return fP;
}

inline float * KFParticle::CovarianceMatrix()
{
  return fC;
}


inline void KFParticle::operator +=( const KFParticle &Daughter )
{
  /** Operator to add daughter to the current particle. Calls AddDaughter() function.
   ** \param[in] Daughter - the daughter particle
   **/
#ifdef NonhomogeneousField
  for(int i=0; i<10; i++)
    SetFieldCoeff(Daughter.GetFieldCoeff()[i], i);
#endif
  KFParticleBase::operator +=( Daughter );
}
  

inline void KFParticle::AddDaughter( const KFParticle &Daughter )
{
  /** Adds daughter to the current particle. Depending on the selected construction method uses: \n
   ** 1) Either simplifyed fast mathematics which consideres momentum and energy as
   ** independent variables and thus ignores constraint on the fixed mass (fConstructMethod = 0).
   ** In this case the mass of the daughter particle can be corrupted when the constructed vertex
   ** is added as the measurement and the mass of the output short-lived particle can become 
   ** unphysical - smaller then the threshold. Implemented in the 
   ** AddDaughterWithEnergyFit() function \n
   ** 2) Or slower but correct mathematics which requires that the masses of daughter particles 
   ** stays fixed in the construction process (fConstructMethod = 2). Implemented in the
   ** AddDaughterWithEnergyFitMC() function.
   ** \param[in] Daughter - the daughter particle
   **/
#ifdef NonhomogeneousField
  for(int i=0; i<10; i++)
    SetFieldCoeff(Daughter.GetFieldCoeff()[i], i);
#endif
  KFParticleBase::AddDaughter( Daughter );
}

inline void KFParticle::Construct( const KFParticle *vDaughters[], int nDaughters, 
                                   const KFParticle *ProdVtx,   float Mass )
{    
  /** Constructs a short-lived particle from a set of daughter particles:\n
   ** 1) all parameters of the "this" objects are initialised;\n
   ** 2) daughters are added one after another;\n
   ** 3) if Parent pointer is not null, the production vertex is set to it;\n
   ** 4) if Mass hypothesis >=0 the mass constraint is set.
   ** \param[in] vDaughters - array of daughter particles
   ** \param[in] nDaughters - number of daughter particles in the input array
   ** \param[in] Parent - optional parrent particle
   ** \param[in] Mass - optional mass hypothesis
   **/  
#ifdef NonhomogeneousField
  for(int i=0; i<10; i++)
    SetFieldCoeff(vDaughters[0]->GetFieldCoeff()[i], i);
#endif
  KFParticleBase::Construct( ( const KFParticleBase**)vDaughters, nDaughters, 
                             ( const KFParticleBase*)ProdVtx, Mass );
}

inline void KFParticle::TransportToPoint( const float xyz[] )
{ 
  /** Transports particle to the distance of closest approach to the point xyz.
   ** \param[in] xyz[3] - point, where particle should be transported
   **/
  float dsdr[6] = {0.f};
  float dS = GetDStoPoint(xyz, dsdr);
  TransportToDS( dS, dsdr );
}
#ifdef HomogeneousField
inline void KFParticle::TransportToVertex( const KFPVertex &v )
{ 
  /** Transports particle to the distance of closest approach to the vertex v.
   ** \param[in] v - vertex, where particle should be transported
   **/
  TransportToPoint( KFParticle(v).fP );
}
#endif
inline void KFParticle::TransportToParticle( const KFParticle &p )
{ 
  /** Transports particle to the distance of closest approach to the particle p.
   ** \param[in] p - particle, to which the current particle should be transported.
   **/
  float dsdr[4][6];
  float dS[2];
  GetDStoParticle( p, dS, dsdr );
  TransportToDS( dS[0], dsdr[0] );
}

inline float KFParticle::GetDStoPoint( const float xyz[], float* dsdr ) const 
{
  /** Returns dS = l/p parameter, where \n
   ** 1) l - signed distance to the DCA point with the input xyz point;\n
   ** 2) p - momentum of the particle; \n
   ** Also calculates partial derivatives dsdr of the parameter dS over the state vector of the current particle.
   ** If "HomogeneousField" is defined KFParticleBase::GetDStoPointBz() is called,
   ** if "NonhomogeneousField" is defined - KFParticleBase::GetDStoPointCBM()
   ** \param[in] xyz[3] - point, to which particle should be transported
   ** \param[out] dsdr[6] = ds/dr partial derivatives of the parameter dS over the state vector of the current particle
   ** \param[in] param - optional parameter, is used in case if the parameters of the particle are rotated
   ** to other coordinate system (see GetDStoPointBy() function), otherwise fP are used
   **/
#ifdef HomogeneousField
  return KFParticleBase::GetDStoPointBz( GetFieldAlice(), xyz, dsdr );
#endif
#ifdef NonhomogeneousField
  return KFParticleBase::GetDStoPointCBM( xyz, dsdr );
#endif
}

#ifdef HomogeneousField
inline float KFParticle::GetFieldAlice()
{ 
  /** Returns value of the constant homogemeous one-component magnetic field Bz, (is defined in case of #ifdef HomogeneousField). */
  return fgBz; 
}
#endif

#ifdef HomogeneousField
inline void KFParticle::GetFieldValue( const float * /*xyz*/, float B[] ) const 
{    
  /** Calculates the Bx, By, Bz components at the point xyz using approximation of the
   ** magnetic field along the particle trajectory.
   ** \param[in] xyz[3] - X, Y, Z coordiantes of the point where the magnetic field should be calculated
   ** \param[out] B[3] - value of X, Y, Z components of the calculated magnetic field at the given point
   **/
  
  B[0] = B[1] = 0;
  B[2] = GetFieldAlice();
}
#endif

#ifdef NonhomogeneousField
inline void KFParticle::GetFieldValue( const float xyz[], float B[] ) const 
{
  /** Calculates the Bx, By, Bz components at the point xyz using approximation of the
   ** magnetic field along the particle trajectory.
   ** \param[in] xyz[3] - X, Y, Z coordiantes of the point where the magnetic field should be calculated
   ** \param[out] B[3] - value of X, Y, Z components of the calculated magnetic field at the given point
   **/
  
  const float dz = (xyz[2]-fieldRegion[9]);
  const float dz2 = dz*dz;

  B[0] = fieldRegion[0] + fieldRegion[1]*dz + fieldRegion[2]*dz2;
  B[1] = fieldRegion[3] + fieldRegion[4]*dz + fieldRegion[5]*dz2;
  B[2] = fieldRegion[6] + fieldRegion[7]*dz + fieldRegion[8]*dz2;
}
#endif

inline void KFParticle::GetDStoParticle( const KFParticleBase &p, float dS[2], float dsdr[4][6] ) const
{ 
  /** Calculates dS = l/p parameters for two particles, where \n
   ** 1) l - signed distance to the DCA point with the other particle;\n
   ** 2) p - momentum of the particle \n
   ** dS[0] is the transport parameter for the current particle, dS[1] - for the particle "p".
   ** Also calculates partial derivatives dsdr of the parameters dS[0] and dS[1] over the state vectors of the particles:\n
   ** 1) dsdr[0][6] = d(dS[0])/d(param1);\n
   ** 2) dsdr[1][6] = d(dS[0])/d(param2);\n
   ** 3) dsdr[2][6] = d(dS[1])/d(param1);\n
   ** 4) dsdr[3][6] = d(dS[1])/d(param2);\n
   ** where param1 are parameters of the current particle fP and
   ** param2 are parameters of the second particle p.fP. If "HomogeneousField" is defined KFParticleBase::GetDStoParticleBz() is called,
   ** if "NonhomogeneousField" is defined - KFParticleBase::GetDStoParticleCBM()
   ** \param[in] p - second particle
   ** \param[out] dS[2] - transport parameters dS for the current particle (dS[0]) and the second particle "p" (dS[1])
   ** \param[out] dsdr[4][6] - partial derivatives of the parameters dS[0] and dS[1] over the state vectors of the both particles
   **/
#ifdef HomogeneousField
  KFParticleBase::GetDStoParticleBz( GetFieldAlice(), p, dS, dsdr ) ;
#endif
#ifdef NonhomogeneousField
  KFParticleBase::GetDStoParticleCBM( p, dS, dsdr ) ;
#endif
}

inline void KFParticle::Transport( float dS, const float* dsdr, float P[], float C[], float* dsdr1, float* F, float* F1 ) const 
{
  /** Transports the parameters and their covariance matrix of the current particle
   ** on a length defined by the transport parameter dS = l/p, where l is the signed distance and p is 
   ** the momentum of the current particle. If "HomogeneousField" is defined KFParticleBase::TransportBz()
   ** is called, if "NonhomogeneousField" - KFParticleBase::TransportCBM().
   ** The obtained parameters and covariance matrix are stored to the arrays P and 
   ** C respectively. P and C can be set to the parameters fP and covariance matrix fC of the current particle. In this
   ** case the particle parameters will be modified. Dependence of the transport parameter dS on the state vector of the
   ** current particle is taken into account in the covariance matrix using partial derivatives dsdr = d(dS)/d(fP). If
   ** a pointer to F is initialised the transport jacobian F = d(fP new)/d(fP old) is stored.
   ** Since dS can depend on the state vector r1 of other particle or vertex, the corelation matrix 
   ** F1 = d(fP new)/d(r1) can be optionally calculated if a pointer F1 is provided.
   *  Parameters F and F1 should be either both initialised or both set to null pointer.
   ** \param[in] dS - transport parameter which defines the distance to which particle should be transported
   ** \param[in] dsdr[6] = ds/dr - partial derivatives of the parameter dS over the state vector of the current particle
   ** \param[out] P[8] - array, where transported parameters should be stored
   ** \param[out] C[36] - array, where transported covariance matrix (8x8) should be stored in the lower triangular form 
   ** \param[in] dsdr1[6] = ds/dr - partial derivatives of the parameter dS over the state vector of another particle 
   ** or vertex
   ** \param[out] F[36] - optional parameter, transport jacobian, 6x6 matrix F = d(fP new)/d(fP old)
   ** \param[out] F1[36] - optional parameter, corelation 6x6 matrix betweeen the current particle and particle or vertex
   ** with the state vector r1, to which the current particle is being transported, F1 = d(fP new)/d(r1)
   **/ 
#ifdef HomogeneousField
  KFParticleBase::TransportBz( GetFieldAlice(), dS, dsdr, P, C, dsdr1, F, F1 );
#endif
#ifdef NonhomogeneousField
  KFParticleBase::TransportCBM( dS, dsdr, P, C, dsdr1, F, F1 );
#endif
}

#endif 
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifndef KFVERTEX_H
#define KFVERTEX_H

#include "KFParticle.h"
#include "KFPVertex.h"

/** @class KFVertex
 ** @brief Mathematics for reconstruction of primary vertices based on KFParticle.
 ** @author  S.Gorbunov, I.Kisel, M.Zyzak
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** The class is inherited from KFParticle, adds functionality for reconstruction of
 ** primary vertices.
 **/

class KFVertex : public KFParticle
{
 public:

  KFVertex():KFParticle(),fIsConstrained(0){ } 
  KFVertex( const KFParticle &particle ): KFParticle(particle), fIsConstrained(0) {} ///< Vertex is constructed from the current position of a given particle.
  KFVertex( const KFPVertex &vertex );
  ~KFVertex(){}

  Int_t GetNContributors() const { return fIsConstrained ?fNDF/2:(fNDF+3)/2; } ///< Returns number of particles used for construction of the vertex.


  void operator +=( const KFParticle &Daughter );  ///< Adds particle to a vertex.
  KFVertex operator -( const KFParticle &Daughter ) const; ///< Subtracts particle from a vertex, returns temporary object. Initial vertex stays untouched.
  void operator -=( const KFParticle &Daughter );  ///< Subtracts particle from a current vertex.

  void SetBeamConstraint( float X, float Y, float Z, 
                          float ErrX, float ErrY, float ErrZ );
  void SetBeamConstraintOff();

  void ConstructPrimaryVertex( const KFParticle *vDaughters[], int nDaughters,
                               Bool_t vtxFlag[], float ChiCut=3.5  );

 protected:

  Bool_t fIsConstrained; ///< Flag showing if the the beam constraint is set
  
#ifndef KFParticleStandalone
  ClassDef( KFVertex, 2 )
#endif
};


//---------------------------------------------------------------------
//
//     Inline implementation of the KFVertex methods
//
//---------------------------------------------------------------------


inline void KFVertex::operator+=( const KFParticle &Daughter )
{
  KFParticle::operator+=( Daughter );
}
  

inline void KFVertex::operator-=( const KFParticle &Daughter )
{
  Daughter.SubtractFromVertex( *this );
}
  
inline KFVertex KFVertex::operator-( const KFParticle &Daughter ) const 
{
  KFVertex tmp = *this;
  Daughter.SubtractFromVertex( tmp );
  return tmp;
}


#endif 
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef KFPartEfficiencies_H
#define KFPartEfficiencies_H

#include <map>
#include <iomanip>
#include "KFMCCounter.h"

#ifdef HLTCA_STANDALONE
#include "RootTypesDef.h"
#else
#include "TObject.h"
#endif

/** @class KFEfficiencyParticleInfo
 ** @brief A helper class to define parameters of the decay list in KFPartEfficiencies.
 ** @author  M.Zyzak, I.Kisel
 ** @date 05.02.2019
 ** @version 1.0
 **/

class KFEfficiencyParticleInfo
{
 public:
  KFEfficiencyParticleInfo():fName("null"),fTitle("null"),fPDG(0),fHistoMin(0.f),fHistoMax(0.f),fMass(0.f),fLifeTime(0.f),fCharge(0), fMassSigma(0.001) {};
  /** \brief Constructor with all parameters set in. There is no other way to define the parameters other then use this constructor.*/
  KFEfficiencyParticleInfo(std::string name, std::string title, int pdg, float histoMin, float histoMax, float mass, float lifeTime, int charge, float massSigma ):
    fName(name), fTitle(title), fPDG(pdg), fHistoMin(histoMin), fHistoMax(histoMax), fMass(mass), fLifeTime(lifeTime), fCharge(charge), fMassSigma(massSigma) {};
  ~KFEfficiencyParticleInfo() {};
  
  //accessors
  std::string Name()      const { return fName; }      ///< Returns name of the decay in the file with histograms.
  std::string Title()     const { return fTitle; }     ///< Returns name of the decay in the output table with efficiency.
  int         PDG()       const { return fPDG; }       ///< Returns the assigned PDG code.
  float       HistoMin()  const { return fHistoMin; }  ///< Returns lower boundary in the mass histogram for the current decay.
  float       HistoMax()  const { return fHistoMax; }  ///< Returns upper boundary in the mass histogram for the current decay.
  float       Mass()      const { return fMass; }      ///< Returns table mass of the particle.
  float       LifeTime()  const { return fLifeTime; }  ///< Returns lifetime of the particle.
  int         Charge()    const { return fCharge; }    ///< Returns charge of the particle in units of the elementary charge.
  float       MassSigma() const { return fMassSigma; } ///< Returns expected width of the mass peak, used in the side bands method.
  
 private:
  std::string fName;  ///< Name of the decay in the file with histograms.
  std::string fTitle; ///< Name of the decay in the output table with efficiency.
  int fPDG;           ///< PDG code assigned to the current decay in the scheme of KF Particle Finder.
  float fHistoMin;    ///< Lower boundary in the mass histogram for the current decay.
  float fHistoMax;    ///< Upper boundary in the mass histogram for the current decay.
  float fMass;        ///< Table mass of the particle.
  float fLifeTime;    ///< Lifetime of the particle in seconds.
  int fCharge;        ///< Charge in units of the elementary charge.
  float fMassSigma;   ///< Expected width of the decay, determines peak sigma for the side bands method.
};

/** @class KFPartEfficiencies
 ** @brief Class to calculate efficiency of KF Particle Finder.
 ** @author  M.Zyzak, I.Kisel
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** The class has two main purposes:\n
 ** 1) Defines the list of decays to be analysed: a unique code of the decay, its mass, lifetime,
 ** a list of daughter particles, etc. See KFPartEfficiencies::KFPartEfficiencies() for more details.\n
 ** 2) It calculates reconstruction efficiency of the decays from the KF Particle Finder scheme.\n
 ** Definitions:\n
 ** background - physics background, when daughter particle come from the real particle, but the pdg
 ** hypothesis is incorrect, for example, Lambda->p pi will create a physics background for
 ** K0s if the proton is misidentified;\n
 ** ghost - combinatorial background, tracks do not form a real vertex;\n
 ** clone - a particle is reconstructed several times, for example, particle track is split into 
 ** to parts due to the multiple scattering.
 **/

class KFPartEfficiencies :public TObject
{
 public:

  /** \brief The default constructor. Defines the list of decays to be analysed and their properties. Please, see the code for indexing scheme. */
  KFPartEfficiencies():
    partDaughterPdg(0),
    names(),
    indices(),
    fPdgToIndex(),
    ratio_reco1(),
    ratio_reco2(),
    ratio_reco3(),
    mc1(),
    mc2(),
    mc3(),
    reco(),
    ratio_ghost(),
    ratio_bg(),
    ratio_clone(),
    ghost(),
    bg(),
    clone()
  {                                    
    KFEfficiencyParticleInfo particleInfo[nParticles] = 
    {
      //                       name                title               PDG code   min   max    mass       lifetime    Q
#ifdef CBM
      KFEfficiencyParticleInfo("Ks",               "KShort        ",        310, 0.3f, 1.3f, 0.497614   , 8.954e-11,  0, 0.0045), //0
#else
      KFEfficiencyParticleInfo("Ks",               "KShort        ",        310, 0.3f, 1.3f, 0.497614   , 8.954e-11,  0, 0.0057), //0
#endif
      KFEfficiencyParticleInfo("Lambda",           "Lambda        ",       3122, 1.0f, 2.0f, 1.115683   , 2.632e-10,  0, 0.0020), //1
      KFEfficiencyParticleInfo("Lambdab",          "Lambda b      ",      -3122, 1.0f, 2.0f, 1.115683   , 2.632e-10,  0, 0.0020), //2
      KFEfficiencyParticleInfo("Xi-",              "Xi-           ",       3312, 1.0f, 3.0f, 1.32171    , 1.639e-10, -1, 0.0022), //3
      KFEfficiencyParticleInfo("Xi+",              "Xi+           ",      -3312, 1.0f, 3.0f, 1.32171    , 1.639e-10,  1, 0.0022), //4
      KFEfficiencyParticleInfo("Xi0",              "Xi0           ",       3322, 1.0f, 3.0f, 1.31486    , 2.9e-10,    0, 0.0030), //5
      KFEfficiencyParticleInfo("Xi0b",             "Xi0 b         ",      -3322, 1.0f, 3.0f, 1.31486    , 2.9e-10,    0, 0.0030), //6
      KFEfficiencyParticleInfo("Omega-",           "Omega-        ",       3334, 1.0f, 3.0f, 1.67245    , 0.821e-10, -1, 0.0022), //7
      KFEfficiencyParticleInfo("Omega+",           "Omega+        ",      -3334, 1.0f, 3.0f, 1.67245    , 0.821e-10,  1, 0.0022), //8
      KFEfficiencyParticleInfo("Sigma^0",          "Sigma0        ",       3212, 1.0f, 3.0f, 1.192642   , 7.4e-20,    0, 0.0030), //9
      KFEfficiencyParticleInfo("Sigma^0b",         "Sigma0 b      ",      -3212, 1.0f, 3.0f, 1.192642   , 7.4e-20,    0, 0.0030), //10
      KFEfficiencyParticleInfo("Sigma^+",          "Sigma+        ",       3222, 1.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0030), //11
      KFEfficiencyParticleInfo("Sigma^-b",         "Sigma- b      ",      -3222, 1.0f, 3.0f, 1.18937    , 0.8018e-10,-1, 0.0030), //12
      KFEfficiencyParticleInfo("K*0",              "K*0           ",        313, 0.6f, 2.6f, 0.8958     , 1.38e-23,   0, 0.0300), //13
      KFEfficiencyParticleInfo("K*0b",             "K*0 b         ",       -313, 0.6f, 2.6f, 0.8958     , 1.38e-23,   0, 0.0300), //14
      KFEfficiencyParticleInfo("K*+",              "K*+           ",        323, 0.6f, 2.6f, 0.89166    , 1.30e-23,   1, 0.0300), //15
      KFEfficiencyParticleInfo("K*-",              "K*-           ",       -323, 0.6f, 2.6f, 0.89166    , 1.30e-23,  -1, 0.0300), //16
      KFEfficiencyParticleInfo("K*0_K0,pi0",       "K*0_K0pi0     ",     100313, 0.6f, 2.6f, 0.8958     , 1.38e-23,   0, 0.0030), //17
      KFEfficiencyParticleInfo("K*+_K+,pi0",       "K*+_K+pi0     ",     100323, 0.6f, 2.6f, 0.89166    , 1.30e-23,   1, 0.0030), //18
      KFEfficiencyParticleInfo("K*-_K-,pi0",       "K*-_K-pi0     ",    -100323, 0.6f, 2.6f, 0.89166    , 1.30e-23,  -1, 0.0030), //19
      KFEfficiencyParticleInfo("Sigma*+",          "Sigma*+       ",       3224, 1.0f, 3.0f, 1.3828     , 1.83e-23,   1, 0.0100), //20
      KFEfficiencyParticleInfo("Sigma*-",          "Sigma*-       ",       3114, 1.0f, 3.0f, 1.3872     , 1.67e-23,  -1, 0.0100), //21
      KFEfficiencyParticleInfo("Sigma*+b",         "Sigma*+ b     ",      -3114, 1.0f, 3.0f, 1.3828     , 1.83e-23,  -1, 0.0100), //22
      KFEfficiencyParticleInfo("Sigma*-b",         "Sigma*- b     ",      -3224, 1.0f, 3.0f, 1.3872     , 1.67e-23,   1, 0.0100), //23
      KFEfficiencyParticleInfo("Sigma*0",          "Sigma*0       ",       3214, 1.0f, 3.0f, 1.3837     , 1.83e-23,   0, 0.0030), //24
      KFEfficiencyParticleInfo("Sigma*0b",         "Sigma*0 b     ",      -3214, 1.0f, 3.0f, 1.3837     , 1.83e-23,   0, 0.0030), //25
      KFEfficiencyParticleInfo("Lambda*",          "Lambda*       ",       3124, 1.4f, 3.4f, 1.5195     , 4.22e-23,   0, 0.0100), //26
      KFEfficiencyParticleInfo("Lambda*b",         "Lambda* b     ",      -3124, 1.4f, 3.4f, 1.5195     , 4.22e-23,   0, 0.0100), //27
      KFEfficiencyParticleInfo("Xi*0",             "Xi*0          ",       3324, 1.4f, 3.4f, 1.53180    , 7.23e-23,   0, 0.0100), //28
      KFEfficiencyParticleInfo("Xi*0b",            "Xi*0 b        ",      -3324, 1.4f, 3.4f, 1.53180    , 7.23e-23,   0, 0.0100), //29
      KFEfficiencyParticleInfo("Xi*-_LK",          "Xi*-_lk       ",    1003314, 1.4f, 3.4f, 1.823      , 2.74e-23,  -1, 0.0030), //30
      KFEfficiencyParticleInfo("Xi*+_LK",          "Xi*+_lk       ",   -1003314, 1.4f, 3.4f, 1.823      , 2.74e-23,   1, 0.0030), //31
      KFEfficiencyParticleInfo("Xi*-_xi-,pi0",     "Xi*-_XiPi     ",       3314, 1.4f, 3.4f, 1.535      , 6.65e-23,  -1, 0.0030), //32
      KFEfficiencyParticleInfo("Xi*+_xi+,pi0",     "Xi*+_XiPi     ",      -3314, 1.4f, 3.4f, 1.535      , 6.65e-23,   1, 0.0030), //33
      KFEfficiencyParticleInfo("Omega*-",          "Omega*-       ",    1003334, 1.8f, 3.8f, 2.252      , 1.2e-23,   -1, 0.0030), //34
      KFEfficiencyParticleInfo("Omega*+",          "Omega*+       ",   -1003334, 1.8f, 3.8f, 2.252      , 1.2e-23,    1, 0.0030), //35
      KFEfficiencyParticleInfo("H0_LL",            "H0_LL         ",       3000, 1.5f, 3.5f, 2.21       , 1.32e-10,   0, 0.0030), //36
      KFEfficiencyParticleInfo("phi_KK",           "phi_KK        ",        333, 0.8f, 2.8f, 1.019455   , 1.55e-22,   0, 0.0030), //37
      KFEfficiencyParticleInfo("rho_pipi",         "rho_pipi      ",        113, 0.0f, 2.0f, 0.77526    , 4.45e-24,   0, 0.0030), //38
      KFEfficiencyParticleInfo("rho_ee",           "rho_ee        ",     100113, 0.0f, 2.0f, 0.77526    , 4.45e-24,   0, 0.0030), //39
      KFEfficiencyParticleInfo("rho_mm",           "rho_mm        ",     200113, 0.0f, 2.0f, 0.77526    , 4.45e-24,   0, 0.0030), //40
      KFEfficiencyParticleInfo("gamma",            "gamma         ",         22, 0.0f, 3.0f, 0.         , 1.e20,      0, 0.0030), //41
      KFEfficiencyParticleInfo("pi0",              "pi0           ",        111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //42
      KFEfficiencyParticleInfo("eta",              "eta           ",        221, 0.0f, 3.0f, 0.547862   , 5.0e-19,    0, 0.0030), //43
//Delta and N resonances
      KFEfficiencyParticleInfo("Delta0",           "Delta0        ",       2114, 1.0f, 3.0f, 1.232      , 5.63e-24,   0, 0.0030), //44
      KFEfficiencyParticleInfo("Delta0 b",         "Delta0 b      ",      -2114, 1.0f, 3.0f, 1.232      , 5.63e-24,   0, 0.0030), //45
      KFEfficiencyParticleInfo("Delta++",          "Delta++       ",       2224, 1.0f, 3.0f, 1.232      , 5.63e-24,   2, 0.0030), //46
      KFEfficiencyParticleInfo("Delta-- b",        "Delta-- b     ",      -2224, 1.0f, 3.0f, 1.232      , 5.63e-24,  -2, 0.0030), //47
//charmonium
      KFEfficiencyParticleInfo("JPsi_ee",          "JPsi_ee       ",        443, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //48
      KFEfficiencyParticleInfo("JPsi_mumu",        "JPsi_mm       ",     100443, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //49
      KFEfficiencyParticleInfo("JPsi_pp",          "JPsi_pp       ",     200443, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //50
      KFEfficiencyParticleInfo("JPsi_LL",          "JPsi_LL       ",     300443, 2.0f, 5.0f, 3.096916   , 7.1e-21,    0, 0.0030), //51
      KFEfficiencyParticleInfo("JPsi_XiXi",        "JPsi_XiXi     ",     400443, 2.0f, 5.0f, 3.096916   , 7.1e-21,    0, 0.0030), //52
      KFEfficiencyParticleInfo("Psi_OO",           "Psi_OO        ",     500443, 3.0f, 6.0f, 3.686109   , 2.1e-22,    0, 0.0030), //53
//open charm
      KFEfficiencyParticleInfo("D0",               "D0            ",        421, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //54
      KFEfficiencyParticleInfo("D0b",              "D0b           ",       -421, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //55
      KFEfficiencyParticleInfo("D0_4",             "D0_4          ",        429, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0100), //56
      KFEfficiencyParticleInfo("D0b_4",            "D0b_4         ",       -429, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0100), //57
      KFEfficiencyParticleInfo("D0_pipi",          "D0_pipi       ",        420, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //58
      KFEfficiencyParticleInfo("D0_2pi2pi",        "D0_2pi2pi     ",        470, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //59
      KFEfficiencyParticleInfo("D0_K0pipi",        "D0_K0pipi     ",        425, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0150), //60
      KFEfficiencyParticleInfo("D0_KK",            "D0_KK         ",        426, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0130), //61
      KFEfficiencyParticleInfo("D0_KKK0",          "D0_KKK0       ",        427, 0.6f, 3.6f, 1.86486    , 4.1e-13,    0, 0.0154), //62
      KFEfficiencyParticleInfo("D0_pi0",           "D0_#pi0       ",        428, 1.0f, 3.0f, 1.86486    , 4.1e-13,    0, 0.0030), //63
      KFEfficiencyParticleInfo("D+",               "D+            ",        411, 1.0f, 3.0f, 1.86962    , 1.04e-13,   1, 0.0114), //64
      KFEfficiencyParticleInfo("D-",               "D-            ",       -411, 1.0f, 3.0f, 1.86962    , 1.04e-13,  -1, 0.0114), //65
      KFEfficiencyParticleInfo("D+_K0pi+",         "D+_K0pi+      ",     100411, 0.6f, 4.6f, 1.86962    , 1.04e-13,   1, 0.0030), //66
      KFEfficiencyParticleInfo("D-_K0pi-",         "D-_K0pi-      ",    -100411, 0.6f, 4.6f, 1.86962    , 1.04e-13,  -1, 0.0030), //67
      KFEfficiencyParticleInfo("D+_K03pi",         "D+_K03pi      ",     200411, 0.6f, 4.6f, 1.86962    , 1.04e-13,   1, 0.0030), //68
      KFEfficiencyParticleInfo("D-_K03pi",         "D-_K03pi      ",    -200411, 0.6f, 4.6f, 1.86962    , 1.04e-13,  -1, 0.0030), //69
      KFEfficiencyParticleInfo("D+_3pi",           "D+_3pi        ",     300411, 0.6f, 4.6f, 1.86962    , 1.04e-13,   1, 0.0030), //70
      KFEfficiencyParticleInfo("D-_3pi",           "D-_3pi        ",    -300411, 0.6f, 4.6f, 1.86962    , 1.04e-13,  -1, 0.0030), //71
      KFEfficiencyParticleInfo("Ds+",              "Ds+           ",        431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0110), //72
      KFEfficiencyParticleInfo("Ds-",              "Ds-           ",       -431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0110), //73
      KFEfficiencyParticleInfo("Ds+_K0K+",         "Ds+_K0K+      ",     100431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0030), //74
      KFEfficiencyParticleInfo("Ds-_K0K-",         "Ds-_K0K-      ",    -100431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0030), //75
      KFEfficiencyParticleInfo("Ds+_K0K0pi+",      "Ds+_K0K0pi+   ",     200431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0030), //76
      KFEfficiencyParticleInfo("Ds-_K0K0pi-",      "Ds-_K0K0pi-   ",    -200431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0030), //77
      KFEfficiencyParticleInfo("Ds+_K0K+pipi",     "Ds+_K0K+pipi  ",     300431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0030), //78
      KFEfficiencyParticleInfo("Ds-_K0K-pipi",     "Ds-_K0K-pipi  ",    -300431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0030), //79
      KFEfficiencyParticleInfo("Ds+_K+pipi",       "Ds+_K+pipi    ",     400431, 1.0f, 3.0f, 1.96850    , 5.0e-13,    1, 0.0030), //80
      KFEfficiencyParticleInfo("Ds-_K-pipi",       "Ds-_K-pipi    ",    -400431, 1.0f, 3.0f, 1.96850    , 5.0e-13,   -1, 0.0030), //81
      KFEfficiencyParticleInfo("Lc",               "Lambdac       ",       4122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0110), //82
      KFEfficiencyParticleInfo("Lcb",              "Lambdac b     ",      -4122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0110), //83
      KFEfficiencyParticleInfo("Lc_{pK0}",         "Lc   {pK0}    ",     104122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //84
      KFEfficiencyParticleInfo("Lcb_{pK0}",        "Lc b {pK0}    ",    -104122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //85
      KFEfficiencyParticleInfo("Lc_{pK02pi}",      "Lc   {pK02pi} ",     204122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //86
      KFEfficiencyParticleInfo("Lcb_{pK02pi}",     "Lc b {pK02pi} ",    -204122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //87
      KFEfficiencyParticleInfo("Lc_{Lpi}",         "Lc   {Lpi}    ",     304122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //88
      KFEfficiencyParticleInfo("Lcb_{Lpi}",        "Lc b {Lpi}    ",    -304122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //89
      KFEfficiencyParticleInfo("Lc_{L3pi}",        "Lc   {L3pi}   ",     404122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //90
      KFEfficiencyParticleInfo("Lcb_{L3pi}",       "Lc b {L3pi}   ",    -404122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //91
      KFEfficiencyParticleInfo("Lc_{p2pi}",        "Lc   {p2pi}   ",     504122, 1.8f, 3.8f, 2.28646    , 2.0e-13,    1, 0.0030), //92
      KFEfficiencyParticleInfo("Lcb_{p2pi}",       "Lc b {p2pi}   ",    -504122, 1.8f, 3.8f, 2.28646    , 2.0e-13,   -1, 0.0030), //93  
      KFEfficiencyParticleInfo("Xic0",             "Xic0          ",       4132, 2.1f, 4.1f, 2.47087    , 1.0e-13,    0, 0.0030), //94
      KFEfficiencyParticleInfo("Xic0b",            "Xic0b         ",      -4132, 2.1f, 4.1f, 2.47087    , 1.0e-13,    0, 0.0030), //95  
      KFEfficiencyParticleInfo("D*0",              "D*0           ",      10421, 1.8f, 3.8f, 2.00699    , 3.0e-22,    0, 0.0030), //96
      KFEfficiencyParticleInfo("D*0b",             "D*0 b         ",     -10421, 1.8f, 3.8f, 2.00699    , 3.0e-22,    0, 0.0030), //97
      KFEfficiencyParticleInfo("D*+",              "D*+           ",      10411, 1.8f, 3.8f, 2.01029    , 6.86e-21,   1, 0.0030), //98
      KFEfficiencyParticleInfo("D*-",              "D*-           ",     -10411, 1.8f, 3.8f, 2.01029    , 6.86e-21,  -1, 0.0030), //99
      KFEfficiencyParticleInfo("D*+_4",            "D*+_4         ",      20411, 1.8f, 3.8f, 2.01029    , 6.86e-21,   1, 0.0030), //100
      KFEfficiencyParticleInfo("D*-_4",            "D*-_4         ",     -20411, 1.8f, 3.8f, 2.01029    , 6.86e-21,  -1, 0.0030), //101
      KFEfficiencyParticleInfo("D0*_pi0",          "D0*_#pi0      ",      10428, 1.8f, 3.8f, 2.00699    , 6.86e-21,   0, 0.0030), //102
//B mesons
      KFEfficiencyParticleInfo("B_Jpsi_ee",        "B_Jpsi_ee     ",        500, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //103
      KFEfficiencyParticleInfo("B_Jpsi_mm",        "B_Jpsi_mm     ",        501, 1.0f, 4.0f, 3.096916   , 7.1e-21,    0, 0.0030), //104
      KFEfficiencyParticleInfo("B+_D0bPi+",        "B+ {D0bPi+}   ",        521, 3.0f, 7.0f, 5.27931    , 1.638e-12,  0, 0.0030), //105
      KFEfficiencyParticleInfo("B-_D0Pi-",         "B- {D0Pi-}    ",       -521, 3.0f, 7.0f, 5.27931    , 1.638e-12,  0, 0.0030), //106
      KFEfficiencyParticleInfo("B+_D0bK+",         "B+ {D0bK+}    ",        529, 3.0f, 7.0f, 5.27931    , 1.638e-12,  0, 0.0030), //107
      KFEfficiencyParticleInfo("B-_D0K-",          "B- {D0K+}     ",       -529, 3.0f, 7.0f, 5.27931    , 1.638e-12,  0, 0.0030), //108
      KFEfficiencyParticleInfo("B0_D-Pi+",         "B0 {D-Pi+}    ",        511, 3.0f, 7.0f, 5.27962    , 1.520e-12,  0, 0.0030), //109
      KFEfficiencyParticleInfo("B0b_D+Pi-",        "B0b {D+Pi-}   ",       -511, 3.0f, 7.0f, 5.27962    , 1.520e-12,  0, 0.0030), //110
      KFEfficiencyParticleInfo("B0_D-K+",          "B0 {D-K+}     ",        519, 3.0f, 7.0f, 5.27962    , 1.520e-12,  0, 0.0030), //111
      KFEfficiencyParticleInfo("B0b_D+K-",         "B0b {D+K-}    ",       -519, 3.0f, 7.0f, 5.27962    , 1.520e-12,  0, 0.0030), //112
      KFEfficiencyParticleInfo("H0_{Lppi}",        "H0            ",       3001, 2.0f, 4.0f, 2.21       , 1.32e-10,   0, 0.0030), //113
//hypernuclei
      KFEfficiencyParticleInfo("LambdaN",          "LambdaN       ",       3003, 1.0f, 3.0f, 2.05395    , 1.00e-10,   0, 0.0030), //114
      KFEfficiencyParticleInfo("LambdaNb",         "LambdaN b     ",      -3003, 1.0f, 3.0f, 2.05395    , 1.00e-10,   0, 0.0030), //115
      KFEfficiencyParticleInfo("LambdaNN",         "LambdaNN      ",       3103, 2.0f, 4.0f, 2.99352    , 1.00e-10,   0, 0.0030), //116
      KFEfficiencyParticleInfo("LambdaNNb",        "LambdaNN b    ",      -3103, 2.0f, 4.0f, 2.99352    , 1.00e-10,   0, 0.0030), //117
      KFEfficiencyParticleInfo("H3L",              "H3L           ",       3004, 2.0f, 4.0f, 2.99339    , 1.85e-10,   1, 0.0030), //118
      KFEfficiencyParticleInfo("H3Lb",             "H3L b         ",      -3004, 2.0f, 4.0f, 2.99339    , 1.85e-10,  -1, 0.0030), //119
      KFEfficiencyParticleInfo("H4L",              "H4L           ",       3005, 3.0f, 5.0f, 3.92975    , 1.80e-10,   1, 0.0030), //120
      KFEfficiencyParticleInfo("H4Lb",             "H4L b         ",      -3005, 3.0f, 5.0f, 3.92975    , 1.80e-10,  -1, 0.0030), //121
      KFEfficiencyParticleInfo("He4L",             "He4L          ",       3006, 3.0f, 5.0f, 3.93070    , 1.50e-10,   2, 0.0030), //122
      KFEfficiencyParticleInfo("He4Lb",            "He4L b        ",      -3006, 3.0f, 5.0f, 3.93070    , 1.50e-10,  -2, 0.0030), //123
      KFEfficiencyParticleInfo("He5L",             "He5L          ",       3007, 4.0f, 6.0f, 4.86824    , 1.40e-10,   2, 0.0030), //124
      KFEfficiencyParticleInfo("He5Lb",            "He5L b        ",      -3007, 4.0f, 6.0f, 4.86824    , 1.40e-10,  -2, 0.0030), //125
      KFEfficiencyParticleInfo("LLn",              "LLn           ",       3203, 3.0f, 5.0f, 3.16964    , 1.00e-10,   0, 0.0030), //126
      KFEfficiencyParticleInfo("H4LL_{He4Lpi-}",   "H4LL_{He4Lpi-}",       3008, 3.0f, 5.0f, 4.10791    ,  1.0e-10,   1, 0.0030), //127
      KFEfficiencyParticleInfo("H4LL_{H3Lppi-}",   "H4LL_{H3Lppi-}",       3009, 3.0f, 5.0f, 4.10791    ,  1.0e-10,   1, 0.0030), //128
      KFEfficiencyParticleInfo("H5LL_{He5Lpi-}",   "H5LL_{He5Lpi-}",       3010, 4.0f, 6.0f, 5.04748    ,  1.0e-10,   1, 0.0030), //129
      KFEfficiencyParticleInfo("He6LL",            "He6LL         ",       3011, 5.0f, 7.0f, 5.98575    ,  1.0e-10,   2, 0.0030), //130
//missing mass method      
      KFEfficiencyParticleInfo("pi-_{mu,nu}",      "pi-_{mnu}     ",   -7000211,-1.0f, 1.0f, 0.139570   , 2.6e-8,    -1, 0.0030), //131
      KFEfficiencyParticleInfo("nu_{pi-}",         "nu_{mupi-} b  ",   -7000014,-1.0f, 1.0f, 0.         , 1.0e20,     0, 0.0030), //132
      KFEfficiencyParticleInfo("pi+_{mu,nu}",      "pi+_{mnu}     ",    7000211,-1.0f, 1.0f, 0.139570   , 2.6e-8,     1, 0.0030), //133
      KFEfficiencyParticleInfo("nu_{pi+}",         "nu_{mupi+}    ",    7000014,-1.0f, 1.0f, 0.         , 1.0e20,     0, 0.0030), //134
      KFEfficiencyParticleInfo("K-_{mu,nu}",       "K-_{mnu}      ",   -7000321,-1.0f, 1.0f, 0.493677   , 1.238e-8,  -1, 0.0030), //135
      KFEfficiencyParticleInfo("nu_{K-}",          "nu_{K-} b     ",   -8000014,-1.0f, 1.0f, 0.         , 1.0e20,     0, 0.0030), //136
      KFEfficiencyParticleInfo("K+_{mu,nu}",       "K+_{mnu}      ",    7000321,-1.0f, 1.0f, 0.493677   , 1.238e-8,   1, 0.0030), //137
      KFEfficiencyParticleInfo("nu_{K+}",          "nu_{K+}       ",    8000014,-1.0f, 1.0f, 0.         , 1.0e20,     0, 0.0030), //138
      KFEfficiencyParticleInfo("Sigma-_{pi-,n}",   "Sigma-_{pi-n} ",    7003112, 0.0f, 3.0f, 1.192642   , 1.479e-10, -1, 0.0100), //139
      KFEfficiencyParticleInfo("n_{Sigma-}",       "n_{Sigma-}    ",    7002112, 0.0f, 1.5f, 0.9395654  , 880,        0, 0.0030), //140
      KFEfficiencyParticleInfo("Sigma+_{pi+n}b",   "Sigma+{pi+n} b",   -7003112, 0.0f, 3.0f, 1.192642   , 1.479e-10, -1, 0.0030), //141
      KFEfficiencyParticleInfo("n_{Sigma+} b",     "n_{Sigma+b} b ",   -7002112, 0.0f, 1.5f, 0.9395654  , 880,        0, 0.0030), //142
      KFEfficiencyParticleInfo("Sigma-_{pi-n}b",   "Sigma+{pi-n} b",   -7003222, 0.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0030), //143
      KFEfficiencyParticleInfo("n_{Sigma-} b",     "n_{Sigma-_b} b",   -8002112, 0.0f, 1.5f, 0.9395654  , 0.93956541, 0, 0.0030), //144
      KFEfficiencyParticleInfo("Sigma+_{pi+n}",    "Sigma+_{pi+n} ",    7003222, 0.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0100), //145
      KFEfficiencyParticleInfo("n_{Sigma+}",       "n_{Sigma+}    ",    8002112, 0.0f, 1.5f, 0.9395654  , 880,        0, 0.0030), //146
      KFEfficiencyParticleInfo("Xi-_{pi-L}",       "Xi-_{pi-L}    ",    7003312, 0.0f, 3.0f, 1.32171    , 1.639e-10, -1, 0.0030), //147
      KFEfficiencyParticleInfo("Lambda_{Xi-}",     "Lambda_{Xi-}  ",    7003122, 0.0f, 2.0f, 1.115683   , 2.632e-10,  0, 0.0030), //148
      KFEfficiencyParticleInfo("Xi+_{pi+L_b}",     "Xi+_{pi+L_b}  ",   -7003312, 0.0f, 3.0f, 1.32171    , 1.639e-10,  1, 0.0030), //149
      KFEfficiencyParticleInfo("Lambda_{Xi+} b",   "Lambda_{Xi+} b",   -7003122, 0.0f, 2.0f, 1.115683   , 2.632e-10,  0, 0.0030), //150
      KFEfficiencyParticleInfo("Omega-_{Xi-pi0}",  "Omega-{pi-Xi0}",    7003334, 0.0f, 3.0f, 1.67245    , 0.821e-10, -1, 0.0030), //151
      KFEfficiencyParticleInfo("Xi0_{Omega-}",     "Xi0_{Omega-}  ",    7003322, 0.0f, 3.0f, 1.31486    , 2.9e-10,    0, 0.0030), //152
      KFEfficiencyParticleInfo("Omega+_{Xi+pi0}",  "Omega+_{Xipi0}",   -7003334, 0.0f, 3.0f, 1.67245    , 0.821e-10,  1, 0.0030), //153
      KFEfficiencyParticleInfo("Xi0_{Omega+} b",   "Xi0_{Omega+} b",   -7003322, 0.0f, 3.0f, 1.31486    , 2.9e-10,    0, 0.0030), //154
      KFEfficiencyParticleInfo("K-_{pi-pi0}",      "K-_{pi-pi0}   ",   -9000321, 0.0f, 3.0f, 0.493677   , 1.24e-8,   -1, 0.0030), //155
      KFEfficiencyParticleInfo("pi0_{K-}",         "pi0_{K-}      ",   -9000111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //156
      KFEfficiencyParticleInfo("K+_{pi+pi0}",      "K+_{pi+pi0}   ",    9000321, 0.0f, 3.0f, 0.493677   , 1.24e-8,    1, 0.0030), //157
      KFEfficiencyParticleInfo("pi0_{K+}",         "pi0_{K+}      ",    9000111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //158
      KFEfficiencyParticleInfo("Omega-{K-L}",      "Omega-_{K-L}  ",    8003334, 0.0f, 3.0f, 1.67245    , 0.821e-10, -1, 0.0030), //159
      KFEfficiencyParticleInfo("Lambda_{Omega-}",  "Lambda_{O-}   ",    8003122, 0.0f, 3.0f, 1.115683   , 2.632e-10,  0, 0.0030), //160
      KFEfficiencyParticleInfo("Omega+_{K+L_b}",   "Omega+_{K+Lb} ",   -8003334, 0.0f, 3.0f, 1.67245    , 0.821e-10,  1, 0.0030), //161
      KFEfficiencyParticleInfo("Lamda_{Omega+} b", "Lambda_{O+} b ",   -8003122, 0.0f, 3.0f, 1.115683   , 2.632e-10,  0, 0.0030), //162
      KFEfficiencyParticleInfo("Sigma-{p_b pi0} b","Sigma-{ppi0} b",   -8003222, 0.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0030), //163
      KFEfficiencyParticleInfo("pi0_{Sigma-b}",    "pi0_{Sigma-_b}",   -8000111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //164
      KFEfficiencyParticleInfo("Sigma+_{p pi0}",   "Sigma+_{ppi0} ",    8003222, 0.0f, 3.0f, 1.18937    , 0.8018e-10, 1, 0.0250), //165
      KFEfficiencyParticleInfo("pi0_{Sigma+}",     "pi0_{Sigma+}  ",    8000111, 0.0f, 3.0f, 0.1349766  , 8.52e-17,   0, 0.0030), //166
//tracks
      KFEfficiencyParticleInfo("e-",               "e-            ",         11, 0.0f,0.01f, 5.485799e-4, 1.0e20,    -1, 0.0030), //167
      KFEfficiencyParticleInfo("e+",               "e+            ",        -11, 0.0f,0.01f, 5.485799e-4, 1.0e20,     1, 0.0030), //168
      KFEfficiencyParticleInfo("mu-",              "mu-           ",         13, 0.0f, 1.0f, 0.105658   , 2.2e-6,    -1, 0.0030), //169
      KFEfficiencyParticleInfo("mu+",              "mu+           ",        -13, 0.0f, 1.0f, 0.105658   , 2.2e-6,     1, 0.0030), //170
      KFEfficiencyParticleInfo("pi+",              "pi+           ",        211, 0.0f, 1.0f, 0.139570   , 2.6e-8,     1, 0.0030), //171
      KFEfficiencyParticleInfo("pi-",              "pi-           ",       -211, 0.0f, 1.0f, 0.139570   , 2.6e-8,    -1, 0.0030), //172
      KFEfficiencyParticleInfo("K+",               "K+            ",        321, 0.0f, 1.0f, 0.493677   , 1.238e-8,   1, 0.0030), //173
      KFEfficiencyParticleInfo("K-",               "K-            ",       -321, 0.0f, 1.0f, 0.493677   , 1.238e-8,  -1, 0.0030), //174
      KFEfficiencyParticleInfo("p+",               "p+            ",       2212, 0.0f, 1.5f, 0.938272   , 1.0e20,     1, 0.0030), //175
      KFEfficiencyParticleInfo("p-",               "p-            ",      -2212, 0.0f, 1.5f, 0.938272   , 1.0e20,    -1, 0.0030), //176
      KFEfficiencyParticleInfo("d+",               "d+            ", 1000010020, 0.0f, 2.5f, 1.876124   , 1.0e20,     1, 0.0030), //177
      KFEfficiencyParticleInfo("d-",               "d-            ",-1000010020, 0.0f, 2.5f, 1.876124   , 1.0e20,    -1, 0.0030), //178
      KFEfficiencyParticleInfo("t+",               "t+            ", 1000010030, 0.0f, 3.5f, 2.809432   , 1.0e20,     1, 0.0030), //179
      KFEfficiencyParticleInfo("t-",               "t-            ",-1000010030, 0.0f, 3.5f, 2.809432   , 1.0e20,    -1, 0.0030), //180
      KFEfficiencyParticleInfo("He3+",             "He3+          ", 1000020030, 0.0f, 3.5f, 2.809413   , 1.0e20,     2, 0.0030), //181
      KFEfficiencyParticleInfo("He3-",             "He3-          ",-1000020030, 0.0f, 3.5f, 2.809413   , 1.0e20,    -2, 0.0030), //182
      KFEfficiencyParticleInfo("He4+",             "He4+          ", 1000020040, 0.0f, 4.5f, 3.728400   , 1.0e20,     2, 0.0030), //183
      KFEfficiencyParticleInfo("He4-",             "He4-          ",-1000020040, 0.0f, 4.5f, 3.728400   , 1.0e20,    -2, 0.0030), //184
//background for subtraction
      KFEfficiencyParticleInfo("pi+pi+",           "pi+pi+        ",       9001, 0.0f, 2.0f, 0          , 1.0e20,     0, 0.0030), //185
      KFEfficiencyParticleInfo("pi+K+",            "pi+K+         ",       9002, 0.6f, 5.6f, 0          , 1.0e20,     0, 0.0030), //186
      KFEfficiencyParticleInfo("K+K+",             "K+K+          ",       9003, 0.8f, 3.8f, 0          , 1.0e20,     0, 0.0030), //187
      KFEfficiencyParticleInfo("K+p+",             "K+p+          ",       9004, 1.4f, 5.4f, 0          , 1.0e20,     0, 0.0030), //188
      KFEfficiencyParticleInfo("pi-pi-",           "pi-pi-        ",      -9001, 0.0f, 2.0f, 0          , 1.0e20,     0, 0.0030), //189
      KFEfficiencyParticleInfo("pi-K-",            "pi-K-         ",      -9002, 0.6f, 5.6f, 0          , 1.0e20,     0, 0.0030), //190
      KFEfficiencyParticleInfo("K-K-",             "K-K-          ",      -9003, 0.8f, 3.8f, 0          , 1.0e20,     0, 0.0030), //191
      KFEfficiencyParticleInfo("K-p-",             "K-p-          ",      -9004, 1.4f, 5.4f, 0          , 1.0e20,     0, 0.0030), //192
//V0
      KFEfficiencyParticleInfo("V0",               "V0            ",  123456789, 0.3f, 1.3f, 0          , 0,          0, 0.0030)  //193
    };
                                        
    int mPartMaxMult[nParticles];
    for(int i=0; i<nParticles; i++)
      mPartMaxMult[i] = 20;
    mPartMaxMult[fFirstStableParticleIndex + 4] = 500;
    mPartMaxMult[fFirstStableParticleIndex + 5] = 500;
    mPartMaxMult[fFirstStableParticleIndex + 6] = 50;
    mPartMaxMult[fFirstStableParticleIndex + 7] = 50;
    mPartMaxMult[fFirstStableParticleIndex + 8] = 500;
                                    
    //set decay mode
    partDaughterPdg.resize(nParticles);

    int curPart = 0;
    
    partDaughterPdg[curPart].push_back(  211); //K0s -> pi+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambda -> p pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-2212); //Lambda_bar -> p- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Xi- -> Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Xi+ -> Lambda_bar pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Xi0 -> Lambda Pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Xi0_bar -> Lambda_bar Pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Omega- -> Lambda K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Omega+ -> Lambda_bar K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   22); //Sigma0 -> Lambda Gamma
    partDaughterPdg[curPart].push_back( 3122);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   22); //Sigma0_bar -> Lambda_bar Gamma
    partDaughterPdg[curPart].push_back(-3122);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //Sigma+ -> p Pi0
    partDaughterPdg[curPart].push_back( 2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //Sigma+_bar -> p- Pi0
    partDaughterPdg[curPart].push_back(-2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //K*0 -> K+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -321); //K*0_bar -> K- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //K*+ -> K0s pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //K*- -> K0s pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //K*0 -> K0 pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //K*+ -> K+ pi0
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //K*- -> K- pi0
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Sigma+ -> Lambda pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Sigma- -> Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Sigma+_bar -> Lambda_bar pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Sigma-_bar -> Lambda_bar pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Sigma*0 -> Lambda pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Sigma*0_bar -> Lambda_bar pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambda* -> p K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-2212); //Lambda*_bar -> p- K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3312); //Xi*0 -> Xi- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3312); //Xi*0_bar -> Xi+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Xi*- -> Lambda K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3122); //Xi*+ -> Lambda_bar K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3312); //Xi*- -> Xi- pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3312); //Xi*+ -> Xi+ pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3312); //Omega*- -> Xi- pi+ K-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3312); //Omega*- -> Xi+ pi- K+
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //H-dibar -> Lambda Lambda
    partDaughterPdg[curPart].push_back( 3122);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //phi -> K+ K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //rho, omega, phi -> pi+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   11); //rho, omega, phi -> e+ e-
    partDaughterPdg[curPart].push_back(  -11);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   13); //rho, omega, phi -> mu+ mu-
    partDaughterPdg[curPart].push_back(  -13);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   11); //gamma -> e+ e-
    partDaughterPdg[curPart].push_back(  -11);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   22); //pi0 -> gamma gamma
    partDaughterPdg[curPart].push_back(   22);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  111); //eta -> pi0 pi0
    partDaughterPdg[curPart].push_back(  111);
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Delta0 -> p pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Delta0_bar -> p- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back( 2212); //Delta++ -> p pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Delta--_bar -> p- pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   11); //JPsi -> e+ e-
    partDaughterPdg[curPart].push_back(  -11);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   13); //JPsi -> mu+ mu-
    partDaughterPdg[curPart].push_back(  -13);
    curPart++;

    partDaughterPdg[curPart].push_back(   2212); //JPsi -> p p-
    partDaughterPdg[curPart].push_back(  -2212);
    curPart++;

    partDaughterPdg[curPart].push_back(   3122); //JPsi -> Lambda Lambda_bar
    partDaughterPdg[curPart].push_back(  -3122);
    curPart++;

    partDaughterPdg[curPart].push_back(   3312); //JPsi -> Xi- Xi+
    partDaughterPdg[curPart].push_back(  -3312);
    curPart++;

    partDaughterPdg[curPart].push_back(   3334); //Psi -> Omega- Omega+
    partDaughterPdg[curPart].push_back(  -3334);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //D0 -> pi+ K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -211); //D0_bar -> K+ pi-
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //D0 -> pi+ pi+ pi- K-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -211); //D0_bar -> pi- pi- pi+ K+
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  321);
    curPart++;

    partDaughterPdg[curPart].push_back(  211); //D0 -> pi+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(  211); //D0 -> 2pi+ 2pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D0_bar -> K0 pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //D0_bar -> K+ K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;

    partDaughterPdg[curPart].push_back(  321); //D0_bar -> K+ K- K0
    partDaughterPdg[curPart].push_back( -321);
    partDaughterPdg[curPart].push_back(  310);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D0_bar -> K0 pi+ pi- pi0
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -321); //D+ -> K- pi+ pi+
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //D- -> K+ pi- pi-
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D+ -> K0 pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D- -> K0 pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D+ -> K0 pi+ pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //D- -> K0 pi+ pi- pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //D+ -> pi+ pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  211); //D- -> pi+ pi- pi-
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -321); //Ds+ -> K- K+ pi+
    partDaughterPdg[curPart].push_back(  321);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //Ds- -> K+ K- pi-
    partDaughterPdg[curPart].push_back( -321);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //Ds+ -> K0 K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //Ds- -> K0 K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //Ds+ -> K0 K0 pi+
    partDaughterPdg[curPart].push_back(  310);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back(  310); //Ds- -> K0 K0 pi-
    partDaughterPdg[curPart].push_back(  310);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  310); //Ds+ -> K0 K+ pi+ pi-
    partDaughterPdg[curPart].push_back(  321);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(  310); //Ds- -> K0 K- pi+ pi-
    partDaughterPdg[curPart].push_back( -321);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  321); //Ds+ -> K+ pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back( -321); //Ds- -> K- pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    
    partDaughterPdg[curPart].push_back(  211); //Lambdac -> pi+ K- p
    partDaughterPdg[curPart].push_back( -321);
    partDaughterPdg[curPart].push_back( 2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -211); //Lambdac_bar -> pi- K+ p-
    partDaughterPdg[curPart].push_back(  321);
    partDaughterPdg[curPart].push_back(-2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambdac -> p K0s
    partDaughterPdg[curPart].push_back(  310);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Lambdac_bar -> p_bar K0s
    partDaughterPdg[curPart].push_back(  310);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambdac -> p K0s pi+ pi-
    partDaughterPdg[curPart].push_back(  310);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Lambdac_bar -> p_bar K0s pi+ pi-
    partDaughterPdg[curPart].push_back(  310);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Lambdac -> Lambda pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back(-3122); //Lambdac_bar -> Lambda_bar pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3122); //Lambdac -> Lambda 2pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-3122); //Lambdac_bar -> Lambda_bar 2pi- pi+
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;  
    
    partDaughterPdg[curPart].push_back( 3312); //Xic0 -> Xi- 2pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(-3312); //Xic0_bar -> Xi+ 2pi- pi+
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 2212); //Lambdac -> p pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-2212); //Lambdac_bar -> p_bar pi+ pi-
    partDaughterPdg[curPart].push_back(  211);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    
    partDaughterPdg[curPart].push_back(  411); //D*0 -> D+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -411); //D*0_bar -> D- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  421); //D*+ -> D0 pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -421); //D*- -> D0_bar pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  429); //D*+ -> D04 pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -429); //D*- -> D04_bar pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(  428); //D*0 -> D04 pi0
    partDaughterPdg[curPart].push_back(  111);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   11); //B -> e+ e-
    partDaughterPdg[curPart].push_back(  -11);
    curPart++;
    
    partDaughterPdg[curPart].push_back(   13); //B -> mu+ mu-
    partDaughterPdg[curPart].push_back(  -13);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -421); //B+ -> D0_bar pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  421); //B- -> D0 pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -421); //B+ -> D0_bar K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  421); //B- -> D0 K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;

    partDaughterPdg[curPart].push_back( -411); //B0 -> D- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  411); //B0_bar -> D+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( -411); //B0 -> D0_bar K+
    partDaughterPdg[curPart].push_back(  321);
    curPart++;
    
    partDaughterPdg[curPart].push_back(  411); //B0_bar -> D0 K-
    partDaughterPdg[curPart].push_back( -321);
    curPart++;

    partDaughterPdg[curPart].push_back( 3122); //H0-> Lambda pi- p
    partDaughterPdg[curPart].push_back( -211);
    partDaughterPdg[curPart].push_back( 2212);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 1000010020); //LambdaN -> d+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000010020); //LambdaN_bar-> d- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back( 1000010030); //LambdaNN -> t+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000010030); //LambdaNN_bar -> t- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 1000020030); //H3Lambda -> He3+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000020030); //H3Lambda_bar -> He3- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;

    partDaughterPdg[curPart].push_back( 1000020040); //H4Lambda -> He4+ pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000020040); //H4Lambda_bar -> He4- pi+
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 1000020030); //He4Lambda -> He3+ p+ pi-
    partDaughterPdg[curPart].push_back( 2212);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000020030); //He4Lambda_bar -> He3- p- pi+
    partDaughterPdg[curPart].push_back(-2212);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 1000020040); //He5Lambda -> He4+ p+ pi-
    partDaughterPdg[curPart].push_back( 2212);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back(-1000020040); //He5Lambda_bar -> He4- p- pi+
    partDaughterPdg[curPart].push_back(-2212);
    partDaughterPdg[curPart].push_back(  211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3004); //LLn -> H3Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3006); //H4LL -> He4Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back( 3004); //H4LL -> H3Lambda p pi-
    partDaughterPdg[curPart].push_back( 2212);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;

    partDaughterPdg[curPart].push_back( 3007); //H5LL -> He5Lambda pi-
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back( 3007); //He6LL -> He5Lambda p pi-
    partDaughterPdg[curPart].push_back( 2212);
    partDaughterPdg[curPart].push_back( -211);
    curPart++;
    
    partDaughterPdg[curPart].push_back(      13); // pi- -> mu- + nu_mu_bar
    partDaughterPdg[curPart].push_back(-7000014); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(    -211); // nu_mu_bar <- pi- - mu-
    partDaughterPdg[curPart].push_back(      13); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -13); // pi+ -> mu+ + nu_mu
    partDaughterPdg[curPart].push_back( 7000014); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(    211); // nu_mu <- pi+ - mu+
    partDaughterPdg[curPart].push_back(    -13); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      13); // K- -> mu- + nu_mu_bar
    partDaughterPdg[curPart].push_back(-8000014); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(    -321); // nu_mu_bar <- K- - mu-
    partDaughterPdg[curPart].push_back(      13); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -13); // K+ -> mu+ + nu_mu
    partDaughterPdg[curPart].push_back( 8000014); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     321); // nu_mu <- K+ - mu+
    partDaughterPdg[curPart].push_back(     -13); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -211); // Sigma- -> pi- + n
    partDaughterPdg[curPart].push_back(  7002112); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     3112); // n <- Sigma- - pi-
    partDaughterPdg[curPart].push_back(     -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // Sigma-b -> pi+ + nb
    partDaughterPdg[curPart].push_back(  -7002112); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3112); // nb <- Sigma-b - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -211); // Sigma+b -> pi- + nb
    partDaughterPdg[curPart].push_back(  -8002112); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(    -3222); // nb <- Sigma+b - pi-
    partDaughterPdg[curPart].push_back(     -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // Sigma+ -> pi+ + n
    partDaughterPdg[curPart].push_back(   8002112); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3222); // n <- Sigma+ - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -211); // Xi- -> pi- + lam
    partDaughterPdg[curPart].push_back(   7003122); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3312); // lam <- Xi- - pi-
    partDaughterPdg[curPart].push_back(      -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // Xi-b -> pi+ + lam_b
    partDaughterPdg[curPart].push_back(  -7003122); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3312); // lam_b <- Xi-b - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -211); // Om- -> pi- + Xi0
    partDaughterPdg[curPart].push_back(   7003322); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3334); // Xi0 <- Om- - pi-
    partDaughterPdg[curPart].push_back(      -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // Om-b -> pi+ + Xi0_b
    partDaughterPdg[curPart].push_back(  -7003322); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3334); // Xi0_b <- Om-b - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -211); // K- -> pi- + Pi0_b
    partDaughterPdg[curPart].push_back(  -9000111); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -321); // Pi0_b <- K- - pi-
    partDaughterPdg[curPart].push_back(      -211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       211); // K+ -> pi+ + Pi0
    partDaughterPdg[curPart].push_back(   9000111); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       321); // Pi0 <- K+ - pi+
    partDaughterPdg[curPart].push_back(       211); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      -321); // Om- -> K- + Lam
    partDaughterPdg[curPart].push_back(   8003122); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3334); // Lam <- Om- - K-
    partDaughterPdg[curPart].push_back(      -321); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(       321); // Om+ -> K+ + Lam_b
    partDaughterPdg[curPart].push_back(  -8003122); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3334); // Lam_b <- Om+ - K+
    partDaughterPdg[curPart].push_back(       321); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -2212); // Si+b -> p_b + Pi0
    partDaughterPdg[curPart].push_back(  -8000111); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(     -3222); // Pi0 <- Si+b - p_b
    partDaughterPdg[curPart].push_back(     -2212); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      2212); // Si+ -> p + Pi0
    partDaughterPdg[curPart].push_back(   8000111); //
    curPart++;
    
    partDaughterPdg[curPart].push_back(      3222); // Pi0 <- Si+ - p
    partDaughterPdg[curPart].push_back(      2212); //
    curPart++;
    
    for(int iP=0; iP<nParticles; iP++)
    {
      partPDG[iP] = particleInfo[iP].PDG();
      partName[iP] = particleInfo[iP].Name();
      partTitle[iP] = particleInfo[iP].Title();
      partMHistoMin[iP] = particleInfo[iP].HistoMin();
      partMHistoMax[iP] = particleInfo[iP].HistoMax();
      partMaxMult[iP] = mPartMaxMult[iP];
      partMass[iP] = particleInfo[iP].Mass();
      partLifeTime[iP] = particleInfo[iP].LifeTime();
      partCharge[iP] = particleInfo[iP].Charge();
      partMassSigma[iP] = particleInfo[iP].MassSigma();
    }

    for(int iP=0; iP<nParticles; iP++)
    {
      AddCounter(partName[iP],           partTitle[iP] + "     ");
      AddCounter(partName[iP] + "_prim", partTitle[iP] + " Prim");
      AddCounter(partName[iP] + "_sec",  partTitle[iP] + " Sec ");
    }

    for(int iP=0; iP<nParticles; iP++)
      fPdgToIndex[particleInfo[iP].PDG()] = iP;
  }

  virtual ~KFPartEfficiencies(){};

  /** \brief Returns index of the decay with a given PDG code in the scheme of the KF Particle Finder. If it is not present there - returns "-1". */
  int GetParticleIndex(int pdg)
  {
    std::map<int, int>::iterator it;
    it=fPdgToIndex.find(pdg);
    if(it != fPdgToIndex.end()) return it->second;
    else return -1;
  }

  /** \brief Returns the map between PDG codes and index of the decay in the scheme of the KF Particle Finder. */
  std::map<int,int> GetPdgToIndexMap() const { return fPdgToIndex; } 
  
  virtual void AddCounter(std::string shortname, std::string name)
  {
    /** Adds a counter with the name defined by "name" to all counter
     ** objects. For easiness of operation with counters, a shortname is assigned
     ** to each of them and the corresponding entry in the map indices is done.
     ** \param[in] shortname - a short name of the counter for fast and easy access to its index
     ** \param[in] name - name of the counter which is added to each counter object.
     **/
    indices[shortname] = names.size();
    names.push_back(name);

    ratio_reco1.AddCounter();
    ratio_reco2.AddCounter();
    ratio_reco3.AddCounter();

    mc1.AddCounter();
    mc2.AddCounter();
    mc3.AddCounter();
    
    reco.AddCounter();

    ratio_ghost.AddCounter();
    ratio_bg.AddCounter();
    ratio_clone.AddCounter();
    ghost.AddCounter();
    bg.AddCounter();
    clone.AddCounter();
  };

  /** \brief Operator to add efficiency table from object "a" to the current object. Returns the current object after addition. */
  KFPartEfficiencies& operator+=(KFPartEfficiencies& a){
    mc1 += a.mc1; mc2 += a.mc2; mc3 += a.mc3; reco += a.reco;
    ghost += a.ghost; bg += a.bg; clone += a.clone;
    return *this;
  };
  
  /** \brief Function to calculate efficiency after all counters are set. If the counters are modified the function should be called again. */
  void CalcEff(){
    ratio_reco1 = reco/mc1;
    ratio_reco2 = reco/mc2;
    ratio_reco3 = reco/mc3;

    KFMCCounter<int> allReco = reco + ghost + bg;
    ratio_ghost = ghost/allReco;
    ratio_bg  = bg/allReco;
    ratio_clone  = clone/allReco;
  };
  
  void Inc(bool isReco, int nClones, bool isMC1, bool isMC2, bool isMC3, std::string name)
  {
    /** Increases counters by one, if the corresponding boolean variable is "true".
     ** \param[in] isReco - "true" if particle is reconstructed
     ** \param[in] nClones - number of double reconstructed particles for the given MC particle,
     ** will be added to the "clone" counters
     ** \param[in] isMC1 - "true" if particle is reconstructable in 4pi, mc1 is increased
     ** \param[in] isMC2 - "true" if all daughters are reconstructable, mc2 is increased
     ** \param[in] isMC3 - "true" if all daughters are reconstructed, mc3 is increased
     ** \param[in] name  - "shortname" of the set of counters, which should be increased
     **/
    const int index = indices[name];
    
    if(isMC1) mc1.counters[index]++;
    if(isMC2) mc2.counters[index]++;
    if(isMC3) mc3.counters[index]++;
    
    if(isReco) reco.counters[index]++;
    if(nClones > 0)
      clone.counters[index] += nClones;
  };

  void IncReco(bool isGhost, bool isBg, std::string name)
  {
    /** Increases counters by one, if the corresponding boolean variable is "true".
     ** \param[in] isGhost - "true" if ghost is added
     ** \param[in] isBg - "true" if physics background is added
     ** \param[in] name  - "shortname" of the set of counters, which should be increased
     **/
    const int index = indices[name];

    if (isGhost) ghost.     counters[index]++;
    if (isBg)    bg.counters[index]++;
  };

  /** \brief Prints the efficiency table on the screen. */
  void PrintEff(){
    std::ios_base::fmtflags original_flags = std::cout.flags();
    std::cout.setf(std::ios::fixed);
    std::cout.setf(std::ios::showpoint);
    std::cout.precision(3);
    std::cout << "Particle             : "
         <<        "   Eff 4pi "
         <<" / "<< " Eff accept"
         <<" / "<< "  Eff KFPF "
         <<" / "<< "     Ghost "
         <<" / "<< "    BackGr "
         <<" / "<< "   N Ghost "
         <<" / "<< "  N BackGr "
         <<" / "<< "    N Reco "
         <<" / "<< "   N Clone "
         <<" | "<< "  N MC 4pi " 
         <<" | "<< "N MC accept" 
         <<" | "<< " N MC KFPF "  << std::endl;
    
    int NCounters = mc1.NCounters;
    for (int iC = 0; iC < NCounters; iC++){
        std::cout << names[iC]
             << "  : " << std::setw(10) << ratio_reco1.counters[iC]    
             << "  / " << std::setw(10) << ratio_reco2.counters[iC]
             << "  / " << std::setw(10) << ratio_reco3.counters[iC]
             << "  / " << std::setw(10) << ratio_ghost.counters[iC]  // particles w\o MCParticle
             << "  / " << std::setw(10) << ratio_bg.counters[iC]     // particles with incorrect MCParticle
             << "  / " << std::setw(10) << ghost.counters[iC]
             << "  / " << std::setw(10) << bg.counters[iC]
             << "  / " << std::setw(10) << reco.counters[iC]
             << "  / " << std::setw(10) << clone.counters[iC]
             << "  | " << std::setw(10) << mc1.counters[iC] 
             << "  | " << std::setw(10) << mc2.counters[iC]
             << "  | " << std::setw(10) << mc3.counters[iC]  << std::endl;
    }
    std::cout.flags(original_flags); 
  };
  
  float GetTotal4piEfficiency(int iDecay) { return ratio_reco1.counters[3*iDecay]; }  ///< Returns efficiency in 4pi for decay "iDecay".
  float GetTotalKFPEfficiency(int iDecay) { return ratio_reco3.counters[3*iDecay]; }  ///< Returns efficiency of KF Particle Finder method (cuts) for decay "iDecay".
  float GetPrimary4piEfficiency(int iDecay) { return ratio_reco1.counters[3*iDecay+1]; } ///< Returns efficiency in 4pi for decay "iDecay" for primary particles.
  float GetPrimaryKFPEfficiency(int iDecay) { return ratio_reco3.counters[3*iDecay+1]; } ///< Returns efficiency of KF Particle Finder method (cuts) for decay "iDecay" for primary particles.
  float GetSecondary4piEfficiency(int iDecay) { return ratio_reco1.counters[3*iDecay+2]; } ///< Returns efficiency in 4pi for decay "iDecay" for secondary particles.
  float GetSecondaryKFPEfficiency(int iDecay) { return ratio_reco3.counters[3*iDecay+2]; } ///< Returns efficiency of KF Particle Finder method (cuts) for decay "iDecay" for secondary particles.
  
  /** \brief Operator to write efficiencies to file. */
  friend std::fstream & operator<<(std::fstream &strm, KFPartEfficiencies &a) 
  {
    strm << a.ratio_reco1;
    strm << a.ratio_reco2;
    strm << a.ratio_reco3;
    strm << a.mc1;
    strm << a.mc2;
    strm << a.mc3;
    strm << a.reco;
    strm << a.ratio_ghost;
    strm << a.ratio_bg;
    strm << a.ratio_clone;
    strm << a.ghost;
    strm << a.bg;
    strm << a.clone;

    return strm;
  }
  /** \brief Operator to read efficiencies from file. */
  friend std::fstream & operator>>(std::fstream &strm, KFPartEfficiencies &a)
  {
    strm >> a.ratio_reco1;
    strm >> a.ratio_reco2;
    strm >> a.ratio_reco3;
    strm >> a.mc1;
    strm >> a.mc2;
    strm >> a.mc3;
    strm >> a.reco;
    strm >> a.ratio_ghost;
    strm >> a.ratio_bg;
    strm >> a.ratio_clone;
    strm >> a.ghost;
    strm >> a.bg;
    strm >> a.clone;

    return strm;
  }
  /** \brief Adds efficiency from the file with the name defined by "fileName" to the current objects. */
  void AddFromFile(std::string fileName)
  {
    std::fstream file(fileName.data(),std::fstream::in);
    file >> *this;
  }
  
  int GetNDaughters(int iParticle) const { return partDaughterPdg[iParticle].size(); } ///< Returns number of daughter particles for the decay with index "iParticle".
  /** \brief Returns the PDG code of the daughter "iDaughter" from the decay with index "iParticle". */
  int GetDaughterPDG(int iParticle, int iDaughter) const { return partDaughterPdg[iParticle][iDaughter]; }
  
  float GetMass(int iParticle) const { return partMass[iParticle]; } ///< Returns the table mass of the decay with index "iParticle".
  float GetMassSigma(int iParticle) const { return partMassSigma[iParticle]; } ///< Returns expected width of the mass peak of the decay with index "iParticle".
  
  static const int nParticles = 194;                     ///< Number of particles.
  static const int fFirstHypernucleusIndex = 114;        ///< Index of the first hypernuclei in the list.
  static const int fLastHypernucleusIndex = 130;         ///< Index of the last hypernuclei in the list.
  static const int fFirstMissingMassParticleIndex = 131; ///< Index of the first decay reconstructed by the missing mass method.
  static const int fLastMissingMassParticleIndex = 166;  ///< Index of the last decay reconstructed by the missing mass method.
  static const int fFirstStableParticleIndex = 167;      ///< Index of the first stable particle in the list.
  static const int fLastStableParticleIndex = 184;       ///< Index of the last stable particle in the list.
  
  int partPDG[nParticles];                        ///< Array of PDG codes assigned to the decays.
  std::string partName[nParticles];               ///< Array of names of the decay in the file with histograms.
  std::string partTitle[nParticles];              ///< Array of names of the decay in the output table with efficiency.
  std::vector<std::vector<int> > partDaughterPdg; ///< Array with vectors of daughter particles for each decay.
  float partMHistoMin[nParticles];                ///< Array with lower boundary in the mass histograms for each decay.
  float partMHistoMax[nParticles];                ///< Array with upper boundary in the mass histograms for each decay.
  int partMaxMult[nParticles];                    ///< Array with upper boundary in the multiplicity histograms of each decay.
  float partMass[nParticles];                     ///< Array with table masses of each decay.
  float partLifeTime[nParticles];                 ///< Array with lifetimes in seconds of each decay.
  int partCharge[nParticles];                     ///< Array with charge of each particle specie in units of the elementary charge.
  float partMassSigma[nParticles];                ///< Array with expected width of mass peaks used for the side band method.

  
 private:
  std::vector<std::string> names;     ///< Names of the counters. The same for all counters objects.
  std::map<std::string, int> indices; ///< Map between the counter index and its short name.

  std::map<int, int> fPdgToIndex;     ///< The map between PDG code assigned to the decay and index in the decay list.

  KFMCCounter<double> ratio_reco1;    ///< Efficiency in 4 pi for all decays.
  KFMCCounter<double> ratio_reco2;    ///< Efficiency normalised on the particles with all daughters reconstructable for all decays.
  KFMCCounter<double> ratio_reco3;    ///< Efficiency normalised on the particles with all daughters reconstructed for all decays.

  KFMCCounter<int> mc1;               ///< Counters of the Monte Carlo particles of all species.
  KFMCCounter<int> mc2;               ///< Counters of the Monte Carlo particles with all daughters reconstructable for all species.
  KFMCCounter<int> mc3;               ///< Counters of the Monte Carlo particles with all daughters found for all species.

  KFMCCounter<int> reco;              ///< Counters of the reconstructed particles for all species.

  KFMCCounter<double> ratio_ghost;    ///< Ratio of the ghost candidates to the total number of candidates for all species.
  KFMCCounter<double> ratio_bg;       ///< Ratio of the physics background candidates to the total number of candidates for all species.
  KFMCCounter<double> ratio_clone;    ///< Ratio of double reconstructed particles to the total number of signal candidates for all species.

  KFMCCounter<int> ghost;             ///< Counters of the ghost candidates for all species.
  KFMCCounter<int> bg;                ///< Counters of the physics background candidates for all species.
  KFMCCounter<int> clone;             ///< Counters of the double reconstructed particles for all species.
  
#ifndef KFParticleStandalone
  ClassDef( KFPartEfficiencies, 1 )
#endif
};

#endif
/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _KFMCParticle_h_
#define _KFMCParticle_h_

#include <vector>

#ifdef HLTCA_STANDALONE
#include "RootTypesDef.h"
#else
#include "TObject.h"
#endif

/** @class KFMCParticle
 ** @brief A class to store relations between mother and daughter Monte Carlo simulated particles.
 ** @author  M.Zyzak, I.Kisel
 ** @date 05.02.2019
 ** @version 1.0
 **
 ** The class is used to calculate reconstruction efficiency of all Monte Carlo particles. It is
 ** simplifies the procedure for short-lived particles. Contains a vector with unique Ids of all
 ** MC daughters, a unique Id of the corresponding MC track, a unique Id of the MC mother particle,
 ** the PDG code of the MC particle, flags showing if particle can be reconstructed according
 ** to several different definitions, flags showing if particle creates a secondary vertex with
 ** two or more daughters, an index of the initial particle Id in case of the K->mu+nu and pi-> mu+nu
 ** decays, since GEANT engines do not store neutrinos. 
 **/

class KFMCParticle :public TObject
{
 public:
  KFMCParticle();
  ~KFMCParticle();

  void AddDaughter( int i ); ///< Adds an Id of the new particle to the list with Ids of daughter particles.
  int  NDaughters() const { return fDaughterIds.size(); } ///< Returns number of daughter particles.
  const std::vector<int>&  GetDaughterIds() const { return fDaughterIds; } ///< Returns a reference to the vector with Id of daughter particle KFMCParticle::fDaughterIds.
  void CleanDaughters() { fDaughterIds.resize(0); } ///< Remove Ids of all daughter particles from the current object.

  void SetPDG(int pdg) {fPDG = pdg;} ///< Set the PDG code of the current particle KFMCParticle::fPDG.
  void SetMCTrackID(int id) {fMCTrackID = id;} ///< Sets the Id of the corresponding Monte Carlo track KFMCParticle::fMCTrackID.
  void SetMotherId(int id) {fMotherId = id;} ///< Sets the Id of the mother particle or primary vertex KFMCParticle::fMotherId.
  
  int  GetMCTrackID()      const {return fMCTrackID;} ///< Returns Id of the corresponding MC track KFMCParticle::fMCTrackID.
  int  GetMotherId()       const {return fMotherId;}  ///< Returns Id of the mother particle or primary vertex KFMCParticle::fMotherId.
  int  GetPDG()            const {return fPDG;}       ///< Returns PDG code of the current particle KFMCParticle::fPDG.
  
  bool IsReconstructable(int i) const {return fIsReconstructable[i];} ///< Returns a flag showing if particle can be reconstructed with KFMCParticle::fIsReconstructable index "i".
  void SetAsReconstructable(int i) { fIsReconstructable[i] = 1;} ///< Defines the particle as those which should be reconstructed for the efficiency set "i".
    
  bool IsReconstructableV0(int i) const {return fIsV0[i];} ///< Returns a flag showing if particle is a reconstructable V0.
  void SetAsReconstructableV0(int i) { fIsV0[i] = 1;}      ///< Defines the particle as V0 which should be reconstructed for the efficiency set "i".
  
  void SetInitialParticleId(int i) {fInitialParticleId = i;} ///< Sets Id of the Monte Carlo particle, from which the current particle was copied.
  int InitialParticleId() const {return fInitialParticleId;} ///< Returns the Id of the Monte Carlo particle, from which the current particle was copied.
 private: //data
  std::vector<int> fDaughterIds; ///< A vector with Ids of the daughter Monte Carlo particles.
  int fMCTrackID; ///< A unique Id of the corresponding Monte Carlo track.
  int fMotherId;  ///< A unique Id of the mother particle. If the current particle is primary the Id of the primary vertex with a negative sigh is stored.
  int fPDG;       ///< A PDG code of the current particle.
  
  /** Flags for calculation of the efficiency, define the denominator in each set of efficiency. 
   ** Flags 0-2 are used for particles reconstructed by the conventional method, 3 and 4 are used
   ** for particles found by the missing mass method: \n
   ** [0] - true for all particles, is used for calculation of the efficiency in 4pi;\n
   ** [1] - true if the particle is long-lived and can be reconstructed in the detector or
   ** if the particle is short-lived and all its daughter particles can be reconstructed; detector-dependent;\n
   ** [2] - true if the particle is long-lived and is reconstructed in the detector or
   ** if the particle is short-lived and all its daughter particles are reconstructed, 
   ** is used in calculation of efficiency of the KF Particle Finder method;\n
   ** [3] - true if the particle is long-lived and is reconstructed in the detector or
   ** if the particle is short-lived, can be reconstructed by the missing mass method
   ** and all its daughter particles are reconstructed; \n
   ** [4] - true for all particles, which can be found by the missing mass method,
   ** is used for calculation of the efficiency in 4pi.
   **/
  bool fIsReconstructable[5];
  /** Flags to calculate efficiency of short-lived particles producing a secondary vertex with 
   ** two or more daughters; similar to KFMCParticle::fIsReconstructable[0-2].
   **/
  bool fIsV0[3]; 

  /** For calculation of missing mass method efficiency a copy of the mother particle
   ** is created. fInitialParticleId is an Id of the initial mother particle.
   **/
  int fInitialParticleId;
#ifndef KFParticleStandalone
  ClassDef( KFMCParticle, 1 )
#endif
};

#endif

/*
 * This file is part of KFParticle package
 * Copyright (C) 2007-2019 FIAS Frankfurt Institute for Advanced Studies
 *               2007-2019 Goethe University of Frankfurt
 *               2007-2019 Ivan Kisel <I.Kisel@compeng.uni-frankfurt.de>
 *               2007-2019 Maksym Zyzak
 *
 * KFParticle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * KFParticle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef KFParticleTest_H
#define KFParticleTest_H

class KFParticle;
class KFParticleSIMD;

class KFParticleTest
{
 public:
  
  KFParticleTest();
  ~KFParticleTest();
  
  void PrintTutorial();
  void RunTest();
  
 private:
   
  void RunTestSingle();
  void RunTestSIMD();
  void CompareSingleAndSIMDResults();
  
  KFParticle* fMotherSingle;
  KFParticleSIMD* fMotherSIMD;
  
#ifndef KFParticleStandalone
  ClassDef( KFParticleTest, 1 )
#endif
};

#endif //KFParticleTest_H


#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_KFParticle.C:6:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_sPHENIX.h:25:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_eventReconstruction.h:25:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_Tools.h:28:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/KFParticle.h:29:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/KFParticleBase.h:294:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef( KFParticleBase, 2 )
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_KFParticle.C:6:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_sPHENIX.h:25:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_eventReconstruction.h:25:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_Tools.h:28:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/KFParticle.h:329:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef( KFParticle, 3 )
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_KFParticle.C:6:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_sPHENIX.h:25:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_eventReconstruction.h:25:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/kfparticle_sphenix/KFParticle_Tools.h:28:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/KFParticle.h:924:1: error: control reaches end of non-void function [-Werror,-Wreturn-type]
}
^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class SvtxVertexMap with content:

#line 1 "SvtxVertexMap_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASEHISTORIC_SVTXVERTEXMAP_H
#define TRACKBASEHISTORIC_SVTXVERTEXMAP_H

#include "SvtxVertex.h"

#include <phool/PHObject.h>
#include <iostream>
#include <map>

class SvtxVertexMap : public PHObject
{
 public:
  typedef std::map<unsigned int, SvtxVertex*> VertexMap;
  typedef std::map<unsigned int, SvtxVertex*>::const_iterator ConstIter;
  typedef std::map<unsigned int, SvtxVertex*>::iterator Iter;

  virtual ~SvtxVertexMap() {}

  virtual void identify(std::ostream& os = std::cout) const
  {
    os << "SvtxVertexMap base class" << std::endl;
  }
  virtual void Reset() {}
  virtual int isValid() const { return 0; }
  virtual PHObject* CloneMe() const { return nullptr; }

  virtual bool empty() const { return true; }
  virtual size_t size() const { return 0; }
  virtual size_t count(unsigned int idkey) const { return 0; }
  virtual void clear() {}

  virtual const SvtxVertex* get(unsigned int idkey) const { return nullptr; }
  virtual SvtxVertex* get(unsigned int idkey) { return nullptr; }

  //! Add vertex to container. Note the container take to ownership
  virtual SvtxVertex* insert(SvtxVertex* cluster) { return nullptr; }
  //! legacy interface. Add vertex to container. Note the container does not take ownership
  virtual SvtxVertex* insert_clone(const SvtxVertex* vertex) { return nullptr; }

  virtual size_t erase(unsigned int idkey) { return 0; }

  virtual ConstIter begin() const;
  virtual ConstIter find(unsigned int idkey) const;
  virtual ConstIter end() const;

  virtual Iter begin();
  virtual Iter find(unsigned int idkey);
  virtual Iter end();

 protected:
  SvtxVertexMap() {}

 private:
  ClassDef(SvtxVertexMap, 1);
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class SvtxTrackMap with content:

#line 1 "SvtxTrackMap_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASEHISTORIC_SVTXTRACKMAP_H
#define TRACKBASEHISTORIC_SVTXTRACKMAP_H

#include "SvtxTrack.h"

#include <phool/PHObject.h>

#include <iostream>
#include <map>

class SvtxTrackMap : public PHObject
{
 public:
  typedef std::map<unsigned int, SvtxTrack*> TrackMap;
  typedef std::map<unsigned int, SvtxTrack*>::const_iterator ConstIter;
  typedef std::map<unsigned int, SvtxTrack*>::iterator Iter;

  virtual ~SvtxTrackMap() {}

  virtual void identify(std::ostream& os = std::cout) const
  {
    os << "SvtxTrackMap base class" << std::endl;
  }
  virtual void Reset() {}
  virtual int isValid() const { return 0; }
  virtual PHObject* CloneMe() const { return nullptr; }

  virtual bool empty() const { return true; }
  virtual size_t size() const { return 0; }
  virtual size_t count(unsigned int idkey) const { return 0; }
  virtual void clear() {}

  virtual const SvtxTrack* get(unsigned int idkey) const { return nullptr; }
  virtual SvtxTrack* get(unsigned int idkey) { return nullptr; }
  virtual SvtxTrack* insert(const SvtxTrack* cluster) { return nullptr; }
  virtual size_t erase(unsigned int idkey) { return 0; }

  virtual ConstIter begin() const;
  virtual ConstIter find(unsigned int idkey) const;
  virtual ConstIter end() const;

  virtual Iter begin();
  virtual Iter find(unsigned int idkey);
  virtual Iter end();

 protected:
  SvtxTrackMap() {}

 private:
  ClassDef(SvtxTrackMap, 1);
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class SvtxVertex with content:

#line 1 "SvtxVertex_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASEHISTORIC_SVTXVERTEX_H
#define TRACKBASEHISTORIC_SVTXVERTEX_H

#include <phool/PHObject.h>

#include <cmath>
#include <iostream>
#include <climits>
#include <set>
#include <vector>

class SvtxVertex : public PHObject
{
 public:
  typedef std::set<unsigned int> TrackSet;
  typedef std::set<unsigned int>::const_iterator ConstTrackIter;
  typedef std::set<unsigned int>::iterator TrackIter;

  virtual ~SvtxVertex() {}

  // PHObject virtual overloads

  virtual void identify(std::ostream& os = std::cout) const
  {
    os << "SvtxVertex base class" << std::endl;
  }
  virtual void Reset() {}
  virtual int isValid() const { return 0; }
  virtual PHObject* CloneMe() const { return nullptr; }

  // vertex info

  virtual unsigned int get_id() const { return UINT_MAX; }
  virtual void set_id(unsigned int id) {}

  virtual float get_t0() const { return NAN; }
  virtual void set_t0(float t0) {}

  virtual float get_x() const { return NAN; }
  virtual void set_x(float x) {}

  virtual float get_y() const { return NAN; }
  virtual void set_y(float y) {}

  virtual float get_z() const { return NAN; }
  virtual void set_z(float z) {}

  virtual float get_chisq() const { return NAN; }
  virtual void set_chisq(float chisq) {}

  virtual unsigned int get_ndof() const { return UINT_MAX; }
  virtual void set_ndof(unsigned int ndof) {}

  virtual float get_position(unsigned int coor) const { return NAN; }
  virtual void set_position(unsigned int coor, float xi) {}

  virtual float get_error(unsigned int i, unsigned int j) const { return NAN; }
  virtual void set_error(unsigned int i, unsigned int j, float value) {}

  //
  // associated track ids methods
  //
  virtual void clear_tracks() {}
  virtual bool empty_tracks() { return true; }
  virtual size_t size_tracks() const { return 0; }
  virtual void insert_track(unsigned int trackid) {}
  virtual size_t erase_track(unsigned int trackid) { return 0; }
  virtual ConstTrackIter begin_tracks() const;
  virtual ConstTrackIter find_track(unsigned int trackid) const;
  virtual ConstTrackIter end_tracks() const;
  virtual TrackIter begin_tracks();
  virtual TrackIter find_track(unsigned int trackid);
  virtual TrackIter end_tracks();

 protected:
  SvtxVertex() {}

  ClassDef(SvtxVertex, 1);
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module KFParticle_Container_Dict: '
#line 1 "KFParticle_Container_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class KFParticle_Container;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module ParticleFlowElement_Dict: '
#line 1 "ParticleFlowElement_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class ParticleFlowElement;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module ParticleFlowElementv1_Dict: '
#line 1 "ParticleFlowElementv1_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class ParticleFlowElementv1;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module ParticleFlowElementContainer_Dict: '
#line 1 "ParticleFlowElementContainer_Dict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class ParticleFlowElementContainer;
'
Error in <TInterpreter::AutoParse>: Error parsing payload code for class SvtxTrackState with content:

#line 1 "SvtxTrackState_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef __SVTXTRACKSTATE_H__
#define __SVTXTRACKSTATE_H__

#include <phool/PHObject.h>
#include <cmath>

class SvtxTrackState : public PHObject
{
 public:
  virtual ~SvtxTrackState() {}
    
  virtual void identify(std::ostream &os = std::cout) const
  {
    os << "SvtxTrackState base class" << std::endl;
  }
  virtual void Reset() {}
  virtual int isValid() const { return 0; }
  virtual PHObject *CloneMe() const { return nullptr; }

  virtual float get_pathlength() const { return NAN; }

  virtual float get_x() const { return NAN; }
  virtual void set_x(float x) {}

  virtual float get_y() const { return NAN; }
  virtual void set_y(float y) {}

  virtual float get_z() const { return NAN; }
  virtual void set_z(float z) {}

  virtual float get_pos(unsigned int i) const { return NAN; }

  virtual float get_px() const { return NAN; }
  virtual void set_px(float px) {}

  virtual float get_py() const { return NAN; }
  virtual void set_py(float py) {}

  virtual float get_pz() const { return NAN; }
  virtual void set_pz(float pz) {}

  virtual float get_mom(unsigned int i) const { return NAN; }

  virtual float get_p() const { return NAN; }
  virtual float get_pt() const { return NAN; }
  virtual float get_eta() const { return NAN; }
  virtual float get_phi() const { return NAN; }

  virtual float get_error(unsigned int i, unsigned int j) const { return NAN; }
  virtual void set_error(unsigned int i, unsigned int j, float value) {}

  virtual std::string get_name() const { return ""; }
  virtual void set_name(const std::string &name) {}

  ///@name convenience interface, also found in Trkrcluster
  //@{

  /// rphi error
  virtual float get_rphi_error() const
  {
    return NAN;
  }

  /// phi error
  virtual float get_phi_error() const
  {
    return NAN;
  }

  /// z error
  virtual float get_z_error() const
  {
    return NAN;
  }

  //@}

 protected:
  SvtxTrackState(float pathlength = 0.0) {}

  ClassDef(SvtxTrackState, 1);
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:19:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Tracking.C:16:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackreco/PHCASeeding.h:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackreco/ALICEKF.h:4:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase_historic/SvtxTrack_v2.h:4:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase_historic/SvtxTrack.h:4:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase_historic/SvtxTrackState.h:81:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(SvtxTrackState, 1);
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class SvtxTrack with content:

#line 1 "SvtxTrack_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASEHISTORIC_SVTXTRACK_H
#define TRACKBASEHISTORIC_SVTXTRACK_H

#include "SvtxTrackState.h"

#include <trackbase/TrkrDefs.h>

#include <g4main/PHG4HitDefs.h>
#include <phool/PHObject.h>

#include <limits.h>
#include <cmath>
#include <iostream>
#include <map>
#include <set>

class SvtxTrack : public PHObject
{
 public:
  typedef std::map<float, SvtxTrackState*> StateMap;
  typedef StateMap::const_iterator ConstStateIter;
  typedef StateMap::iterator StateIter;

  typedef std::set<unsigned int> ClusterSet;
  typedef ClusterSet::const_iterator ConstClusterIter;
  typedef ClusterSet::iterator ClusterIter;

  typedef std::set<TrkrDefs::cluskey> ClusterKeySet;
  typedef ClusterKeySet::const_iterator ConstClusterKeyIter;
  typedef ClusterKeySet::iterator ClusterKeyIter;

  enum CAL_LAYER
  {
    PRES = 0,
    CEMC = 1,
    HCALIN = 2,
    HCALOUT = 3
  };

  virtual ~SvtxTrack() = default;

  // The "standard PHObject response" functions...
  virtual void identify(std::ostream& os = std::cout) const
  {
    os << "SvtxTrack base class" << std::endl;
  }
  virtual void Reset() {}
  virtual int isValid() const { return 0; }
  virtual PHObject* CloneMe() const { return nullptr; }

  //! import PHObject CopyFrom, in order to avoid clang warning
  using PHObject::CopyFrom;
  
  //! copy content from base class
  virtual void CopyFrom( const SvtxTrack& ) 
  {}

  //! copy content from base class
  virtual void CopyFrom( SvtxTrack* ) 
  {}

  //
  // basic track information ---------------------------------------------------
  //

  virtual unsigned int get_id() const { return UINT_MAX; }
  virtual void set_id(unsigned int id) {}

  virtual unsigned int get_vertex_id() const { return UINT_MAX; }
  virtual void set_vertex_id(unsigned int vertex_id) {}

  virtual bool get_positive_charge() const { return false; }
  virtual void set_positive_charge(bool ispos) {}

  virtual int get_charge() const { return -1; }
  virtual void set_charge(int charge) {}

  virtual float get_chisq() const { return NAN; }
  virtual void set_chisq(float chisq) {}

  virtual unsigned int get_ndf() const { return UINT_MAX; }
  virtual void set_ndf(int ndf) {}

  virtual float get_quality() const { return NAN; }

  virtual float get_dca() const { return NAN; }
  virtual void set_dca(float dca) {}

  virtual float get_dca_error() const { return NAN; }
  virtual void set_dca_error(float dca) {}

  virtual float get_dca2d() const { return NAN; }
  virtual void set_dca2d(float dca2d) {}

  virtual float get_dca2d_error() const { return NAN; }
  virtual void set_dca2d_error(float error) {}

  virtual float get_dca3d_xy() const { return NAN; }
  virtual void set_dca3d_xy(float dcaxy) {}

  virtual float get_dca3d_xy_error() const { return NAN; }
  virtual void set_dca3d_xy_error(float error) {}

  virtual float get_dca3d_z() const { return NAN; }
  virtual void set_dca3d_z(float dcaz) {}

  virtual float get_dca3d_z_error() const { return NAN; }
  virtual void set_dca3d_z_error(float error) {}

  virtual float get_x() const { return NAN; }
  virtual void set_x(float x) {}

  virtual float get_y() const { return NAN; }
  virtual void set_y(float y) {}

  virtual float get_z() const { return NAN; }
  virtual void set_z(float z) {}

  virtual float get_pos(unsigned int i) const { return NAN; }

  virtual float get_px() const { return NAN; }
  virtual void set_px(float px) {}

  virtual float get_py() const { return NAN; }
  virtual void set_py(float py) {}

  virtual float get_pz() const { return NAN; }
  virtual void set_pz(float pz) {}

  virtual float get_mom(unsigned int i) const { return NAN; }

  virtual float get_p() const { return NAN; }
  virtual float get_pt() const { return NAN; }
  virtual float get_eta() const { return NAN; }
  virtual float get_phi() const { return NAN; }

  virtual float get_error(int i, int j) const { return NAN; }
  virtual void set_error(int i, int j, float value) {}

  //
  // state methods -------------------------------------------------------------
  //
  virtual bool empty_states() const { return false; }
  virtual size_t size_states() const { return 0; }
  virtual size_t count_states(float pathlength) const { return 0; }
  virtual void clear_states() {}

  virtual const SvtxTrackState* get_state(float pathlength) const { return nullptr; }
  virtual SvtxTrackState* get_state(float pathlength) { return nullptr; }
  virtual SvtxTrackState* insert_state(const SvtxTrackState* state) { return nullptr; }
  virtual size_t erase_state(float pathlength) { return 0; }

  virtual ConstStateIter begin_states() const;
  virtual ConstStateIter find_state(float pathlength)  const;
  virtual ConstStateIter end_states() const;

  virtual StateIter begin_states();
  virtual StateIter find_state(float pathlength);
  virtual StateIter end_states();

  //
  // associated cluster ids methods --------------------------------------------
  //

  // needed by old tracking

  //! deprecated - please use cluster keys instead
  virtual void clear_clusters() {}
  //! deprecated - please use cluster keys instead
  virtual bool empty_clusters() const { return false; }
  //! deprecated - please use cluster keys instead
  virtual size_t size_clusters() const { return 0; }

  //! deprecated - please use cluster keys instead
  virtual void insert_cluster(unsigned int clusterid) {}
  //! deprecated - please use cluster keys instead
  virtual size_t erase_cluster(unsigned int clusterid) { return 0; }
  //! deprecated - please use cluster keys instead
  virtual ConstClusterIter begin_clusters() const;
  //! deprecated - please use cluster keys instead
  virtual ConstClusterIter find_cluster(unsigned int clusterid) const;
  //! deprecated - please use cluster keys instead
  virtual ConstClusterIter end_clusters() const;
  //! deprecated - please use cluster keys instead
  virtual ClusterIter begin_clusters();
  //! deprecated - please use cluster keys instead
  virtual ClusterIter find_cluster(unsigned int clusterid);
  //! deprecated - please use cluster keys instead
  virtual ClusterIter end_clusters();

  // needed by new tracking
  virtual void clear_cluster_keys() {}
  virtual bool empty_cluster_keys() const { return false; }
  virtual size_t size_cluster_keys() const { return 0; }

  virtual void insert_cluster_key(TrkrDefs::cluskey clusterid) {}
  virtual size_t erase_cluster_key(TrkrDefs::cluskey clusterid) { return 0; }
  virtual ConstClusterKeyIter find_cluster_key(TrkrDefs::cluskey clusterid) const;
  virtual ConstClusterKeyIter begin_cluster_keys() const;
  virtual ConstClusterKeyIter end_cluster_keys() const;
  virtual ClusterKeyIter begin_cluster_keys();
  virtual ClusterKeyIter find_cluster_keys(unsigned int clusterid);
  virtual ClusterKeyIter end_cluster_keys();

  //
  // calo projection methods ---------------------------------------------------
  //
  virtual float get_cal_dphi(CAL_LAYER layer) const { return 0.; }
  virtual void set_cal_dphi(CAL_LAYER layer, float dphi) {}

  virtual float get_cal_deta(CAL_LAYER layer) const { return 0.; }
  virtual void set_cal_deta(CAL_LAYER layer, float deta) {}

  virtual float get_cal_energy_3x3(CAL_LAYER layer) const { return 0.; }
  virtual void set_cal_energy_3x3(CAL_LAYER layer, float energy_3x3) {}

  virtual float get_cal_energy_5x5(CAL_LAYER layer) const { return 0.; }
  virtual void set_cal_energy_5x5(CAL_LAYER layer, float energy_5x5) {}

  virtual unsigned int get_cal_cluster_id(CAL_LAYER layer) const { return 0; }
  virtual void set_cal_cluster_id(CAL_LAYER layer, unsigned int id) {}

  virtual TrkrDefs::cluskey get_cal_cluster_key(CAL_LAYER layer) const { return 0; }
  virtual void set_cal_cluster_key(CAL_LAYER layer, TrkrDefs::cluskey key) {}

  virtual float get_cal_cluster_e(CAL_LAYER layer) const { return 0.; }
  virtual void set_cal_cluster_e(CAL_LAYER layer, float e) {}

  // Acts methods for use by Acts modules only
  virtual float get_acts_covariance(unsigned int i, unsigned int j) const { return NAN;}
  virtual void set_acts_covariance(unsigned int i, unsigned int j, float value) {}
 
  

  //
  // truth track interface ---------------------------------------------------
  //

  //SvtxTrack_FastSim
  virtual unsigned int get_truth_track_id() const { return UINT_MAX; }
  virtual void set_truth_track_id(unsigned int truthTrackId) {}
  virtual void set_num_measurements(int nmeas) {}
  virtual unsigned int get_num_measurements() const { return 0; }

  //SvtxTrack_FastSim_v1
  typedef std::map<int, std::set<PHG4HitDefs::keytype> > HitIdMap;
  typedef HitIdMap::iterator HitIdIter;
  typedef HitIdMap::const_iterator HitIdConstIter;

  virtual bool empty_g4hit_id() const { return true; }
  virtual size_t size_g4hit_id() const { return 0; }
  virtual void add_g4hit_id(int volume, PHG4HitDefs::keytype id) {}
  virtual HitIdIter begin_g4hit_id();
  virtual HitIdConstIter begin_g4hit_id() const;
  virtual HitIdIter find_g4hit_id(int volume);
  virtual HitIdConstIter find_g4hit_id(int volume) const;
  virtual HitIdIter end_g4hit_id();
  virtual HitIdConstIter end_g4hit_id() const;
  virtual size_t remove_g4hit_id(int volume, PHG4HitDefs::keytype id) { return 0; }
  virtual size_t remove_g4hit_volume(int volume) { return 0; }
  virtual void clear_g4hit_id() {}
  virtual const HitIdMap& g4hit_ids() const;

 protected:
  SvtxTrack() {}

  ClassDef(SvtxTrack, 1);
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:19:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Tracking.C:16:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackreco/PHCASeeding.h:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackreco/ALICEKF.h:4:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase_historic/SvtxTrack_v2.h:4:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase_historic/SvtxTrack.h:267:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(SvtxTrack, 1);
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class SvtxTrack_v2 with content:

#line 1 "SvtxTrack_v2_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASEHISTORIC_SVTXTRACKV2_H
#define TRACKBASEHISTORIC_SVTXTRACKV2_H

#include "SvtxTrack.h"
#include "SvtxTrackState.h"

#include <trackbase/TrkrDefs.h>

#include <cmath>
#include <cstddef>  // for size_t
#include <iostream>
#include <map>
#include <utility>  // for pair

class PHObject;

class SvtxTrack_v2: public SvtxTrack
{
 public:
  SvtxTrack_v2();
  
  //* base class copy constructor
  SvtxTrack_v2( const SvtxTrack& );
  
  //* copy constructor
  SvtxTrack_v2(const SvtxTrack_v2& );
  
  //* assignment operator
  SvtxTrack_v2& operator=(const SvtxTrack_v2& track);

  //* destructor
  virtual ~SvtxTrack_v2(); 

  // The "standard PHObject response" functions...
  void identify(std::ostream& os = std::cout) const;
  void Reset() { *this = SvtxTrack_v2(); }
  int isValid() const;
  PHObject* CloneMe() const { return new SvtxTrack_v2(*this); }

  // copy content from base class
  virtual void CopyFrom( const SvtxTrack& );
  virtual void CopyFrom( SvtxTrack* source )
  { CopyFrom( *source ); }

  //
  // basic track information ---------------------------------------------------
  //

  unsigned int get_id() const { return _track_id; }
  void set_id(unsigned int id) { _track_id = id; }

  unsigned int get_vertex_id() const { return _vertex_id; }
  void set_vertex_id(unsigned int id) { _vertex_id = id; }

  bool get_positive_charge() const { return _is_positive_charge; }
  void set_positive_charge(bool ispos) { _is_positive_charge = ispos; }

  int get_charge() const { return (get_positive_charge()) ? 1 : -1; }
  void set_charge(int charge) { (charge > 0) ? set_positive_charge(true) : set_positive_charge(false); }

  float get_chisq() const { return _chisq; }
  void set_chisq(float chisq) { _chisq = chisq; }

  unsigned int get_ndf() const { return _ndf; }
  void set_ndf(int ndf) { _ndf = ndf; }

  float get_quality() const { return (_ndf != 0) ? _chisq / _ndf : NAN; }

  float get_dca() const { return _dca; }
  void set_dca(float dca) { _dca = dca; }

  float get_dca_error() const { return _dca_error; }
  void set_dca_error(float dca_error) { _dca_error = dca_error; }

  float get_dca2d() const { return _dca2d; }
  void set_dca2d(float dca2d) { _dca2d = dca2d; }

  float get_dca2d_error() const { return _dca2d_error; }
  void set_dca2d_error(float error) { _dca2d_error = error; }

  float get_dca3d_xy() const { return _dca3d_xy; }
  void set_dca3d_xy(float dcaxy) { _dca3d_xy = dcaxy; }

  float get_dca3d_xy_error() const { return _dca3d_xy_error; }
  void set_dca3d_xy_error(float error) { _dca3d_xy_error = error; }

  float get_dca3d_z() const { return _dca3d_z; }
  void set_dca3d_z(float dcaz) { _dca3d_z = dcaz; }

  float get_dca3d_z_error() const { return _dca3d_z_error; }
  void set_dca3d_z_error(float error) { _dca3d_z_error = error; }

  float get_x() const { return _states.find(0.0)->second->get_x(); }
  void set_x(float x) { _states[0.0]->set_x(x); }

  float get_y() const { return _states.find(0.0)->second->get_y(); }
  void set_y(float y) { _states[0.0]->set_y(y); }

  float get_z() const { return _states.find(0.0)->second->get_z(); }
  void set_z(float z) { _states[0.0]->set_z(z); }

  float get_pos(unsigned int i) const { return _states.find(0.0)->second->get_pos(i); }

  float get_px() const { return _states.find(0.0)->second->get_px(); }
  void set_px(float px) { _states[0.0]->set_px(px); }

  float get_py() const { return _states.find(0.0)->second->get_py(); }
  void set_py(float py) { _states[0.0]->set_py(py); }

  float get_pz() const { return _states.find(0.0)->second->get_pz(); }
  void set_pz(float pz) { _states[0.0]->set_pz(pz); }

  float get_mom(unsigned int i) const { return _states.find(0.0)->second->get_mom(i); }

  float get_p() const { return sqrt(pow(get_px(), 2) + pow(get_py(), 2) + pow(get_pz(), 2)); }
  float get_pt() const { return sqrt(pow(get_px(), 2) + pow(get_py(), 2)); }
  float get_eta() const { return asinh(get_pz() / get_pt()); }
  float get_phi() const { return atan2(get_py(), get_px()); }

  float get_error(int i, int j) const { return _states.find(0.0)->second->get_error(i, j); }
  void set_error(int i, int j, float value) { return _states[0.0]->set_error(i, j, value); }

  //
  // state methods -------------------------------------------------------------
  //
  bool empty_states() const { return _states.empty(); }
  size_t size_states() const { return _states.size(); }
  size_t count_states(float pathlength) const { return _states.count(pathlength); }
  void clear_states();

  const SvtxTrackState* get_state(float pathlength) const;
  SvtxTrackState* get_state(float pathlength);
  SvtxTrackState* insert_state(const SvtxTrackState* state);
  size_t erase_state(float pathlength);

  ConstStateIter begin_states() const { return _states.begin(); }
  ConstStateIter find_state(float pathlength) const { return _states.find(pathlength); }
  ConstStateIter end_states() const { return _states.end(); }

  StateIter begin_states() { return _states.begin(); }
  StateIter find_state(float pathlength) { return _states.find(pathlength); }
  StateIter end_states() { return _states.end(); }

  //
  // associated cluster ids methods --------------------------------------------
  //

  // needed by old tracking
  void clear_clusters() { _cluster_ids.clear(); }
  bool empty_clusters() const { return _cluster_ids.empty(); }
  size_t size_clusters() const { return _cluster_ids.size(); }

  void insert_cluster(unsigned int clusterid) { _cluster_ids.insert(clusterid); }
  size_t erase_cluster(unsigned int clusterid) { return _cluster_ids.erase(clusterid); }
  ConstClusterIter begin_clusters() const { return _cluster_ids.begin(); }
  ConstClusterIter find_cluster(unsigned int clusterid) const { return _cluster_ids.find(clusterid); }
  ConstClusterIter end_clusters() const { return _cluster_ids.end(); }
  ClusterIter find_cluster(unsigned int clusterid) { return _cluster_ids.find(clusterid); }
  ClusterIter begin_clusters() { return _cluster_ids.begin(); }
  ClusterIter end_clusters() { return _cluster_ids.end(); }

  // needed by new tracking
  void clear_cluster_keys() { _cluster_keys.clear(); }
  bool empty_cluster_keys() const { return _cluster_keys.empty(); }
  size_t size_cluster_keys() const { return _cluster_keys.size(); }

  void insert_cluster_key(TrkrDefs::cluskey clusterid) { _cluster_keys.insert(clusterid); }
  size_t erase_cluster_key(TrkrDefs::cluskey clusterid) { return _cluster_keys.erase(clusterid); }
  ConstClusterKeyIter find_cluster_key(TrkrDefs::cluskey clusterid) const { return _cluster_keys.find(clusterid); }
  ConstClusterKeyIter begin_cluster_keys() const { return _cluster_keys.begin(); }
  ConstClusterKeyIter end_cluster_keys() const { return _cluster_keys.end(); }
  ClusterKeyIter find_cluster_keys(unsigned int clusterid) { return _cluster_keys.find(clusterid); }
  ClusterKeyIter begin_cluster_keys() { return _cluster_keys.begin(); }
  ClusterKeyIter end_cluster_keys() { return _cluster_keys.end(); }

  //
  // calo projection methods ---------------------------------------------------
  //
  float get_cal_dphi(CAL_LAYER layer) const;
  void set_cal_dphi(CAL_LAYER layer, float dphi) { _cal_dphi[layer] = dphi; }

  float get_cal_deta(CAL_LAYER layer) const;
  void set_cal_deta(CAL_LAYER layer, float deta) { _cal_deta[layer] = deta; }

  float get_cal_energy_3x3(CAL_LAYER layer) const;
  void set_cal_energy_3x3(CAL_LAYER layer, float energy_3x3) { _cal_energy_3x3[layer] = energy_3x3; }

  float get_cal_energy_5x5(CAL_LAYER layer) const;
  void set_cal_energy_5x5(CAL_LAYER layer, float energy_5x5) { _cal_energy_5x5[layer] = energy_5x5; }

  unsigned int get_cal_cluster_id(CAL_LAYER layer) const;
  void set_cal_cluster_id(CAL_LAYER layer, unsigned int id) { _cal_cluster_id[layer] = id; }

  TrkrDefs::cluskey get_cal_cluster_key(CAL_LAYER layer) const;
  void set_cal_cluster_key(CAL_LAYER layer, TrkrDefs::cluskey id) { _cal_cluster_key[layer] = id; }

  float get_cal_cluster_e(CAL_LAYER layer) const;
  void set_cal_cluster_e(CAL_LAYER layer, float e) { _cal_cluster_e[layer] = e; }

  // ACTS track information for use by ACTS modules only
  float get_acts_covariance(unsigned int i, unsigned int j) const {return _acts_trajectory_covariance[i][j]; }
  void set_acts_covariance(unsigned int i, unsigned int j, float value) { _acts_trajectory_covariance[i][j] = value; }

 private:

  //! acts covariance matrix
  float _acts_trajectory_covariance[6][6] = {};

  // track information
  unsigned int _track_id = UINT_MAX;
  unsigned int _vertex_id = UINT_MAX;
  bool _is_positive_charge = false;
  float _chisq = NAN;
  unsigned int _ndf = 0;

  // extended track information (non-primary tracks only)
  float _dca = NAN;
  float _dca_error = NAN;
  float _dca2d = NAN;
  float _dca2d_error = NAN;
  float _dca3d_xy = NAN;
  float _dca3d_xy_error = NAN;
  float _dca3d_z = NAN;
  float _dca3d_z_error = NAN;

  // extended track information (primary tracks only)

  // track state information
  StateMap _states;  //< path length => state object

  // cluster contents
  ClusterSet _cluster_ids;
  ClusterKeySet _cluster_keys;

  // calorimeter matches
  std::map<CAL_LAYER, float> _cal_dphi;
  std::map<CAL_LAYER, float> _cal_deta;
  std::map<CAL_LAYER, float> _cal_energy_3x3;
  std::map<CAL_LAYER, float> _cal_energy_5x5;
  std::map<CAL_LAYER, int> _cal_cluster_id;
  std::map<CAL_LAYER, TrkrDefs::cluskey> _cal_cluster_key;
  std::map<CAL_LAYER, float> _cal_cluster_e;

  ClassDef(SvtxTrack_v2, 2)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:19:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Tracking.C:16:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackreco/PHCASeeding.h:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackreco/ALICEKF.h:4:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase_historic/SvtxTrack_v2.h:244:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(SvtxTrack_v2, 2)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class TrkrClusterContainer with content:

#line 1 "TrkrClusterContainer_Dict dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
#ifndef TRACKBASE_TRKRCLUSTERCONTAINER_H
#define TRACKBASE_TRKRCLUSTERCONTAINER_H

/**
 * @file trackbase/TrkrClusterContainer.h
 * @author D. McGlinchey, Hugo Pereira Da Costa
 * @date June 2018
 * @brief Cluster container base class
 */

#include "TrkrDefs.h"

#include <phool/PHObject.h>

#include <map>
#include <iostream>          // for cout, ostream
#include <utility>           // for pair

class TrkrCluster;

/**
 * @brief Cluster container object
 */
class TrkrClusterContainer : public PHObject
{
 public:

  //!@name convenient shortuts
  //@{
  using Map = std::map<TrkrDefs::cluskey, TrkrCluster *>;
  using Iterator = Map::iterator;
  using ConstIterator = Map::const_iterator;
  using Range = std::pair<Iterator, Iterator>;
  using ConstRange = std::pair<ConstIterator, ConstIterator>;
  //@}

  //! constructor
  TrkrClusterContainer() = default;

  //! reset method
  virtual void Reset() {}

  //! identify object
  virtual void identify(std::ostream &os = std::cout) const {}

  //! add a cluster
  virtual ConstIterator addCluster(TrkrCluster*);

  //! add a cluster with specific key
  virtual ConstIterator addClusterSpecifyKey(const TrkrDefs::cluskey, TrkrCluster* );

  //! remove cluster
  virtual void removeCluster(TrkrDefs::cluskey) {}

  //! remove cluster
  virtual void removeCluster(TrkrCluster* ) {}

  //! find cluster matching key if any, add a new one otherwise and return cluster
  virtual Iterator findOrAddCluster(TrkrDefs::cluskey);
  
  //! return all clusters
  virtual ConstRange getClusters() const;

  //! get all clusters matching hitset
  virtual ConstRange getClusters(TrkrDefs::hitsetkey) const;

  //! get pointer to map containing clusters mathching hitset
  virtual Map* getClusterMap(TrkrDefs::hitsetkey) { return nullptr; }

  //! find cluster matching given key
  virtual TrkrCluster* findCluster(TrkrDefs::cluskey) const { return nullptr; }

  //! total number of clusters
  virtual unsigned int size() const { return 0; }

  private:

  ClassDef(TrkrClusterContainer, 1)

};

#endif //TRACKBASE_TRKRCLUSTERCONTAINER_H

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_11:1:
In file included from /gpfs/mnt/gpfs02/eic/kkauder/scratch/spacktest/example_workflows/fun4all/payload/Fun4All_G4_sPHENIX.C:19:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/rootmacros/G4_Tracking.C:16:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackreco/PHCASeeding.h:15:
In file included from /cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackreco/ALICEKF.h:6:
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/release/release_new/new.2/include/trackbase/TrkrClusterContainer.h:78:3: warning: ambiguous expansion of macro 'ClassDef' [-Wambiguous-macro]
  ClassDef(TrkrClusterContainer, 1)
  ^
/cvmfs/sphenix.sdcc.bnl.gov/gcc-8.3/opt/sphenix/core/root-6.22.02/include/Rtypes.h:322:9: note: expanding this definition of 'ClassDef'
#define ClassDef(name,id) \
        ^
input_line_7:22:9: note: other definition of 'ClassDef'
#define ClassDef(name, id) \
        ^

 *** Break *** keyboard interrupt
